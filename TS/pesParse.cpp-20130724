
/*
	pesParse.cpp
		2012.8.15 separate from pes.cpp
		2012.8.17 Use AddrSrc
		2012.8.23 GetBitStream() : processing "00 00 03" bug fixed
		2012.9.21 Delete userdata_ptsh/l
		2012.9.24 Merge shira source (frame_packing_arrangement info)
		2012.9.26 pes() : pes.cpp -> pesParse.cpp 
		2012.9.26 +O : bShowPOC
		2012.9.27 +S : bDumpSPS
			    pic_order_cnt_lsb
			    Support
				avc_log2_max_pic_order_cnt_lsb_minus4
				avc_log2_max_frame_num_minus4
			  +F : bFramePackingArrangement=1
			  	Parse PPS
		2012.10.3 malloc Packets
			  malloc g_update_addr_S/..
			  malloc g_update_addr/..
			  malloc BitBuffer
		2012.10.5 Parse PPS more
			  Parse Slice header more (ref_pic_list)
		2012.10.9 +s : bParseSlice=1
			  +e : bDebugSEI=1
			  bug fix : modification_of_pic_nums_idc
		2012.10.10 separate nal_ref_idc, nal_unit_type
			   check forbidden_zero_bit
		2012.11.12 user_data_registered/unregister should return 0
		2012.11.15 use bAlarmAVC, nAlarm : -M : bAlarmAVC=0
		2013.2.7   view_scalability_info()
				not parse internal
		2013.4.10  AVS
		2013.5. 9  =P : bDebugPES
		2013.6.17 =D : bDSS
		2013.7.17  Separate to pesAVC.cpp
 */

#include <stdio.h>
#include <stdlib.h>	// exit
#include <string.h>	// strlen

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>	// close

#include <sys/mman.h>	// mmap

#include "lib.h"
#include "tsLib.h"
#include "parseLib.h"
#include "pesParse.h"

#define BUF_SIZE	1024*4
//#define ADDR_MAX	1024*1024*16
#define MAX_UPDATE	1024*64

#define INVALID_OFFSET	0x12345678

//typedef unsigned int UINT;

// -------------------------------------------------------------
static int bUseAddrFile=1;
static int bShowUpdate=0;
extern int bDebugPES;

// -------------------------------------------------------------
extern int bDebug;
int bDump  = 0;
int bDumpSlice=0;
int bDisplayTS=0;
//int bDebugGol=0;
//int bDebugGolB=0;
//int bShowGolomb=0;		// Dump Golomb parse
int bShow=0;
int bSkipError=0;
static int bShowDetail=0;		// AVC show NAL parse
//static int bShowSEI=0;
int bDebugSkip=0;		// Dump with skipContent()
int bShowBitAddr=0;		// Show BitAddr/Offset/Readed
int bDebugSEI=0;		// Debug SEI
int bShowNALinfo=0;		// CountNAL message
int bDSS=0;
int bUserData=0;
int bShowMvcExtention=0;
int bShowMvcScalable=0;
static int bDumpSPS=0;
//static int bParsePOC=1;
static int bParseSlice=0;
static int bAlarmAVC=1;

int bDebugRemux=0;
static int bShowPOC=0;
static int bFramePackingArrangement=0;

static int DSS_PCT=(-1);
static char DSS_Addr[80];

int validStart = (-1);
int validEnd   = (-1);

#define EDIT_NONE	0
#define EDIT_CUT	1
#define EDIT_INS	2
//static int bEditSPS=EDIT_NONE;

static int bRemovePicStruct= EDIT_NONE;
static int nEditFrameMbs = (-1);
// make timing_info_present_flag=0 and remove timing_info
static int bRemoveTimingInfo=0;	

void init_AVC();

#if 0
static int g_DTSL = (-1);
static int g_DTSH = (-1);
static int g_PTSL = (-1);
static int g_PTSH = (-1);
#endif
extern int g_DTSL;
extern int g_DTSH;
extern int g_PTSL;
extern int g_PTSH;

static int es_addr =  0;

int SpecialStartAddr=0;
int SpecialStartBits=0;
int SpecialEndAddr=0;
int SpecialEndBits=0;

int nSequence=0;
int nSequenceExtension=0;
int nSequenceDisplayExtension=0;
#if 0
int nSelSt=(-1);
int nSelEn=(-1);
#endif
int bDumpSequenceDisplayExtension = 0;
int bDumpSequenceExtension = 0;
int bDumpSequence = 0;

#define MAX_PACKETS 1024*64
//int Packets[MAX_PACKETS+4];	// 16bit
int *Packets=NULL;

unsigned int *g_update_addrS = NULL;
unsigned int *g_update_bit_S = NULL;	// remove start
unsigned int *g_update_bit_E = NULL;	// remove end
unsigned int *g_update_bit_T = NULL;	// structure end : つめる
unsigned int *g_update_mode  = NULL;

int g_update_countS=0;

#if 0
// ---------------------------------------------
// AVC
// for each SPS
//int avc_nal_hrd_parameters_present_flag=(-1);
//int avc_vcl_hrd_parameters_present_flag=(-1);
//int avc_pic_struct_present_flag = (-1);
//int avc_CpbDpbDelaysPresentFlag = (-1);
#define MAX_SPS 32
int avc_nal_hrd_parameters_present_flag[MAX_SPS];
int avc_vcl_hrd_parameters_present_flag[MAX_SPS];
int avc_pic_struct_present_flag[MAX_SPS];
int avc_CpbDpbDelaysPresentFlag[MAX_SPS];

int PPStoSPS[MAX_SPS];
int avc_PPS_id = (-1);

int avc_cpb_cnt = (-1);
int avc_CpgDpbDelaysPresentFlag = (-1);
int avc_time_offset_length = (-1);

int avc_initial_cpb_removal_delay_length = (-1);
int avc_cpb_removal_delay_length = (-1);
int avc_dpb_output_delay_length = (-1);
int avc_separate_colour_plane_flag=(-1);
int avc_frame_mbs_only_flag = (-1);
int avc_IdrPicFlag = 0;
int avc_pic_order_cnt_type = (-1);
int avc_log2_max_pic_order_cnt_lsb_minus4 = (-1);
int avc_log2_max_frame_num_minus4 = (-1);
int avc_delta_pic_order_always_zero_flag  = (-1);
// PPS
int avc_bottom_field_pic_order_in_frame_present_flag = (-1);
int avc_redundant_pic_cnt_present_flag = (-1);

int n_vui_parameters = 0;
int n_sequenceParameters = 0;
int n_pan_scan = 0;
#endif
// ---------------------------------------------
// header item
//
int items[ID_MAX];
int value[ID_MAX];

// BitAddr
//#define BIT_BUFFER_SIZE	1024*64
#define BIT_BUFFER_SIZE	1024*1024*4

//static unsigned char BitBuffer[BIT_BUFFER_SIZE];
static unsigned char *BitBuffer = NULL;
static unsigned int BitAddr = 0;
static int BitOffset=0;
static int BitReaded=0;
static int BitSkip  =0;
static int nZero=0;
static int b_user_data=0;
static unsigned int picture_coding_type=0;

int GetBitAddr()
{
	return BitAddr;
}
int GetBitOffset()
{
	return BitOffset;
}
int GetBitSkip()
{
	return BitSkip;
}

void ShowBitAddr( )
{
	if( bShowBitAddr )
	{
	    int target = BitAddr+BitOffset/8;
	    fprintf( stdout, "Target   =0x%X(0x%X) %dbit\n", 
	    	(UINT)target, (UINT)SrcAddr(target,0), BitOffset%8 );

	    fprintf( stdout, "BitAddr  =0x%X(0x%X)\n", 
	    	(UINT)BitAddr, (UINT)SrcAddr(BitAddr,0) );
	    fprintf( stdout, "BitOffset=%d\n", BitOffset );
	    fprintf( stdout, "BitReaded=%d\n", BitReaded );
	}
}

void DumpBitBuffer( )
{
int j;
	if( BitBuffer )
	{
	    for( j=0; j<BitReaded/8; j++ )
	    {
		fprintf( stdout, "%02X ", BitBuffer[j] );
#if 0
		if( ((i+j)&15)==15 )
#else
		if( (j&15)==15 )
#endif
		    fprintf( stdout, "\n" );
	    }
	}
}

void InitBitStream( )
{
//	fprintf( stdout, "InitBitStream(0x%X)\n", g_addr );
	BitAddr  = g_addr;
	BitOffset= 0;
	BitReaded= 0;
	BitSkip  = 0;
	nZero    = 0;
}
int GetBitStream( FILE *fp, int nBit )
{
static unsigned char BitMask[] = {
0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01
};
	if( BitBuffer==NULL )
	{
	    BitBuffer = (unsigned char *)malloc( BIT_BUFFER_SIZE );
	    if( BitBuffer==NULL )
	    {
	    	fprintf( stdout, "Can't malloc BitBuffer\n" );
		exit( 1 );
	    }
	}
	if( bDebug )
	fprintf( stdout, "GetBitStream(%d)\n", nBit );
	int nPos = BitOffset/8;
	if( (BitReaded/8)>=BIT_BUFFER_SIZE )
	{
	    fprintf( stdout, "BitBuffer full (%d)\n", BitReaded );
	    EXIT();
	}
	if( (BitOffset+nBit)>BitReaded )
	{	// たりないのでよむ
	    int ii;
	    int nByte = BitOffset+nBit-BitReaded;
	    nByte = (nByte+7)/8;
	    if( bDebug )
	    fprintf( stdout, "Requested %d bytes (%d)\n", 
	    	nByte, BitReaded );
	    int readed = gread( &BitBuffer[BitReaded/8], nByte, 1, fp );
	    if( readed<1 )
	    {
		CannotRead( NULL );
		return -1;
	    }
	    for( ii=0; ii<nByte; ii++ )
	    {
#if 0
		fprintf( stdout, "%8X,nZero=%d [%02X]\n", 
			g_addr, nZero, BitBuffer[BitReaded/8+ii] );
#endif
	    	if( nZero==2 )
		{
		    if( BitBuffer[BitReaded/8+ii]==3 )
		    {
		    	// 00 00 03
			if( bDebug )
			    fprintf( stdout, "Found(00 00 03)@0x%X+%d/8\n",
				BitAddr, BitOffset );
#if 0
int iii;
for( iii=0;iii<nByte;iii++ )
{
    fprintf( stdout, "%02X ", BitBuffer[BitReaded/8+iii] );
}
fprintf( stdout, "\n" );
#endif
			BitSkip++;
			int jj;
			for( jj=ii; jj<nByte; jj++ )
			{
			    BitBuffer[BitReaded/8+jj] 
			    	= BitBuffer[BitReaded/8+jj+1];
			}
			readed = gread( &BitBuffer[BitReaded/8+nByte-1],
				1, 1, fp );
			if( readed<1 )
			{
			    CannotRead( NULL );
			    return -1;
			}
			nZero=0;
//			if( BitBuffer[BitReaded/8+nByte-1]==0 ) // 2012.5.7
//			if( BitBuffer[BitReaded/8+ii]==0 ) // 2012.8.23
//			    nZero++;	// 2012.5.7
#if 0
for( iii=0;iii<nByte;iii++ )
{
    fprintf( stdout, "%02X ", BitBuffer[BitReaded/8+iii] );
}
fprintf( stdout, "\n" );
#endif
//			break;	// comment out 2012.8.23
		    }
		}
	    	if( BitBuffer[BitReaded/8+ii] == 0 )
		    nZero++;
		else
		    nZero=0;
	    }
	    if( bDebug )
	    {
	    fprintf( stdout, "%d bits readed\n", readed*nByte*8 );
	    for( ii=0; ii<nByte; ii++ )
	    {
	    	fprintf( stdout, "%02X ", BitBuffer[BitReaded/8+ii] );
	    }
	    fprintf( stdout, "\n" );
	    }
	    BitReaded += nByte*8;
	}
	unsigned int data=0;
	int rBit = nBit+BitOffset-nPos*8;
	int rP = 0;
	int data8 = (-1);
	while( rBit>0 )
	{
	    data = (data<<8) | BitBuffer[nPos+rP]; 
	    data8= BitBuffer[nPos+rP];
	    if( rP==0 )
	    {
	    	if( BitOffset%8 )
		    data = data & BitMask[BitOffset%8];
	    }
	    rBit-=8;
	    rP++;
	}
	BitOffset += nBit;
	if( rBit<0 )
	    data = data>>(-rBit);
	if( bDebugGolB )
	{
	    int n;
	    int mask = 1<<(nBit-1);
	    int v = data;
	    for( n=0; n<nBit; n++ )
	    {
	    	if( v & mask )
		    fprintf( stdout, "1 " );
		else
		    fprintf( stdout, "0 " );
		v=v<<1;
	    }
	    fprintf( stdout, "\n" );
	}

	if( bDebug )
	fprintf( stdout, "BitOffset=%d, BitReaded=%d, data=0x%X(0x%X)\n",
		BitOffset, BitReaded, data, data8 );
	return data;
}

// --------------------------------------------------
// Exp-Golomb codes
//#define MAX_BASE	26
#define MAX_BASE	30
static int base[MAX_BASE];
int GetBitStreamGolomb( FILE *fp )
{
int nBit;
int i, n;
int bValue, value=0;
/*
static int base[] = {
	0, 1, 3, 7, 15, 31, 
};
*/
	if( bShowGolomb )
	fprintf( stdout, "Golomb:" );
#if 0
	base[0] = 0;
#else
	if( base[1]==0 )
	{
	    for( n=1; n<MAX_BASE; n++ )
	    {
		base[n] = base[n-1]*2+1;
	    }
	}
#endif
	bDebugGolB = 0;
	for( n=0; n<MAX_BASE; n++ )
	{
	    nBit = GetBitStream( fp, 1 );
	    if( bShowGolomb )
	    fprintf( stdout, "%d ", nBit );
	    if( nBit==1 )
	    	break;
	}
	if( n>=MAX_BASE )
	{
	    fprintf( stdout, "Invalid Golomb\n" );
	    return -1;
	}
	bValue = 0;
	for( i=0; i<n; i++ )
	{
	    nBit = GetBitStream( fp, 1 );
	    if( bShowGolomb )
	    fprintf( stdout, "%d ", nBit );
	    bValue = (bValue<<1) | nBit;
	}
	bDebugGolB = bDebugGol;
	value = base[n] + bValue;
	if( bShowGolomb )
	fprintf( stdout, " : value=%d (%X,%d=%X,%d)\n", 
		value, BitAddr, BitOffset, BitAddr+BitOffset/8, BitOffset%8 );
	return value;
}

#if 0
int GolombNext( int cVal, int step )
{
int base[MAX_BASE];	// 0, 1, 3, 7, 15, 31, 
int value = 0;
int n, i;
	base[0] = 0;
	for( n=1; n<MAX_BASE; n++ )
	{
	    base[n] = base[n-1]*2+1;
//	    fprintf( stdout, "base[%d]=%d, cVal=%d\n", n, base[n], cVal );
	    if( cVal<base[n] )
	    	break;
	}
	if( n>=MAX_BASE )
	    return cVal;
	value = cVal;
	if( step>=0 )
	{
	    for( i=0; i<step; i++ )
	    {
		value=value+1;
		if( value>=base[n] )
		    value = base[n-1];
	    }
	} else {
	    for( i=0; i<-step; i++ )
	    {
		value=value-1;
		if( value<=base[n-1] )
		    value = base[n]-1;
	    }
	}
//	fprintf( stdout, "GolombNext(%d) = %d\n", cVal, value );
	return value;
}

int GolombValue( int cVal )
{
int base[MAX_BASE+1];	// 0, 1, 3, 7, 15, 31, 
int value =0;
int n;
	base[0] = 0;
	for( n=0; n<MAX_BASE; n++ )
	{
	    base[n+1] = base[n]*2+1;
	    if( cVal<base[n+1] )
	    	break;
	}
	if( n>=MAX_BASE )
	{
	    fprintf( stdout, "Can't convert GolmbValue(%d)\n", cVal );
	    EXIT();
	}
	value = (1<<n) + (cVal-base[n]);
//	fprintf( stdout, "GolombValue(%d) = 0x%X\n", cVal, value );
	return value;
}
#endif

int UpdateProcedure( int nCycle, int id, int size )
{
	if( nSelSt>=0 )
	{
#if 0
	    fprintf( stdout, "nSelSt=%d, Sequence=%d, %d\n",
		nSelSt, nCycle, items[ID_HSV] );
#endif
	    if( (nCycle>=nSelSt) && ((nSelEn<0) || (nCycle<=nSelEn)) )
	    if( items[id]>0 )
	    {
	    	DoUpdate( BitAddr, BitOffset, size, value[id] );
		return 1;
	    }
	}
	return 0;
}

int UpdateProcedureGolomb( int nCycle, int id, int size, int nValue )
{
	if( nSelSt>=0 )
	{
	    if( (nCycle>=nSelSt) && ((nSelEn<0) || (nCycle<=nSelEn)) )
	    if( items[id]>0 )
	    {
		fprintf( stdout, "UpdateProcedureGolomb(%X,%d,%d:%d)\n",
			BitAddr, BitOffset-size, size, nValue );
		DoUpdate( BitAddr, BitOffset-size, size, nValue );
	    }
	}
	return 0;
}

void SetSpecial( int mode )
{
	switch( mode )
	{
	case SET_START :
	    SpecialStartAddr = BitAddr;
	    SpecialStartBits = BitOffset;
	    break;
	case SET_START_END :
	    SpecialStartAddr = BitAddr;
	    SpecialStartBits = BitOffset;
	    SpecialEndBits   = BitOffset+1;
	    break;
	case SET_END :
	    SpecialEndAddr   = BitAddr;
	    SpecialEndBits   = BitOffset;
	    break;
	}
}

#if 0
void ShowBitAddr( )
{
	fprintf( stdout, "BitAddr=(%s), BitOffset=%d\n",
		AddrStr(BitAddr), BitOffset );
}
#endif

int MPEG_Sequence( FILE *fp, unsigned char buffer[] )
{
/*
HSV	12bit
VSV	12bit
ARI	4bit
FRC	4bit
BRV	18bit
MRK	1bit
VBSV	10bit
CPF	1bit
LIQM	1bit
IQM	8*64bit
LNIQM	1bit
NIQM	8*64bit
---------------
(512*2)*n+64bit
1088bit=136byte
*/
int HSV, VSV, ARI, FRC, BRV, MRK, VBSV, CPF, LIQM, LNIQM;
int dummy, i;
	fprintf( stdout, "Sequence() : (%s)\n", AddrStr(g_addr) );
	fprintf( stdout, "**********************************************\n" );
 	InitBitStream();
	UpdateProcedure( nSequence, ID_HSV, 12 );
 	HSV = GetBitStream( fp, 12 );
	UpdateProcedure( nSequence, ID_VSV, 12 );
 	VSV = GetBitStream( fp, 12 );
	UpdateProcedure( nSequence, ID_ARI,  4 );
 	ARI = GetBitStream( fp,  4 );
	UpdateProcedure( nSequence, ID_FRC,  4 );
 	FRC = GetBitStream( fp,  4 );
 	BRV = GetBitStream( fp, 18 );
 	MRK = GetBitStream( fp,  1 );
 	VBSV= GetBitStream( fp, 10 );
 	CPF = GetBitStream( fp,  1 );
 	LIQM= GetBitStream( fp,  1 );
	if( LIQM>0 )
	{
	    for( i=0; i<16; i++ )
		dummy= GetBitStream( fp,  32 );
	}
 	LNIQM= GetBitStream( fp,  1 );
	if( LNIQM>0 )
	{
	    for( i=0; i<16; i++ )
		dummy= GetBitStream( fp,  32 );
	}
	if( bDumpSequence )
	{
	    fprintf( stdout, "HSV=%d\n", HSV );
	    fprintf( stdout, "VSV=%d\n", VSV );
	    fprintf( stdout, "ARI=%d\n", ARI );
	    fprintf( stdout, "FRC=%d\n", FRC );
	    fprintf( stdout, "BRV=%d\n", BRV );
	}
	nSequence++;
	return 0;
}

int SequenceExtension( FILE *fp, unsigned char buffer[] )
{
int PALI, PS, CF, HSE, VSE, BRE, MRK, VBSE, LD, FREn, FREd;
	fprintf( stdout, "SequenceExtension() : (%s)\n", AddrStr(g_addr) );
	fprintf( stdout, "----------------------------------------------\n" );
	UpdateProcedure( nSequence, ID_PALI, 8 );
	PALI = GetBitStream( fp, 8 );
	UpdateProcedure( nSequence, ID_PS,   1 );
	PS   = GetBitStream( fp, 1 );
	CF   = GetBitStream( fp, 2 );
	HSE  = GetBitStream( fp, 2 );
	VSE  = GetBitStream( fp, 2 );
	BRE  = GetBitStream( fp,12 );
	MRK  = GetBitStream( fp, 1 );
	VBSE = GetBitStream( fp, 8 );
	LD   = GetBitStream( fp, 1 );
	FREn = GetBitStream( fp, 2 );
	FREd = GetBitStream( fp, 2 );
	if( bDumpSequenceExtension )
	{
	    fprintf( stdout, "PALI=%d\n", PALI );
	    fprintf( stdout, "PS  =%d\n", PS   );
	    fprintf( stdout, "CF  =%d\n", CF   );
	    fprintf( stdout, "LD  =%d\n", LD   );
	}
	nSequenceExtension++;
	return 0;
}


int SequenceDisplayExtension( FILE *fp, unsigned char buffer[] )
{
int VF, CD, CP, TC, MXC, DHS, MRK, DVS;
	CP = (-1);
	TC = (-1);
	MXC= (-1);

	fprintf( stdout, "SequenceDisplayExtension() : (%s)\n", 
	    AddrStr(g_addr) );
	ShowBitAddr( );
	fprintf( stdout, "==============================================\n" );
	VF   = GetBitStream( fp, 3 );
	CD   = GetBitStream( fp, 1 );
	if( CD==1 )
	{
	    UpdateProcedure( nSequence, ID_CP,   8 );
	    CP   = GetBitStream( fp, 8 );
	    UpdateProcedure( nSequence, ID_TC,   8 );
	    TC   = GetBitStream( fp, 8 );
	    UpdateProcedure( nSequence, ID_MXC,  8 );
	    MXC  = GetBitStream( fp, 8 );
	}
	UpdateProcedure( nSequence, ID_DHS, 14 );
	DHS  = GetBitStream( fp,14 );
	MRK  = GetBitStream( fp, 1 );
	UpdateProcedure( nSequence, ID_DVS, 14 );
	DVS  = GetBitStream( fp,14 );
	if( bDumpSequenceDisplayExtension )
	{
	    fprintf( stdout, "VF =%d\n", VF );
	    fprintf( stdout, "CD =%d\n", CD );
	    fprintf( stdout, "CP =%d\n", CP );
	    fprintf( stdout, "TC =%d\n", TC );
	    fprintf( stdout, "MXC=%d\n", MXC );
	    fprintf( stdout, "DHS=%d\n", DHS );
	    fprintf( stdout, "DVS=%d\n", DVS );
	}
	nSequenceDisplayExtension++;
	return 0;
}
int SequenceScalableExtension( FILE *fp, unsigned char buffer[] )
{
int SM, LID, LLPHS, MRK, LLPVS, HSFm, HSFn, VSFm, VSFn, PME, MTPS, PMO, PMF;
	fprintf( stdout, "SequenceScalableExtension()\n" );
	SM   = GetBitStream( fp, 2 );
	LID  = GetBitStream( fp, 4 );
	LLPHS= GetBitStream( fp,14 );
	MRK  = GetBitStream( fp, 1 );
	LLPVS= GetBitStream( fp,14 );
	HSFm = GetBitStream( fp, 5 );
	HSFn = GetBitStream( fp, 5 );
	VSFm = GetBitStream( fp, 5 );
	VSFn = GetBitStream( fp, 5 );
	PME  = GetBitStream( fp, 1 );
	MTPS = GetBitStream( fp, 1 );
	PMO  = GetBitStream( fp, 3 );
	PMF  = GetBitStream( fp, 3 );
	return 0;
}

int PictureCodingExtention( FILE *fp, unsigned char buffer[] )
{
int FHFC, FVFC, BHFC, BVFC, IDP, PSTR, TFF, FPFD, CMV, QST, IVF;
int AS, RFF, C420T, PF, CDF;
//int VA, FS, SC, BA, SCP;
	if( bShow )
	fprintf( stdout, "PictureCodingExtention() : " );
	FHFC = GetBitStream( fp, 4 );
	FVFC = GetBitStream( fp, 4 );
	BHFC = GetBitStream( fp, 4 );
	BVFC = GetBitStream( fp, 4 );
	IDP  = GetBitStream( fp, 2 );
	PSTR = GetBitStream( fp, 2 );
	TFF  = GetBitStream( fp, 1 );
	FPFD = GetBitStream( fp, 1 );
	CMV  = GetBitStream( fp, 1 );
	QST  = GetBitStream( fp, 1 );
	IVF  = GetBitStream( fp, 1 );
	AS   = GetBitStream( fp, 1 );
	RFF  = GetBitStream( fp, 1 );
	C420T= GetBitStream( fp, 1 );
	PF   = GetBitStream( fp, 1 );
	CDF  = GetBitStream( fp, 1 );
#if 0	// PAL
	VA   = GetBitStream( fp, 1 );
	FS   = GetBitStream( fp, 3 );
	SC   = GetBitStream( fp, 1 );
	BA   = GetBitStream( fp, 7 );
	SCP  = GetBitStream( fp, 8 );
#endif
//	fprintf( stdout, "PSTR=%d\n", PSTR );
	return 0;
}

int PictureDisplayExtension( FILE *fp, unsigned char buffer[] )
{
int FCHO, FCVO;
int MRK;
int i;
//	if( bShow )
	fprintf( stdout, "PictureDisplayExtension() : " );
	ShowBitAddr( );
/*
	ESC,ESCI,<FCHO,MRK,FCVO,MRK>
*/
	for( i=0; i<2; i++ )
	{
	    FCHO = GetBitStream( fp, 16 );// Frame Center Horizontal Offset
	    MRK  = GetBitStream( fp,  1 );// Marker Bit
	    FCVO = GetBitStream( fp, 16 );// Frame Center Vertical Offset
	    MRK  = GetBitStream( fp,  1 );// Marker Bit
	    fprintf( stdout, "FCHO[%d]=%4d\n", i, FCHO );
	    fprintf( stdout, "FCVO[%d]=%4d\n", i, FCVO );
	}
	return 0;
}

int QuantMatrixExtension( FILE *fp, unsigned char buffer[] )
{
int LIQM, LNIQM, LCIQM, LCNIQM;
int dummy, i;
	fprintf( stdout, "QuantMatrixExtension()\n" );
	LIQM = GetBitStream( fp, 1 );
	if( LIQM>0 )
	{
	    for( i=0; i<16; i++ )
		dummy= GetBitStream( fp,  32 );
	}
	LNIQM = GetBitStream( fp, 1 );
	if( LNIQM>0 )
	{
	    for( i=0; i<16; i++ )
		dummy= GetBitStream( fp,  32 );
	}
	LCIQM = GetBitStream( fp, 1 );
	if( LCIQM>0 )
	{
	    for( i=0; i<16; i++ )
		dummy= GetBitStream( fp,  32 );
	}
	LCNIQM = GetBitStream( fp, 1 );
	if( LCNIQM>0 )
	{
	    for( i=0; i<16; i++ )
		dummy= GetBitStream( fp,  32 );
	}
	return 0;
}

int MPEG_Extension( FILE *fp, unsigned char buffer[] )
{
int ESCI;
unsigned int topAddr = g_addr;
 	InitBitStream();
	ESCI = GetBitStream( fp, 4 );
//	fprintf( stdout, "ESCI=%X\n", ESCI );
	fprintf( stdout, "Extension(%d) : %X\n", ESCI, topAddr );
	switch( ESCI )
	{
	case 1 :	// Sequence Extension
	    SequenceExtension( fp, buffer );
//	    fprintf( stdout, "\n" );
	    break;
	case 2 :	// Sequence Display Extension
	    SequenceDisplayExtension( fp, buffer );
	    break;
	case 3 :	// Quant Matrix Extension
	    QuantMatrixExtension( fp, buffer );
	    break;
	case 5 :	// Sequence Scalable Extension
	    SequenceScalableExtension( fp, buffer );
	    break;
	case 8 :	// Picture Coding Extension
	    PictureCodingExtention( fp, buffer );
	    break;
	case 7 :	// Picture Display Extension
	    PictureDisplayExtension( fp, buffer );
	    break;
	case 9 :	// Picture Spatial Scalable Extension
	case 10 :	// Picture Temporal Scalable Extension
	default :
	    fprintf( stdout, "Unknow ESCI(0x%02X)\n", ESCI );
	    EXIT();
	    break;
	}
	if( bDump )
	fprintf( stdout, "%d bits readed\n", BitReaded );
	return 0;
}

int MPEG_GOP( FILE *fp, unsigned char buffer[] )
{
int TC, CG, BL;
	if( bShow )
	fprintf( stdout, "GOP()\n" );
 	InitBitStream();
	TC   = GetBitStream( fp,25 );
	CG   = GetBitStream( fp, 1 );	// Closed GOP flag
	BL   = GetBitStream( fp, 1 );
	if( bShow )
	fprintf( stdout, "ClosedGOP=%d\n", CG );
	if( bDump )
	fprintf( stdout, "%d bits readed\n", BitReaded );
	return 0;
}

int MPEG_Picture( FILE *fp, unsigned char buffer[] )
{
//unsigned int topAddr = g_addr;
int TR, PCT, VD, EBP, EIP;
//	if( bShow )
//	fprintf( stdout, "MPEG_Picture() : " );
 	InitBitStream();
//	bDebug=1;
	TR   = GetBitStream( fp,10 );
	PCT  = GetBitStream( fp, 3 );
	VD   = GetBitStream( fp,16 );
#if 0	// Not used with MPEG2
	FPFV = GetBitStream( fp, 1 );
	FFC  = GetBitStream( fp, 3 );
	FPBV = GetBitStream( fp, 1 );
	BFC  = GetBitStream( fp, 3 );
#endif
	EBP  = GetBitStream( fp, 1 );
	EBP  = GetBitStream( fp, 1 );
	while( EBP>0 )
	{
	    EIP  = GetBitStream( fp, 3 );
	    EBP  = GetBitStream( fp, 1 );
	}
	if( bDSS )
	{
#if 0
	    fprintf( stdout, "DSS_Picture(%d) : (%s)\n", 
		PCT, AddrStr(g_addr) );
	    fprintf( stdout, "DSS_Picture(%d) : (%s) (%s)\n", 
		PCT, AddrStr(g_addr), TsStr() );
#else
	    DSS_PCT=PCT;
	    sprintf( DSS_Addr, "%s", AddrStr(g_addr) );
	    fprintf( stdout, "DSS_Picture(%d) : (%s) (------------)\n", 
		PCT, AddrStr(g_addr) );
#endif
	} else {
	    fprintf( stdout, "MPEG_Picture(%d) : (%s) (%s)\n", 
		PCT, AddrStr(g_addr), TsStr() );
	}
	if( bShowDetail )
	    fprintf( stdout, "TR=%3d\n", TR );
	picture_coding_type = PCT;
	if( bDump )
	fprintf( stdout, "%d bits readed\n", BitReaded );
//	bDebug=0;
/*
	PictureCodingExtention( fp, buffer );
	QuantMatrixExtention( fp, buffer );
	PictureDisplayExtention( fp, buffer );
	PictureSpatialScalableExtention( fp, buffer );
	PictureTemporalScalableExtention( fp, buffer );
*/
	return 0;
}

int SeekHeader( FILE *fp, unsigned char buffer[] )
{
int state=0;
int readed;
int total=0;
	while( state<3 )
	{
	    readed = gread( buffer, 1, 1, fp );
	    if( readed<1 )
	    {
		CannotRead( "(SeekHeader)" );
		return -1;
	    }
	    total+=1;
	    switch( state )
	    {
	    case 0 :
	    	if( buffer[0]==0x00 )
		    state++;
		break;
	    case 1 :
	    	if( buffer[0]==0x00 )
		    state++;
		else
		    state=0;
		break;
	    case 2 :
	    	if( buffer[0]==0x01 )
		    state++;
		else if( buffer[0]==0x00 )
		    state=state;
		else
		    state = 0;
		break;
	    }
	}
	return total;
}

int UserDataTimestamp( unsigned char UserData[] )
{
unsigned int timeStamp=0;
	timeStamp = 
	    ((UserData[0]&0x03)<<30)
	  | ((UserData[1]&0x7F)<<23)
	  | ((UserData[2]&0xFF)<<15)
	  | ((UserData[3]&0x7F)<< 8)
	  | ((UserData[4]&0xFF)<< 0);
#if 0
        fprintf( stdout, "UserDataTimestamp(%2X %2X %2X %2X %2X:%8X)\n",
		UserData[0], UserData[1], UserData[2], UserData[3], UserData[4],
		timeStamp );
	fprintf( stdout, "%8X %8X %8X : %8X\n",
	    ((UserData[2]&0xFF)<<15),
	    ((UserData[3]&0xEF)<< 8),
	    ((UserData[4]&0xFF)<< 0),
	    ((UserData[2]&0xFF)<<15)
	  | ((UserData[3]&0xEF)<< 8)
	  | ((UserData[4]&0xFF)<< 0) );
#endif
	return timeStamp/300;
}

int MPEG_UserData( FILE *fp, unsigned char buffer[] )
{
int total=0;
int i;
	if( bShow )
	    fprintf( stdout, "UserData() : " );
	fprintf( stdout, "UserData(%s)\n", AddrStr(g_addr-4) );

	int pos = ftell(fp)-4;
	unsigned int l_addr = g_addr-4;

	total = SeekHeader( fp, buffer );
	if( total<0 )
	    return -1;
#if 1
	fprintf( stdout, "fseek(%X)\n", pos );
	fseek( fp, pos, SEEK_SET );
	g_addr = l_addr;
	InitBitStream();

	unsigned char UserData[256];
	int nUserData=0;
	unsigned char user_data;
	int userDataSize = total+1;
	if( bUserData )
	{
	    if( bDSS==0 )
	    fprintf( stdout, 
		"[UserData] pts  = 0x%04X%06X\n", g_PTSH, g_PTSL );
	    fprintf( stdout, 
		"[UserData] picture_coding_type = 0x%X\n", 
		picture_coding_type );
	    fprintf( stdout, "[UserData] size = 0x%08X\n", userDataSize );
	    fprintf( stdout, "[UserData] data =" );
	}
	for( i=0; i<userDataSize; i++ ) 	// read before 00 00 01
	{
	    user_data = GetBitStream( fp, 8 );
	    if( nUserData<256 )
	    {
	    	UserData[nUserData++] = user_data;
	    }
	    if( bUserData )
		fprintf( stdout, " %02X", user_data );
	}
	if( bUserData )
	    fprintf( stdout, "\n" );
	b_user_data = 1;

	if( bDSS )
	{
	    int pos=4;
	    while( UserData[pos]!=0 )
	    {
		int user_data_length = UserData[pos++];
		int user_data_type   = UserData[pos++];
		switch( user_data_type )
		{
		case 2 :	// PTS
		    g_PTSH=0;
		    g_PTSL=UserDataTimestamp( &UserData[pos] );
//		    fprintf( stdout, "PTS=%8X\n", g_PTSL );
//		    pos+=5;
		    pos+=(user_data_length-1);
		    break;
		case 4 :	// DTS
		    g_DTSH=0;
		    g_DTSL=UserDataTimestamp( &UserData[pos] );
//		    fprintf( stdout, "DTS=%8X\n", g_DTSL );
//		    pos+=5;
		    pos+=(user_data_length-1);
		    break;
		case 9 :	// closed caption
		    fprintf( stdout, 
			"[UserData] CC   = %02X %02X\n", 
			    UserData[pos+0], UserData[pos+1] );
		    pos+=(user_data_length-1);
		    break;
		default :
		    pos+=(user_data_length-1);
		    break;
		}
	    }
	    fprintf( stdout, 
		"[UserData] pts  = 0x%08X\n", g_PTSL );
	    fprintf( stdout, 
		"[UserData] dts  = 0x%08X\n", g_DTSL );
	    fprintf( stdout, "DSS_Picture(%d) : (%s) (%s)\n", 
		DSS_PCT, DSS_Addr, TsStr() );
	}

	user_data = GetBitStream( fp, 8 );	// 00
	if( user_data!=0x00 )
	    fprintf( stdout, "Invalid %02X (UserData0)\n", user_data );
	user_data = GetBitStream( fp, 8 );	// 00
	if( user_data!=0x00 )
	    fprintf( stdout, "Invalid %02X (UserData1)\n", user_data );
	user_data = GetBitStream( fp, 8 );	// 01
	if( user_data!=0x01 )
	    fprintf( stdout, "Invalid %02X (UserData2)\n", user_data );
#endif
	if( bDump )
	    fprintf( stdout, "%d bytes readed\n", total );
	return 0;
}


// SSC : 00 00 01 AF
int MPEG_Slice( FILE *fp, unsigned char buffer[], int ID )
{
int total=0;
int QSC, ISF, IS, RB, EBS, EIS;
int MBE;
	if( bDumpSlice )
	fprintf( stdout, "Slice(%02X) : (%s) : ", ID, AddrStr(g_addr) );

 	InitBitStream();
#if 1
//	bDebug = 1;
#if 0
	SVPE = GetBitStream( fp, 3 );
	PBP  = GetBitStream( fp, 7 );
	if( bDumpSlice )
	{
	fprintf( stdout, "SVPE=%d\n", SVPE );
	fprintf( stdout, "PBP =%d\n", PBP  );
	}
#endif
	QSC  = GetBitStream( fp, 5 );
	ISF  = GetBitStream( fp, 1 );
	if( bDumpSlice )
	{
	fprintf( stdout, "QSC =%d\n", QSC  );
	fprintf( stdout, "ISF =%d\n", ISF  );
	}
	if( ISF>0 )
	{
	    IS   = GetBitStream( fp, 1 );	// Intra Slice Flag
	    RB   = GetBitStream( fp, 7 );	// Reserved BIts
	    if( bDumpSlice )
	    {
	    fprintf( stdout, "IS =%d\n", IS );
	    fprintf( stdout, "RB =%d\n", RB );
	    }
	}
	EBS=1;
	while( EBS==1 )
	{
	    EBS  = GetBitStream( fp, 1 );
	    EIS  = GetBitStream( fp, 8 );
	    if( bDumpSlice )
	    {
	    fprintf( stdout, "EBS=%d\n", EBS );
	    fprintf( stdout, "EIS=%d\n", EIS );
	    }
	}
	MBE  = GetBitStream( fp, 11 );
	if( bDumpSlice )
	fprintf( stdout, "MBE=0x%X\n", MBE );

//	bDebug = 0;

	total = SeekHeader( fp, buffer );
	if( total<0 )
	    return -1;
#else
	total = SeekHeader( fp, buffer );
	if( total<0 )
	    return -1;
#endif
	if( bDumpSlice )
	fprintf( stdout, "%d bytes readed\n", total );
	return 3;
}

// ------------------------------------------------------------
//	Analyze
// ------------------------------------------------------------
/*
H.264
NAL header = 0,nal_ref_idc[1:0], nal_unit_type[4:0]
nal_unit_type =
1 : non-IDR picture
5 : IDR picutre slice
6 : SEI
7 : SPS
8 : PPS
9 : AU delimiter
10 : End of Sequence
11 : End of Stream
12 : Filler data
13 : Sequence Parameter Set Extrention
14..18 : 
19 : 
20..23:
24..31:
*/
int AnalyzeMPG( FILE *fp, FILE *pts_fp )
{
int bNoRead=0;
int eof=0;
unsigned char buffer[BUF_SIZE];
unsigned int ID;
int readed;
unsigned int PTSH, PTSL, DTSH, DTSL;
int readP=0;
unsigned int pes_addr=0xFFFFFFFF;
int i;
#define MAX_DATA_SIZE	1024*64
unsigned char dataBuf[MAX_DATA_SIZE];
int nAlarm=0;

	while( eof==0 )
	{
#if 0
	    if( bNoRead==0 )
	    {
		readed = gread( buffer, 1, 4, fp );
		if( readed<4 )
		{
		    CannotRead( "Prefix" );
		    break;
		}
	    }
#else
	    if( readP<4 )
	    {
	    	int size;
	    	size = 4-readP;
#if 0
		fprintf( stdout, "gread@%d, %d\n", readP, size );
#endif
		readed = gread( &buffer[readP], 1, size, fp );
		if( readed<size )
		{
		    CannotRead( "Prefix" );
		    break;
		}
		readP+=size;
	    }
#endif
	    if( (buffer[0]==0x00)
	     && (buffer[1]==0x00)
	     && (buffer[2]==0x00) )
	    {
	    	int bWarn=0;
#if 1
		if ( buffer[3]==1 )
		{
		    bWarn=1;
		}
#endif
	    	memcpy( &buffer[0], &buffer[1], 3 );
		readed = gread( &buffer[3], 1, 1, fp );
		if( readed<1 )
		{
		    CannotRead( "Prefix" );
		    break;
		}
		if( bWarn )
		{
		    if( bAlarmAVC )
		    {
		    	if( (buffer[3]>0x00) && (buffer[3]<0xB0) )
			{
			    if( nAlarm<10 )
			    {
				fprintf( stdout, 
				"%8X : File may be AVC ?  Add -AVC option : ",
				    g_addr-4 );
				fprintf( stdout, 
				    "00 00 00 01 %02X\n", buffer[3] );
			    }
			    nAlarm++;
			}
		    }
		}
		continue;
	    }

	    if( (buffer[0]!=0x00)
	     || (buffer[1]!=0x00)
	     || (buffer[2]!=0x01) )
	    {
	    	fprintf( stdout, 
		"AnalyzeMPG : Invalid Prefix %02X %02X %02X : (%s)\n",
			buffer[0], buffer[1], buffer[2], AddrStr(g_addr-4) );
		while( 1 )
		{
		    memcpy( &buffer[0], &buffer[1], 3 );
		    readed = gread( &buffer[3], 1, 1, fp );
		    if( readed<1 )
		    {
		    	fprintf( stdout, "EOF\n" );
			EXIT();
		    }
		    if( (buffer[0]==0)
		     && (buffer[1]==0)
		     && (buffer[2]==1) )
		     {
		     	fprintf( stdout, "00 00 01 : %X\n", g_addr );
		     	break;
		     }
		}
	    }
#if 0
	    for( i=0; i<4; i++ )
	    {
		fprintf( stdout, "%02X ", buffer[i] );
	    }
	    fprintf( stdout, ": %X", g_addr );
	    fprintf( stdout, "\n" );
#endif
	    // 00 00 01 XX(ID)
	    ID = buffer[3];
	    if( (ID>=0xB0) || bDumpSlice )
	    {
		if( bShow )
		{
		    for( i=0; i<4; i++ )
		    {
			fprintf( stdout, "%02X ", buffer[i] );
		    }
		    fprintf( stdout, ": " );
		    fprintf( stdout, "\n" );
		}
    //	    fprintf( stdout, "ID = %02X\n", ID );
	    }
	    readP = 0;
	    if( (ID>=1) && (ID<=0xAF) )
	    {
		    readP =  MPEG_Slice( fp, buffer, ID );
		    if( readP<0 )
		    {
		    	eof=1;
			break;
		    }
		    buffer[0] = 0x00;
		    buffer[1] = 0x00;
		    buffer[2] = 0x01;
		    readed = gread( &buffer[3], 1, 1, fp );
		    readP = 4;
		    bNoRead=1;
	    } else {
		if( bShow )
	    	if( bNoRead )
		{
		    fprintf( stdout, "%02X %02X %02X %02X : ",
			buffer[0], buffer[1], buffer[2], buffer[3] );
		    fprintf( stdout, "\n" );
		}
		bNoRead=0;
		int pes_len=(-1);
		pes_addr = g_addr-4;
		switch( ID )
		{
		case 0xE0 :	// Video
		case 0xE1 :	// 
		case 0xE2 :	// 
		case 0xE3 :	// 
		case 0xE4 :	// 
		case 0xE5 :	// 
		case 0xE6 :	// 
		case 0xE7 :	// 
		case 0xE8 :	// 
		case 0xE9 :	// 
		case 0xEA :	// 
		case 0xEB :	// 
		case 0xEC :	// 
		case 0xED :	// 
		case 0xEE :	// 
		case 0xEF :	// 
		    pes_len = PES_header( fp, buffer, bDisplayTS, 
		    	&PTSH, &PTSL, &DTSH, &DTSL );
		    {
		    	if( PTSH==0xFFFFFFFF )
			{
			    fprintf( stdout, "ID=%02X : PES_header(%s)\n", 
				ID, AddrStr2(pes_addr) );
			} else {
			    int hour, min, sec, msec;
			    TcTime32( PTSH, PTSL, &hour, &min, &sec, &msec );
			    fprintf( stdout, 
			"ID=%02X : PES_header(%s) PTS=%2d:%02d:%02d.%03d\n", 
				ID, AddrStr2(pes_addr), hour, min, sec, msec );
			}
		    }
		    break;
		case 0xB2 :
		    if( MPEG_UserData( fp, buffer )<0 )
		    {
		    	eof=1;
		    	break;
		    }
		    buffer[0] = 0x00;
		    buffer[1] = 0x00;
		    buffer[2] = 0x01;
		    readed = gread( &buffer[3], 1, 1, fp );
		    bNoRead=1;
		    readP = 4;
		    break;
		case 0xB3 :	// SHC
		    MPEG_Sequence( fp, buffer );
		    break;
		case 0xB5 :	// ESC
		    MPEG_Extension( fp, buffer );
		    break;
		case 0xB8 :	// GSC
		    MPEG_GOP( fp, buffer );
		    break;
		case 0x00 :	// PSC
		    MPEG_Picture( fp, buffer );
		    break;
		case 0xAF :	// SSC
		    break;
		case 0xB7 :	// Sequence end
		    fprintf( stdout, "Sequence end\n" );
		    break;
		case 0xC0 :	// Audio
		case 0xC1 :
		case 0xC2 :
		case 0xC3 :
		case 0xC4 :
		case 0xC5 :
		case 0xC6 :
		case 0xC7 :
		case 0xC8 :
		case 0xC9 :
		case 0xCA :
		case 0xCB :
		case 0xCC :
		case 0xCD :
		case 0xCE :
		case 0xCF :
		    {
		    int a0 = g_addr;
		    pes_len = PES_header( fp, buffer, bDisplayTS,
		    	&PTSH, &PTSL, &DTSH, &DTSL );
		    if( PTSH==0xFFFFFFFF )
		    {
			fprintf( stdout, "ID=%02X : PES_header(%s)\n", 
			    ID, AddrStr2(pes_addr) );
		    } else {
			int hour, min, sec, msec;
			TcTime32( PTSH, PTSL, &hour, &min, &sec, &msec );
			fprintf( stdout, 
		    "ID=%02X : PES_header(%s) PTS=%2d:%02d:%02d.%03d\n", 
			    ID, AddrStr2(pes_addr), hour, min, sec, msec );
		    }
		    fprintf( pts_fp, "%8X %8llX : %4X %08X, %4X %08X\n",
			    pes_addr, SrcAddr(pes_addr,0),
			    (UINT)(PTSH & 0xFFFF), PTSL, 
			    (UINT)(DTSH & 0xFFFF), DTSL );
		    int a1 = g_addr;
		    int readSize = pes_len-(a1-a0)+2;
#if 0
		    fprintf( stdout, "pes_len=%d, a1-a0=%d, read=%d\n",
		    	pes_len, a1-a0, readSize );
#endif
		    if( readSize>=MAX_DATA_SIZE )
		    {
		    	fprintf( stdout, "Too large data (0x%X)\n",
				readSize );
			exit( 1 );
		    }
		    readed = gread( dataBuf, 1, readSize, fp );
		    }
		    break;
		default :
		    fprintf( stdout, 
		    	"Not implemented (%02X) in AnaylzeMPG(%s)\n",
			    ID, AddrStr(pes_addr) );
		    break;
		}
	    }
	}
	fprintf( stdout, "nSequence=%d\n", nSequence );
	fprintf( stdout, "nSequenceExtension=%d\n", nSequenceExtension );
	fprintf( stdout, "nSequenceDisplayExtension=%d\n", 
		nSequenceDisplayExtension );
#if 0
	if( g_update_addr[0]==0xFFFFFFFF )
	{
	    fprintf( stdout, "No g_update\n" );
	} else {
	    fprintf( stdout, "addr=%X\n", g_update_addr[0] );
	    fprintf( stdout, "bits=%X\n", g_update_bits[0] );
	    fprintf( stdout, "size=%X\n", g_update_size[0] );
	    fprintf( stdout, "data=%X\n", g_update_data[0] );
	}
#endif
	return 0;
}

// ----------------------------------------------------------------------
// Analayze AVS
// ----------------------------------------------------------------------
int AVS_low_delay = (-1);
int AVS_fixed_picture_qp = (-1);
int AVS_skip_mode_flag = (-1);
int AVS_chroma_format = (-1);
int AVS_picture_reference_flag = (-1);

int AVS_PictureType=(-1);
int AVS_PictureStructure=(-1);
int AVS_MbRow=(-1);
int AVS_MbIndex=(-1);
int AVS_MbWidth=(-1);
int AVS_MbHeight=(-1);
int AVS_NumberOfReference=(-1);
int AVS_MbType=(-1);
int AVS_MbTypeIndex=(-1);
int AVS_MvNum=(-1);
int AVS_MbWeightingFlag=0;
int AVS_MbCBP=(-1);
int AVS_MbCBP422=(-1);

#define AVS_NONE	0
#define AVS_I_FRAME	1
#define AVS_P_FRAME	2
#define AVS_B_FRAME	3
int AVS_CurrentPicture=AVS_NONE;

#define AVS_P_SKIP	0

#define AVS_B_SKIP	 0
#define AVS_B_8x8	23
#define AVS_I_8x8	24

int AVS_sequence_header( FILE *fp, unsigned char buffer[] )
{
	fprintf( stdout, "AVS_sequence_header() : (%s)\n", AddrStr(g_addr) );
	fprintf( stdout, "**********************************************\n" );
 	InitBitStream();

	int profile_id = GetBitStream( fp, 8 );
	int level_id = GetBitStream( fp, 8 );
	int progressive_sequence = GetBitStream( fp, 1 );
	int horizontal_size = GetBitStream( fp, 14 );
	int vertical_size = GetBitStream( fp, 14 );
	AVS_chroma_format = GetBitStream( fp, 2 );
	int sample_precision = GetBitStream( fp, 3 );
	int aspect_ratio = GetBitStream( fp, 4 );
	int frame_rate_code = GetBitStream( fp, 4 );
	int bit_rate_lower = GetBitStream( fp, 18 );
	int marker_bit = GetBitStream( fp, 1 );
	int bit_rate_upper = GetBitStream( fp, 12 );
	AVS_low_delay = GetBitStream( fp, 1 );
	int marker_bit2= GetBitStream( fp, 1 );
	int bbv_buffer_size = GetBitStream( fp, 18 );
#if 0
	int reserved_bits = GetBitStream( fp, 2 );
#else
	GetBitStream( fp, 2 );
#endif

//	if( bDumpSequence )
	{
	    fprintf( stdout, "profile_id          =%d\n", profile_id );
	    fprintf( stdout, "level_id            =%d\n", level_id   );
	    fprintf( stdout, "progressive_sequence=%d\n", progressive_sequence);
	    fprintf( stdout, "horizontal_size     =%d\n", horizontal_size );
	    fprintf( stdout, "vertical_size       =%d\n", vertical_size   );
	    fprintf( stdout, "sample_precision    =%d\n", sample_precision);
	    fprintf( stdout, "aspect_ratio        =%d\n", aspect_ratio    );
	    fprintf( stdout, "frame_rate_code     =%d\n", frame_rate_code );
	    fprintf( stdout, "bit_rate_lower      =%d\n", bit_rate_lower  );
	    fprintf( stdout, "marker_bit          =%d\n", marker_bit      );
	    fprintf( stdout, "bit_rate_upper      =%d\n", bit_rate_upper  );
	    fprintf( stdout, "low_delay           =%d\n", AVS_low_delay   );
	    fprintf( stdout, "marker_bit2         =%d\n", marker_bit2     );
	    fprintf( stdout, "bbv_buffer_size     =%d\n", bbv_buffer_size );
	}
	AVS_MbWidth  =  (horizontal_size+15)/16;
	AVS_MbHeight = ((vertical_size  +31)/32)*2;

	nSequence++;
	return 0;
}
int AVS_sequence_display_extension( FILE *fp, unsigned char buffer[],
	int extension_id )
{
//	int extension_id = GetBitStream( fp, 4 );
	int video_format = GetBitStream( fp, 3 );
	int sample_range = GetBitStream( fp, 1 );
	int colour_description = GetBitStream( fp, 1 );

	fprintf( stdout, "extension_id           =%d\n",
		extension_id            );
	fprintf( stdout, "video_format           =%d\n",
		video_format            );
	fprintf( stdout, "sample_range           =%d\n",
		sample_range            );

	if( colour_description )
	{
	    int colour_primaries = GetBitStream( fp, 8 );
	    int transfer_characteristics = GetBitStream( fp, 8 );
	    int matrix_coefficients = GetBitStream( fp, 8 );
	    fprintf( stdout, "colour_primaries         = %d\n", 
	    	colour_primaries );
	    fprintf( stdout, "transfer_characteristics = %d\n", 
	    	transfer_characteristics );
	    fprintf( stdout, "matrix_coefficients      = %d\n", 
	    	matrix_coefficients );
	}
	int display_horizontal_size = GetBitStream( fp, 14 );
	int marker_bit = GetBitStream( fp, 1 );
	fprintf( stdout, "marker_bit=%d\n", marker_bit );
	int display_vertical_size = GetBitStream( fp, 14 );
#if 0
	int reserved_bits = GetBitStream( fp, 2 );
#else
	GetBitStream( fp, 2 );
#endif
	fprintf( stdout, "display_horizontal_size=%d\n",
		display_horizontal_size );
	fprintf( stdout, "display_vertical_size =%d\n",
		display_vertical_size );
	return 0;
}

int AVS_extension_data( FILE *fp, unsigned char buffer[], int id )
{
	fprintf( stdout, "AVS_extension_data() : (%s)\n", AddrStr(g_addr) );
	fprintf( stdout, "**********************************************\n" );
 	InitBitStream();

	if( id==0 )	// after sequence header
	{
	    int next_bits4 = GetBitStream( fp, 4 );
	    fprintf( stdout, "next_bits4=%d\n", next_bits4 );
	    if( next_bits4== 2 )	// picture display extension
	    {
	    	fprintf( stdout, "pictrue display  extension\n" );
	    	AVS_sequence_display_extension( fp, buffer, next_bits4 );
//		EXIT();
	    } else if( next_bits4== 4 )	// copyright extension
	    {
	    	fprintf( stdout, "copyright extension\n" );
		EXIT();
	    } else if( next_bits4==11 )	// camera parameters extension
	    {
	    	fprintf( stdout, "camera parameters extension\n" );
	    } else {
		int state=0;
		int bFirst=1;
		while( 1 )
		{
		    int next_bits8;
		    if( bFirst )
		    {
			next_bits8 = (next_bits4<<4) | GetBitStream( fp, 4 );
		    } else {
			next_bits8 = GetBitStream( fp, 8 );
		    }
		    bFirst=0;
		    fprintf( stdout, "state=%d, next_bits8=%02X\n",
		    	state, next_bits8 );
		    switch( state )
		    {
		    case 0 :
		    	if( next_bits8==0 )
			    state++;
			else {
			    fprintf( stdout, "%02X ", next_bits8 );
			}
			break;
		    case 1 :
		    	if( next_bits8==0 )
			{
			    state++;
			} else {
			    fprintf( stdout, "00 %02X ", next_bits8 );
			    state = 0;
			}
			break;
		    case 2 :
		    	if( next_bits8==0 )
			{
			    fprintf( stdout, "00 " );
			} else if( next_bits8==1 )
			{
			    buffer[0] = 0;
			    buffer[1] = 0;
			    buffer[2] = 1;
			    return 3;
			} else {
			    fprintf( stdout, "00 00 %02X ", next_bits8 );
			    state = 0;
			}
			break;
		    }
		}
	    }
	} else {	// after picture header
	    	fprintf( stdout, "after picture header\n" );
		EXIT();
	}
	return 0;
}

int AVS_user_data( FILE *fp, unsigned char buffer[] )
{
	fprintf( stdout, "AVS_user_data() : (%s)\n", AddrStr(g_addr) );
	fprintf( stdout, "**********************************************\n" );
 	InitBitStream();

	int state=0;
	int userCount=0;
	while( 1 )
	{
	    int next_bits8;
	    next_bits8 = GetBitStream( fp, 8 );
#if 0
	    fprintf( stdout, "state=%d, next_bits8=%02X\n",
		state, next_bits8 );
#endif
	    buffer[userCount++] = next_bits8;
	    switch( state )
	    {
	    case 0 :
		if( next_bits8==0 )
		    state++;
		else {
		    fprintf( stdout, "%02X ", next_bits8 );
		}
		break;
	    case 1 :
		if( next_bits8==0 )
		{
		    state++;
		} else {
		    fprintf( stdout, "00 %02X ", next_bits8 );
		    state = 0;
		}
		break;
	    case 2 :
		if( next_bits8==0 )
		{
		    fprintf( stdout, "00 " );
		} else if( next_bits8==1 )
		{
		    fprintf( stdout, "\n" );
		    fprintf( stdout, "UserData=[%s]\n", buffer );
		    buffer[0] = 0;
		    buffer[1] = 0;
		    buffer[2] = 1;
		    return 3;
		} else {
		    fprintf( stdout, "00 00 %02X ", next_bits8 );
		    state = 0;
		}
		break;
	    }
	}

	return 0;
}
int AVS_i_picture_header( FILE *fp, unsigned char buffer[] )
{
	fprintf( stdout, "AVS_i_picture_header() : (%s)\n", AddrStr(g_addr) );
	fprintf( stdout, "**********************************************\n" );
 	InitBitStream();

	int bbv_delay = GetBitStream( fp, 16 );
	fprintf( stdout, "bbv_delay=%04X\n", bbv_delay );
	int time_code_flag = GetBitStream( fp, 1 );
	if( time_code_flag )
	{
	    int time_code = GetBitStream( fp, 24 );
	    fprintf( stdout, "time_code=%06X\n", time_code );
	}
	int marker_bit = GetBitStream( fp, 1 );
	fprintf( stdout, "marker_bit=%d\n", marker_bit );
	int picture_distance = GetBitStream( fp, 8 );
	fprintf( stdout, "picture_distance=%d\n", picture_distance );

	if( AVS_low_delay )
	{
	    fprintf( stdout, "AVS_low_delay=%d\n", AVS_low_delay );
	    EXIT();
	}
	int progressive_frame = GetBitStream( fp, 1 );
	fprintf( stdout, "progressive_frame=%d\n", progressive_frame );
	int picture_structure = (-1);
	if( progressive_frame==0 )
	{
	    picture_structure = GetBitStream( fp, 1 );
	    fprintf( stdout, "picture_structure=%d\n", picture_structure );
	    AVS_PictureStructure = picture_structure;
	} else {
	    AVS_PictureStructure = 1;
	}
	int top_field_first = GetBitStream( fp, 1 );
	int repeat_first_field = GetBitStream( fp, 1 );
	AVS_fixed_picture_qp = GetBitStream( fp, 1 );
	int picture_qp = GetBitStream( fp, 6 );
	fprintf( stdout, "picture_qp     =%d\n", picture_qp      );
	fprintf( stdout, "top_field_first=%d\n", top_field_first );
	fprintf( stdout, "repeat_first_field=%d\n", repeat_first_field );
	if( progressive_frame==0 )
	{
	    if( picture_structure==0 )
	    {
		AVS_skip_mode_flag = GetBitStream( fp, 1 );
		fprintf( stdout, "skip_mode_flag = %d\n", AVS_skip_mode_flag );
	    }
	}
#if 0
	int reserved_bits = GetBitStream( fp, 4 );
#else
	GetBitStream( fp, 4 );
#endif
	int loop_filter_disable = GetBitStream( fp, 1 );
	fprintf( stdout, "loop_filter_disable=%d\n", loop_filter_disable );
	if( loop_filter_disable==0 )
	{
	    int loop_filter_parameter_flag = GetBitStream( fp, 1 );
	    fprintf( stdout, "loop_filter_parameter_flag=%d\n", 
	    	loop_filter_parameter_flag );
	    if( loop_filter_parameter_flag )
	    {
		int alpha_c_offset = GetBitStreamGolomb( fp );
		int beta_offset = GetBitStreamGolomb( fp );
		fprintf( stdout, "alpha_c_offset=%d\n", alpha_c_offset );
		fprintf( stdout, "beta_offset   =%d\n", beta_offset );
	    }
	}
	AVS_CurrentPicture=AVS_I_FRAME;

	return 0;
}

int AVS_block( FILE *fp, unsigned char buffer[], int i )
{
	fprintf( stdout, "AVS_block(%d)\n", i );
	int EOB=0;
	if( ((i< 6) && (AVS_MbCBP    & (1<<i)))
	||  ((i>=6) && (AVS_MbCBP422 & (1<<(i-6)))) )
	{
	    while( 1 )
	    {
		int trans_coefficient = GetBitStreamGolomb( fp );
		fprintf( stdout, "trans_coefficient=%d\n", trans_coefficient );
		if( trans_coefficient>=59 )
		{
		int escape_level_diff = GetBitStreamGolomb( fp );
		fprintf( stdout, "escape_level_diff=%d\n", escape_level_diff );
		}
		if( trans_coefficient==EOB )
		    break;
	    }
	}
	return 0;
}

int AVS_macroblock( FILE *fp, unsigned char buffer[] )
{
int i;
int mb_type = (-1);

	if( (AVS_PictureType!=0) 
	 || ((AVS_PictureStructure==0) 
	  && (AVS_MbIndex>=AVS_MbWidth*AVS_MbHeight/2)) )
	{
	    mb_type = GetBitStreamGolomb( fp );
	}
	if( AVS_CurrentPicture==AVS_I_FRAME )
	{
	    if( AVS_PictureStructure==1 )
	    {
		AVS_MbType = AVS_I_8x8;
		AVS_MvNum  = 0;
	    } else {
		if( AVS_MbIndex < AVS_MbWidth*AVS_MbHeight/2 )
		{
		    AVS_MbType = AVS_I_8x8;
		    AVS_MvNum = 0;
		} else {
		    if( AVS_skip_mode_flag==1 )
		    {
			AVS_MbTypeIndex = mb_type+1;
		    } else {
			AVS_MbTypeIndex = mb_type+0;
		    }
		}
	    }
	}
	if( (AVS_MbType!=AVS_P_SKIP) && (AVS_MbType!=AVS_B_SKIP) )
	{
	    if( AVS_MbType==AVS_B_8x8 )
	    {
	    	for( i=0; i<4; i++ )
		{
		    int mb_part_type = GetBitStream( fp, 2 );
		    fprintf( stdout, "mb_part_type=%d\n", mb_part_type );
		}
	    }
	    if( AVS_MbType==AVS_I_8x8 )
	    {
	    	for( i=0; i<4; i++ )
		{
		    int pred_mode_flag = GetBitStream( fp, 1 );
		    if( pred_mode_flag==0 )
		    {
			int intra_luma_pred_mode = GetBitStream( fp, 2 );
			fprintf( stdout, "intra_luma_pred_mode=%d\n",
				intra_luma_pred_mode );
		    }
		}
		int intra_chroma_pred_mode = GetBitStreamGolomb( fp );
		fprintf( stdout, "intra_chroma_pred_mode=%d\n",
			intra_chroma_pred_mode );
		if( AVS_chroma_format==2 )
		{
		    int intra_chroma_pred_mode_422 = GetBitStreamGolomb( fp );
		    fprintf( stdout, "intra_chroma_pred_mode_422=%d\n",
			    intra_chroma_pred_mode_422 );
		}
	    }
	    if(( (AVS_PictureType==1)
	     || ((AVS_PictureType==2) && (AVS_PictureStructure==0)))
	     && (AVS_picture_reference_flag==0) )
	    {
	    	for( i=0; i<AVS_MvNum; i++ )
		{
#if 1
		    int mb_reference_index = GetBitStream( fp, 1 );
#else
		    int mb_reference_index = GetBitStream( fp, 2 );
#endif
			fprintf( stdout, "mb_reference_index=%d\n",
				mb_reference_index );
		}
	    }
	    for( i=0; i<AVS_MvNum; i++ )
	    {
		int mv_diff_x = GetBitStreamGolomb( fp );
		int mv_diff_y = GetBitStreamGolomb( fp );
		fprintf( stdout, "(%d,%d)\n", mv_diff_x, mv_diff_y );
	    }
	    if( AVS_MbWeightingFlag==1 )
	    {
		int weighting_prediction = GetBitStream( fp, 1 );
		fprintf( stdout, "weighting_prediction = %d\n",
			weighting_prediction );
	    }

	    if( ((AVS_MbTypeIndex>=24) && (AVS_PictureType==2))
	     || ((AVS_MbTypeIndex>= 5) && (AVS_PictureType!=2)) )
	    {
		int cbp = GetBitStreamGolomb( fp );
		AVS_MbCBP = cbp;
	    }
	    if( AVS_chroma_format==2 )
	    {
		int cbp_422 = GetBitStreamGolomb( fp );
		AVS_MbCBP422 = cbp_422;
	    }
	    if( ((AVS_MbCBP>0)
	     || ((AVS_MbCBP422>0) && (AVS_chroma_format==2)))
	     && (AVS_fixed_picture_qp==0) )
	    {
		int mb_qp_delta = GetBitStreamGolomb( fp );
		fprintf( stdout, "mb_qp_delta = %d\n", mb_qp_delta );
	    }
	    for( i=0; i<6; i++ )
	    {
	    	AVS_block( fp, buffer, i );
	    }
	    if( AVS_chroma_format==2 )
	    {
	    	for( i=6; i<8; i++ )
		{
	    	AVS_block( fp, buffer, i );
		}
	    }
	}
	return 0;
}

int AVS_slice( FILE *fp, unsigned char buffer[], int slice_vertical_position )
{
	AVS_MbWeightingFlag = 0;
	AVS_MbRow = slice_vertical_position;
	AVS_MbIndex = AVS_MbRow*AVS_MbWidth;

	if( AVS_fixed_picture_qp==0 )
	{
	    int fixed_slice_qp = GetBitStream( fp, 1 );
	    int slice_qp = GetBitStream( fp, 6 );
	    fprintf( stdout, "fixed_slice_qp = %d\n", fixed_slice_qp );
	    fprintf( stdout, "slice_qp       = %d\n", slice_qp );
	}

fprintf( stdout, "AVS_PictureType=%d\n", AVS_PictureType );
fprintf( stdout, "AVS_PictureStructure=%d\n", AVS_PictureStructure );
fprintf( stdout, "AVS_MbIndex=%d\n", AVS_MbIndex );
fprintf( stdout, "AVS_MbWidth=%d\n", AVS_MbWidth );
fprintf( stdout, "AVS_MbHeight=%d\n", AVS_MbHeight );

	if( (AVS_PictureType!=0) 
	 || ((AVS_PictureStructure==0) 
	  && (AVS_MbIndex>=AVS_MbWidth*AVS_MbHeight/2)) )
	{
	    int slice_weighting_flag = GetBitStream( fp, 1 );
	    if( slice_weighting_flag==1 )
	    {
	    	int i;
		for( i=0; i<AVS_NumberOfReference; i++ )
		{
		    int luma_scale = GetBitStream( fp, 8 );
		    int luma_shift = GetBitStream( fp, 8 );
		    int marker_bit = GetBitStream( fp, 1 );
		    int chroma_scale = GetBitStream( fp, 8 );
		    int chroma_shift = GetBitStream( fp, 8 );
		    int marker_bit2= GetBitStream( fp, 1 );
		    fprintf( stdout, "luma_scale  =%d\n", luma_scale );
		    fprintf( stdout, "luma_shift  =%d\n", luma_shift );
		    fprintf( stdout, "marker_bit=%d\n", marker_bit );
		    fprintf( stdout, "chroma_scale=%d\n", chroma_scale );
		    fprintf( stdout, "chroma_shift=%d\n", chroma_shift );
		    fprintf( stdout, "marker_bit=%d\n", marker_bit2 );
		}
	    }
	    int mb_weighting_flag = GetBitStream( fp, 1 );
	    AVS_MbWeightingFlag = mb_weighting_flag;
	}
//	while( 1 )
	{
	    if( (AVS_PictureType!=0)
	     || ((AVS_PictureStructure==0) 
	      && (AVS_MbIndex>=AVS_MbWidth*AVS_MbHeight/2) ))
	    {
		if( AVS_skip_mode_flag==1 )
		{
		    int mb_skip_run = GetBitStreamGolomb( fp );
		    fprintf( stdout, "mb_skip_run=%d\n", mb_skip_run );
		}
	    }
	    if( AVS_MbIndex<(AVS_MbWidth*AVS_MbHeight) )
	    {
		AVS_macroblock( fp, buffer );
	    }
	}

	return 0;
}

int AnalyzeAVS( FILE *fp, FILE *pts_fp )
{
int bNoRead=0;
int eof=0;
unsigned char buffer[BUF_SIZE];
unsigned int ID;
int readed;
unsigned int PTSH, PTSL, DTSH, DTSL;
int readP=0;
unsigned int pes_addr=0xFFFFFFFF;
int i;
#define MAX_DATA_SIZE	1024*64
unsigned char dataBuf[MAX_DATA_SIZE];
int nAlarm=0;

	while( eof==0 )
	{
	    if( readP<4 )
	    {
	    	int size;
	    	size = 4-readP;
		readed = gread( &buffer[readP], 1, size, fp );
		if( readed<size )
		{
		    CannotRead( "Prefix" );
		    break;
		}
		readP+=size;
	    }
	    if( (buffer[0]==0x00)
	     && (buffer[1]==0x00)
	     && (buffer[2]==0x00) )
	    {
#if 1
		if ( buffer[3]==1 )
		{
		    if( bAlarmAVC )
		    {
		    if( nAlarm<10 )
		    fprintf( stdout, "File may be AVC ?  Add -AVC option\n" );
		    }
		    nAlarm++;
		}
#endif
//	    fprintf( stdout, "00 00 00 : %X\n", g_addr );
	    	memcpy( &buffer[0], &buffer[1], 3 );
		readed = gread( &buffer[3], 1, 1, fp );
		if( readed<1 )
		{
		    CannotRead( "Prefix" );
		    break;
		}
		continue;
	    }

	    if( (buffer[0]!=0x00)
	     || (buffer[1]!=0x00)
	     || (buffer[2]!=0x01) )
	    {
	    	fprintf( stdout, 
		"AnalyzeAVS : Invalid Prefix %02X %02X %02X : (%s)\n",
			buffer[0], buffer[1], buffer[2], AddrStr(g_addr-4) );
		fprintf( stdout, "Search next start code\n" );
//	exit( 1 );
		while( 1 )
		{
		    memcpy( &buffer[0], &buffer[1], 3 );
		    readed = gread( &buffer[3], 1, 1, fp );
		    if( readed<1 )
		    {
		    	fprintf( stdout, "EOF\n" );
			EXIT();
		    }
		    if( (buffer[0]==0)
		     && (buffer[1]==0)
		     && (buffer[2]==1) )
		     {
		     	fprintf( stdout, "00 00 01 : Addr=0x%X\n", g_addr );
		     	break;
		     }
		}
	    }
#if 0
	    for( i=0; i<4; i++ )
	    {
		fprintf( stdout, "%02X ", buffer[i] );
	    }
	    fprintf( stdout, ": %X", g_addr );
	    fprintf( stdout, "\n" );
#endif
	    // 00 00 01 XX(ID)
	    ID = buffer[3];
	    if( (ID>=0xB0) || bDumpSlice )
	    {
		if( bShow )
		{
		    for( i=0; i<4; i++ )
		    {
			fprintf( stdout, "%02X ", buffer[i] );
		    }
		    fprintf( stdout, ": " );
		    fprintf( stdout, "\n" );
		}
    //	    fprintf( stdout, "ID = %02X\n", ID );
	    }
	    readP = 0;
// --------------------------------------------------
	    if( bShow )
	    if( bNoRead )
	    {
		fprintf( stdout, "%02X %02X %02X %02X : ",
		    buffer[0], buffer[1], buffer[2], buffer[3] );
		fprintf( stdout, "\n" );
	    }
	    bNoRead=0;
	    int pes_len=(-1);
	    pes_addr = g_addr-4;
	    if( (ID>=0x00) && (ID<=0xAF) )
	    {	// slice_start_code
		fprintf( stdout, "%02X : slice_start_code\n", ID );
		readP = AVS_slice( fp, buffer, ID );
	    } else if( (ID>=0xE0) && (ID<=0xEF) )
	    {	// Video PES header
		pes_len = PES_header( fp, buffer, bDisplayTS, 
		    &PTSH, &PTSL, &DTSH, &DTSL );
		{
		    if( PTSH==0xFFFFFFFF )
		    {
			fprintf( stdout, "ID=%02X : PES_header(%s)\n", 
			    ID, AddrStr2(pes_addr) );
		    } else {
			int hour, min, sec, msec;
			TcTime32( PTSH, PTSL, &hour, &min, &sec, &msec );
			fprintf( stdout, 
		    "ID=%02X : PES_header(%s) PTS=%2d:%02d:%02d.%03d\n", 
			    ID, AddrStr2(pes_addr), hour, min, sec, msec );
		    }
		}
	    } else if( (ID>=0xC0) && (ID<=0xCF) )
	    {	// Audio PES header
		int a0 = g_addr;
		pes_len = PES_header( fp, buffer, bDisplayTS,
		    &PTSH, &PTSL, &DTSH, &DTSL );
		if( PTSH==0xFFFFFFFF )
		{
		    fprintf( stdout, "ID=%02X : PES_header(%s)\n", 
			ID, AddrStr2(pes_addr) );
		} else {
		    int hour, min, sec, msec;
		    TcTime32( PTSH, PTSL, &hour, &min, &sec, &msec );
		    fprintf( stdout, 
		"ID=%02X : PES_header(%s) PTS=%2d:%02d:%02d.%03d\n", 
			ID, AddrStr2(pes_addr), hour, min, sec, msec );
		}
		fprintf( pts_fp, "%8X %8llX : %4X %08X, %4X %08X\n",
			pes_addr, SrcAddr(pes_addr,0),
			(UINT)(PTSH & 0xFFFF), PTSL, 
			(UINT)(DTSH & 0xFFFF), DTSL );
		int a1 = g_addr;
		int readSize = pes_len-(a1-a0)+2;
#if 0
		fprintf( stdout, "pes_len=%d, a1-a0=%d, read=%d\n",
		    pes_len, a1-a0, readSize );
#endif
		if( readSize>=MAX_DATA_SIZE )
		{
		    fprintf( stdout, "Too large data (0x%X)\n",
			    readSize );
		    exit( 1 );
		}
		readed = gread( dataBuf, 1, readSize, fp );
	    } else {
		switch( ID )
		{
		case 0xB0 :	// video_sequence_start_code
		    fprintf( stdout, "%02X : video_sequence_start_code\n", ID );
		    readP = AVS_sequence_header( fp, buffer );
		    break;
#if 0
		case 0xB1 :	// video_sequence_end_code
		    fprintf( stdout, "video_sequence_end_code\n" );
		    break;
#endif
		case 0xB2 :	// User_data_start_code
		    fprintf( stdout, "%02X : User_data_start_code\n", ID );
		    readP = AVS_user_data( fp, buffer );
		    break;
		case 0xB3 :	// i_picture_start_code
		    fprintf( stdout, "%02X : i_picture_start_code\n", ID );
		    readP = AVS_i_picture_header( fp, buffer );
		    AVS_PictureType = 0;
		    AVS_NumberOfReference = 1;
		    break;
		case 0xB5 :	// 
		    fprintf( stdout, "%02X : extension_start_code\n", ID );
		    readP = AVS_extension_data( fp, buffer, 0 );
		    break;
		case 0xB6 :	// 
		    fprintf( stdout, "%02X : pb_picture_start_code\n", ID );
		    break;
		default :
		    fprintf( stdout, 
			"Not implemented (%02X) in AnaylzeAVS(%s)\n",
			    ID, AddrStr(pes_addr) );
		    exit( 1 );
		    break;
		}
	    }
	}
	fprintf( stdout, "nSequence=%d\n", nSequence );
	fprintf( stdout, "nSequenceExtension=%d\n", nSequenceExtension );
	fprintf( stdout, "nSequenceDisplayExtension=%d\n", 
		nSequenceDisplayExtension );
#if 0
	if( g_update_addr[0]==0xFFFFFFFF )
	{
	    fprintf( stdout, "No g_update\n" );
	} else {
	    fprintf( stdout, "addr=%X\n", g_update_addr[0] );
	    fprintf( stdout, "bits=%X\n", g_update_bits[0] );
	    fprintf( stdout, "size=%X\n", g_update_size[0] );
	    fprintf( stdout, "data=%X\n", g_update_data[0] );
	}
#endif
	return 0;
}
// --------------------------------------------------------------------
// end of Analayze AVS
// --------------------------------------------------------------------

static void ShowHeader( unsigned char *buffer )
{
int i;
	for( i=0; i<4; i++ )
	{
	    fprintf( stdout, "%02X ", buffer[i] );
	}
	fprintf( stdout, " : (%s) : ", AddrStr(g_addr) );
}

int nPict=0;
int nPes=0;
int oPes=(-1);
int nShc=0;
int FirstDts=(-1);
int FirstPts=(-1);

int ParseHeader( FILE *fp, unsigned char *buffer, FILE *pts_fp )
{
int ID=buffer[3];
unsigned int PTSH=0xFFFFFFFF, PTSL=0xFFFFFFFF;
unsigned int DTSH=0xFFFFFFFF, DTSL=0xFFFFFFFF;
int HeaderAddr = (-1);
int NoPtsAddr  = (-1);
	if( ID<0x80 )
	{
	    if( ID==0 )
	    {
	    	int TR, PCT;
		HeaderAddr = g_addr-4;
		ShowHeader( buffer );
		InitBitStream( );
		TR  = GetBitStream( fp, 10 );
		PCT = GetBitStream( fp, 3 );
		fprintf( stdout, "TR=%4d, PCT=%d : Pict(%4d)\n", 
			TR, PCT, nPict );
		if( (PCT>=1) && (PCT<=3) )
		{
		    nPict++;
		} else {
		    fprintf( stdout, "Error\n" );
		    int RST= GetBitStream( fp, 3 );
		    buffer[4] = TR>>2;
		    buffer[5] = ((TR&3)<<6) 
		    	       | (PCT<<3)
			       | (RST<<0);
		    return 2;
		}
	    } else {
	    	if( oPes!=nPes )
		{
		    HeaderAddr = g_addr-4;
		    ShowHeader( buffer );
		    fprintf( stdout, "\n" );
		}
		oPes=nPes;
	    }
	} else {
	    HeaderAddr = g_addr-4;
	    ShowHeader( buffer );
	    oPes=nPes;
	    int bPTS=0;
	    switch( ID )
	    {
	    case 0xE0 :	// PES_header
	    case 0xE1 :	//
	    case 0xE2 :	//
	    case 0xE3 :	//
	    case 0xE4 :	//
	    case 0xE5 :	//
	    case 0xE6 :	//
	    case 0xE7 :	//
	    case 0xE8 :	//
	    case 0xE9 :	//
	    case 0xEA :	//
	    case 0xEB :	//
	    case 0xEC :	//
	    case 0xED :	//
	    case 0xEE :	//
	    case 0xEF :	//

	    case 0xC0 :	// PES_header : Audio

		PES_header( fp, buffer, 0, &PTSH, &PTSL, &DTSH, &DTSL );
		if( PTSH!=0xFFFFFFFF )
		{
		    fprintf( stdout, "PTS=%4X %06X ", PTSH, PTSL );
		    bPTS=1;
		}
		if( DTSH!=0xFFFFFFFF )
		    fprintf( stdout, "DTS=%4X %06X", DTSH, DTSL );
		else {
		    if( bPTS )
		    {
		    DTSH=PTSH;
		    DTSL=PTSL;
		    fprintf( stdout, "DTS=%4X %06X", PTSH, PTSL );
		    }
		}
		fprintf( stdout, ": Pes(%4d)", nPes );
		fprintf( pts_fp, "%8X %8llX : %4X %08X, %4X %08X\n",
			HeaderAddr, SrcAddr(HeaderAddr,0),
			(UINT)(PTSH & 0xFFFF), PTSL, 
			(UINT)(DTSH & 0xFFFF), DTSL );
		if( bPTS )
		{
		    if( FirstPts==(-1) )
		    	FirstPts = PTSL;
		    if( FirstDts==(-1) )
		    {
		    if( DTSH!=0xFFFFFFFF )
		    	FirstDts = DTSL;
		    else
		    	FirstDts = PTSL;
		    }
		    if( fromDts!=INVALID_OFFSET )
		    {
		    	int valid=0;
		    	if( (DTSL-FirstDts)>=fromDts )
			{
			    if( toDts==INVALID_OFFSET )
			    {
			    	valid = 1;
			    } else {
			    	if( (DTSL-FirstDts)<toDts )
				    valid = 1;
			    }
			}
#if 0
			fprintf( stdout, 
			"\nvalid=%d\n %8X %8X %8X", 
			valid, fromDts, DTSL, toDts );
#endif
			if( valid )
			{
			    if( validStart<0 )
			    {
				validStart = HeaderAddr;
				if( NoPtsAddr!=(-1) )
				    validStart = NoPtsAddr;
//			    fprintf( stdout, "validStart=%X\n", validStart );
			    }
			} else {
			    if( validStart>=0 )
			    	if( validEnd<0 )
				{
				    validEnd = HeaderAddr;
//			    fprintf( stdout, "validEnd=%X\n", validEnd );
				}
			}
		    }
		    NoPtsAddr = (-1);
		} else {
		    if( NoPtsAddr==(-1) )
			NoPtsAddr = HeaderAddr;
		}
		nPes++;
		es_addr = g_addr;	// 2012.9.3
		break;
	    case 0xB2 :	// UserData
	    	fprintf( stdout, "UserData" );
		break;
	    case 0xB3 :	// SHC
	    	fprintf( stdout, "SHC (%4d)", nShc );
		nShc++;
		break;
	    case 0xB5 :	// ESC
	    	fprintf( stdout, "ESC" );
		break;
	    case 0xB8 :	// GSC
	    	fprintf( stdout, "GSC" );
		break;
	    case 0x00 :	// PSC
	    	fprintf( stdout, "PSC" );
		break;
	    default :
		fprintf( stdout, 
		    "Not implemented (%02X) in Header\n", ID );
//		return 1;
		break;
	    }
	    fprintf( stdout, "\n" );
	}
	return 0;
}

int AnalyzeHeader( FILE *fp, FILE *pts_fp )
{
int eof=0;
unsigned char buffer[BUF_SIZE];
int ID;
int readed;
int nPos=0;
int ret=0;
	nPict=0;
	nPes =0;
	nShc =0;

	while( eof==0 )
	{
	    readed = gread( &buffer[nPos], 1, 1, fp );
	    if( readed<1 )
	    {
		fprintf( stdout, "EOF@(%s)\n", AddrStr(g_addr) );
		break;
	    }
	    switch( nPos )
	    {
	    case 0 :
		if( buffer[nPos]==0 )	// 00
		    nPos++;
		break;
	    case 1 :
		if( buffer[nPos]==0 )	// 00 00
		    nPos++;
		else
		    nPos=0;
		break;
	    case 2 :
		if( buffer[nPos]==0 )	// 00 00 00
		{
		} else if( buffer[nPos]==1 )	// 00 00 01
		    nPos++;
		else
		    nPos=0;
		break;
	    case 3 :
	    	ID = buffer[nPos];
		ret = ParseHeader( fp, buffer, pts_fp );
		if( ret>0 )	// Error
		{
		    buffer[0] = buffer[0+ret];
		    buffer[1] = buffer[1+ret];
		    buffer[2] = buffer[2+ret];
		    buffer[3] = buffer[3+ret];
		    if( buffer[1]==0 )
		    {
		    	if( buffer[2]==0 )
			{
			    if( buffer[3]==1 )
			    	nPos=3;
			    else
			    	nPos=0;
			} else {
			    	nPos=0;
			}
		    } else if( buffer[2]==0 )
		    {
		    	if( buffer[3]==0 )
			    nPos=2;
			else
			    nPos=0;
		    } else if( buffer[3]==0 )
		    	nPos=1;
		    else
		    	nPos=0;
		    fprintf( stdout, "%02X %02X %02X %02X\n",
		    	buffer[0],
		    	buffer[1],
		    	buffer[2],
		    	buffer[3] );
		} else {
		    nPos=0;
		}
		break;
	    }
	}

	fprintf( stdout, "fromDts   =%8X(%d)\n", fromDts, fromDts );
	fprintf( stdout, "toDts     =%8X(%d)\n", toDts  , toDts   );
	fprintf( stdout, "validStart=%X\n", validStart );
	fprintf( stdout, "validEnd  =%X\n", validEnd   );
	return 0;
}

// ------------------------------------------------------------
#if 0
int skipContent( FILE *fp, unsigned char *buffer, int bDump )
{
int i;
int zCount=0;
int readed;
	if( bShowDetail )
	{
	fprintf( stdout, "***********************************************\n" );
	fprintf( stdout, " skipContent(%X)\n", g_addr );
	fprintf( stdout, "***********************************************\n" );
	}
	while( 1 )
	{
	    readed = gread( &buffer[zCount], 1, 1, fp );
	    if( readed<1 )
	    {
	    	CannotRead( NULL );
	    	return -1;
	    }
	    if( bDump )
	    {
	    	for( i=0; i<readed; i++ )
		{
		    fprintf( stdout, "%02X ", buffer[zCount+i] );
		}
	    }
	    switch( zCount )
	    {
	    case 0 :
	    	if( buffer[zCount]==0 )
		    zCount++;
		break;
	    case 1 :	// 00 XX
	    	if( buffer[zCount]==0 )
		    zCount++;
		else
		    zCount=0;
		break;
	    case 2 :	// 00 00 XX
	    	if( buffer[zCount]==0 )	// 00 00 00
		{
			// Do nothing
		} else if( buffer[zCount]==1 ) {	// 00 00 01
//		    fprintf( stdout, "Found\n" );
		    readed = gread( &buffer[3], 1, 1, fp );
		    if( readed<1 )
		    {
			CannotRead( NULL );
			return -1;
		    }
		    if( bDump )
			fprintf( stdout, "%02X\n", buffer[3] );
		    if( bShowDetail )
		    fprintf( stdout, "skipped(%s)\n", AddrStr(g_addr) );
		    return 1;
		} else {	// 00 00 XX
		    zCount = 0;
		}
		break;
	    }
	}
	if( bDebug )
	    fprintf( stdout, "%X\n", g_addr );
	return 0;
}

int hrd_parameters( FILE *fp, unsigned char *buffer, int SPS_id )
{
int n;
int bit_rate_scale = (-1);
int cpb_size_scale = (-1);
int bit_rate_value[256];
int cpb_size_value[256];
int cbr_flag[256];
	fprintf( stdout, "hrd_parameters(%d)\n", SPS_id );
	for( n=0; n<256; n++ )
	{
	    bit_rate_value[n] =  (-1);
	    cpb_size_value[n] =  (-1);
	    cbr_flag[n]       =  (-1);
	}
	// -----------------------------------------
	avc_cpb_cnt = GetBitStreamGolomb( fp );
	bit_rate_scale = GetBitStream( fp, 4 );
	cpb_size_scale = GetBitStream( fp, 4 );
	if( bShowDetail )
	fprintf( stdout, "cpb_cnt=%d\n", avc_cpb_cnt );
	if( bShowDetail )
	fprintf( stdout, "bit_rate_scale=%d\n", bit_rate_scale );
	if( bShowDetail )
	fprintf( stdout, "cpb_size_scale=%d\n", cpb_size_scale );
	for( n=0; n<=avc_cpb_cnt; n++ )
	{
	    bit_rate_value[n] = GetBitStreamGolomb( fp );
	    if( bShowDetail )
	    fprintf( stdout, "bit_rate_value[%d]=%d\n", n, bit_rate_value[n] );
	    cpb_size_value[n] = GetBitStreamGolomb( fp );
	    if( bShowDetail )
	    fprintf( stdout, "cpb_size_value[%d]=%d\n", n, cpb_size_value[n] );
	    cbr_flag[n] = GetBitStream( fp, 1 );
	    if( bShowDetail )
	    fprintf( stdout, "cbr_flag      [%d]=%d\n", n, cbr_flag[n] );
	}
	avc_initial_cpb_removal_delay_length = GetBitStream( fp, 5 )+1;
	avc_cpb_removal_delay_length = GetBitStream( fp, 5 )+1;
	avc_dpb_output_delay_length = GetBitStream( fp, 5 )+1;
	if( bShowDetail )
	fprintf( stdout, "initial_cpb_removal_delay_length=%d\n",
		avc_initial_cpb_removal_delay_length );
	if( bShowDetail )
	fprintf( stdout, "cpb_removal_delay_length=%d\n",
		avc_cpb_removal_delay_length );
	if( bShowDetail )
	fprintf( stdout, "dpb_output_delay_length=%d\n",
		avc_dpb_output_delay_length );
#if 1	// 2011.9.23
	avc_CpbDpbDelaysPresentFlag[SPS_id] = 1;
	if( bShowDetail )
	fprintf( stdout, "avc_CpbDpbDelaysPresentFlag is set to 1\n" );;
#endif
	avc_time_offset_length = GetBitStream( fp, 5 );
	if( bShowDetail )
	fprintf( stdout, "time_offset_length=%d\n", avc_time_offset_length );
	return 0;
}

#define EXTENDED_SAR	255

int vui_parameters( FILE *fp, unsigned char *buffer, int SPS_id,
    int *pNum_units_in_tick, int *pTime_scale, int *pFixed_frame_rate_flag )
{
int aspect_ratio_info_present_flag = (-1);
int aspect_ratio = (-1);
int sar_width  = (-1);
int sar_height = (-1);
int overscan_info_present_flag = (-1);
int overscan_info = (-1);
int video_signal_type_present_flag = (-1);
int video_format = (-1);
int video_full_range_flag = (-1);
int colour_description_present_flag = (-1);
int transfer_characteristics = (-1);
int colour_primaries = (-1);
int matrix_coefficients = (-1);
int chroma_loc_info_present_flag = (-1);
int chroma_sample_loc_type_top_field = (-1);
int chroma_sample_loc_type_bottom_field = (-1);
int timing_info_present_flag = (-1);
int num_units_in_tick = (-1);
int time_scale = (-1);
int fixed_frame_rate_flag = (-1);
int low_delay_hrd_flag = (-1);
int bitstream_restriction_flag = (-1);
int motion_ectors_over_pic_boundaries_flag = (-1);
int max_bytes_per_pic_denom = (-1);
int max_bits_per_pic_denom = (-1);
int max_mv_length_horizontal = (-1);
int max_mv_length_vertical = (-1);
int num_reorder_frames = (-1);
int max_dec_frame_buffering = (-1);
	// -----------------------------------------------------
	avc_nal_hrd_parameters_present_flag[SPS_id] = (-1);
	avc_vcl_hrd_parameters_present_flag[SPS_id] = (-1);
	avc_pic_struct_present_flag        [SPS_id] = (-1);
	avc_CpbDpbDelaysPresentFlag        [SPS_id] = (-1);
	// -----------------------------------------------------
	fprintf( stdout, "vui_parameters(%d)\n", SPS_id );
	if( bRemoveTimingInfo )
	    fprintf( stdout, "bRemoveTimingInfo=%d\n", bRemoveTimingInfo );
	aspect_ratio_info_present_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "aspect_ratio_info=%d\n", 
		aspect_ratio_info_present_flag );
	if( aspect_ratio_info_present_flag )
	{
	    aspect_ratio = GetBitStream( fp, 8 );
	    if( bShowDetail )
	    fprintf( stdout, "aspect_ratio=%d\n", aspect_ratio );
	    if( aspect_ratio==EXTENDED_SAR )
	    {
		//
		UpdateProcedure( n_vui_parameters, ID_SARW, 16 );
		//
	    	sar_width  = GetBitStream( fp, 16 );
		//
		UpdateProcedure( n_vui_parameters, ID_SARH, 16 );
		//
	    	sar_height = GetBitStream( fp, 16 );
		if( bShowDetail )
		fprintf( stdout, "sar_width=%d\n", sar_width );
		if( bShowDetail )
		fprintf( stdout, "sar_height=%d\n", sar_height );
	    }
	}
	int bEditOVS=0;
	int bUpdateOVS=UpdateProcedure( n_vui_parameters, ID_OVSP, 1 );
	overscan_info_present_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "overscan_info_present=%d\n", 
		overscan_info_present_flag );
	if( bUpdateOVS )
	{
	    if( bShowDetail )
	    fprintf( stdout, "ovs(%d->%d)\n", 
		    overscan_info_present_flag, value[ID_OVSP] );
	    if( overscan_info_present_flag==1 )
	    {
		if( value[ID_OVSP]==0 )
		{
		    bEditOVS=1;
		    bEditSPS=EDIT_CUT;
		    SpecialStartAddr = BitAddr;
		    SpecialStartBits = BitOffset;
		    fprintf( stdout, "bEditSPS=%d\n", bEditSPS );
		}
	    } else {
		if( value[ID_OVSP]==1 )	// add OVS
		{
		    bEditOVS=1;
		    bEditSPS=EDIT_INS;
		    SpecialStartAddr = BitAddr;
		    SpecialStartBits = BitOffset;
		    fprintf( stdout, "bEditSPS=%d\n", bEditSPS );
		}
	    }
	}

	if( overscan_info_present_flag )
	{
	    if( bShowDetail )
	    fprintf( stdout, "ovs:BitAddr=(%s), BitOffset=%d\n",
	    	AddrStr(BitAddr), BitOffset );
	    UpdateProcedure( n_vui_parameters, ID_OVSA, 1 );
	    overscan_info = GetBitStream( fp, 1 );
	    if( bShowDetail )
	    fprintf( stdout, "overscan_info_appropriate_flag=%d\n", 
	    	overscan_info );
	}
	if( bEditOVS )
	{
	    SpecialEndAddr = BitAddr;
	    SpecialEndBits = BitOffset;
	}

	video_signal_type_present_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "video_signal_type_present=%d\n", 
	    video_signal_type_present_flag );
	if( video_signal_type_present_flag )
	{
	    video_format = GetBitStream( fp, 3 );
	    if( bShowDetail )
	    fprintf( stdout, "video_format=%d\n", video_format );
	    video_full_range_flag = GetBitStream( fp, 1 );
	    if( bShowDetail )
	    fprintf( stdout, "video_full_range=%d\n", video_full_range_flag );
	    colour_description_present_flag = GetBitStream( fp, 1 );
	    if( bShowDetail )
	    fprintf( stdout, "colour_description_present=%d\n", 
	    	colour_description_present_flag );
	    if( colour_description_present_flag )
	    {
		//
		UpdateProcedure( n_vui_parameters, ID_CP,  8 );
		//
		colour_primaries = GetBitStream( fp, 8 );
	    if( bShowDetail )
		fprintf( stdout, "colour_primaries=%d\n", colour_primaries );
		//
		UpdateProcedure( n_vui_parameters, ID_TC,  8 );
		//
		transfer_characteristics = GetBitStream( fp, 8 );
	    if( bShowDetail )
		fprintf( stdout, "transfer_characteristics=%d\n", 
			transfer_characteristics );
		//
		UpdateProcedure( n_vui_parameters, ID_MXC,  8 );
		//
		matrix_coefficients = GetBitStream( fp, 8 );
	    if( bShowDetail )
		fprintf( stdout, "matrix_coefficients=%d\n", 
			matrix_coefficients );
	    }
	}
	chroma_loc_info_present_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "chroma_loc_info_present=%d\n", 
	    chroma_loc_info_present_flag );
	if( chroma_loc_info_present_flag )
	{
	    chroma_sample_loc_type_top_field = GetBitStreamGolomb( fp );
	    chroma_sample_loc_type_bottom_field = GetBitStreamGolomb( fp );
	}

	if( bRemoveTimingInfo )
	{	// make timing_info_present_flag = 0
	    DoUpdate( BitAddr, BitOffset, 1, 0 );
	}
	timing_info_present_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "timing_info_present=%d\n", timing_info_present_flag );
	if( timing_info_present_flag==1 )
	{
	    if( bRemoveTimingInfo )
	    {
		bEditSPS = EDIT_CUT;
		SpecialStartAddr = BitAddr;
		SpecialStartBits = BitOffset;
		ShowBitAddr( );
	    }
//
	    num_units_in_tick = GetBitStream( fp, 32 );
	    if( bShowDetail )
	    fprintf( stdout, "num_units_in_tick=%d\n", num_units_in_tick );
	    time_scale = GetBitStream( fp, 32 );
	    if( bShowDetail )
	    fprintf( stdout, "time_scale=%d\n", time_scale );
	    //
	    UpdateProcedure( n_vui_parameters, ID_FRC,  1 );
	    //
	    fixed_frame_rate_flag = GetBitStream( fp, 1 );
	    if( bShowDetail )
	    fprintf( stdout, "fixed_frame_rate_flag=%d\n", 
		    fixed_frame_rate_flag );
//
	    if( bRemoveTimingInfo )
	    if( bEditSPS )
	    {
		ShowBitAddr( );
	    }
//
	}
	if( bRemoveTimingInfo )
	{
	    bEditSPS = EDIT_CUT;
	    SpecialEndAddr = BitAddr;
	    SpecialEndBits = BitOffset;
	}
	avc_nal_hrd_parameters_present_flag[SPS_id] = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "nal_hrd_parameters_present(%d)=%d\n", 
		SPS_id,
		avc_nal_hrd_parameters_present_flag[SPS_id] );
	if( avc_nal_hrd_parameters_present_flag[SPS_id]==1 )
	{
	    hrd_parameters( fp, buffer, SPS_id );
	}
	avc_vcl_hrd_parameters_present_flag[SPS_id] = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "vcl_hrd_parameters_present(%d)=%d\n", 
		SPS_id,
		avc_vcl_hrd_parameters_present_flag[SPS_id] );
	if( avc_vcl_hrd_parameters_present_flag[SPS_id]==1 )
	{
	    hrd_parameters( fp, buffer, SPS_id );
	}
	if( avc_nal_hrd_parameters_present_flag[SPS_id] 
	 || avc_vcl_hrd_parameters_present_flag[SPS_id] )
	    low_delay_hrd_flag = GetBitStream( fp, 1 );

//	ShowBitAddr( );
	if( bRemovePicStruct )
	{	// make pic_struct_present_flag = 0
	    ShowBitAddr( );
	    DoUpdate( BitAddr, BitOffset+BitSkip*8, 1, 0 );
	}
	avc_pic_struct_present_flag[SPS_id] = GetBitStream( fp, 1 );

	if( bShowDetail )
	fprintf( stdout, "pic_struct_present_flag(%d)=%d\n", 
		SPS_id,
		avc_pic_struct_present_flag[SPS_id] );
//	ShowBitAddr( );

	bitstream_restriction_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "bitstream_restriction_flag=%d\n", 
		bitstream_restriction_flag );
	if( bitstream_restriction_flag==1 )
	{
	    motion_ectors_over_pic_boundaries_flag = GetBitStream( fp, 1 );
	    max_bytes_per_pic_denom = GetBitStreamGolomb( fp );
	    max_bits_per_pic_denom = GetBitStreamGolomb( fp );
	    max_mv_length_horizontal = GetBitStreamGolomb( fp );
	    max_mv_length_vertical = GetBitStreamGolomb( fp );
	    num_reorder_frames = GetBitStreamGolomb( fp );
	    max_dec_frame_buffering = GetBitStreamGolomb( fp );
	}
	n_vui_parameters ++;
	*pNum_units_in_tick = num_units_in_tick;
	*pTime_scale        = time_scale;
	*pFixed_frame_rate_flag = fixed_frame_rate_flag;
	return 0;
}

int SequenceParameterSet( FILE *fp, unsigned char *buffer )
{
int n;
int profile_idc=(-1);
int constraint=(-1);
int level_idc=(-1);
int seq_parameter_set_id=(-1);
int chroma_format_idc=(-1);
int bit_depth_luma=(-1);
int bit_depth_chroma=(-1);
int bypass_flag = (-1);
int matrix_present_flag = (-1);
int offset_for_non_ref  = (-1);
int offset_for_top_for_bottom  = (-1);
int num_ref_frames  = (-1);
int offset_for_ref_frame[256];
int max_num_ref_frames  = (-1);
int gaps_allowed_flag = (-1);
int pic_width   = (-1);
int pic_height  = (-1);
int adaptive_frame_field_flag = (-1);
int direct_8x8_inference_flag = (-1);
int frame_cropping_flag = (-1);
int frame_crop_left_offset   = (-1);
int frame_crop_right_offset  = (-1);
int frame_crop_top_offset    = (-1);
int frame_crop_bottom_offset = (-1);
int vui_parameters_present_flag = (-1);
int ret=0;

//	bDebugGol = 1;
	bEditSPS = EDIT_NONE;
	for( n=0; n<256; n++  )
	{
	    offset_for_ref_frame[n] = (-1);
	}
	if( bShowDetail )
	fprintf( stdout, "SequenceParameterSet()\n" );
	// -------------------------------------------
	InitBitStream( );
	bDebugGolB = bDebugGol;
	//
	UpdateProcedure( n_sequenceParameters, ID_PALI,  8 );
	//
	profile_idc = GetBitStream( fp, 8 );
	if( bShowDetail )
	fprintf( stdout, "profile=%d\n", profile_idc );
	constraint  = GetBitStream( fp, 8 );
	if( bShowDetail )
	fprintf( stdout, "constraint=%d\n", constraint );
	//
	UpdateProcedure( n_sequenceParameters, ID_LVL,  8 );
	//
	level_idc   = GetBitStream( fp, 8 );
	if( bShowDetail )
	fprintf( stdout, "level=%d\n", level_idc );
	seq_parameter_set_id = GetBitStreamGolomb( fp );
	if( bShowDetail )
	fprintf( stdout, "seq_parameter_set_id=%d\n", seq_parameter_set_id );
	switch( profile_idc )
	{
	case 100 :
	case 110 :
	case 122 :
	case 244 :
	case  44 :
	case  83 :
	case  86 :
	case 118 :
	case 128 :
	    chroma_format_idc = GetBitStreamGolomb( fp );
	    if( bShowDetail )
	    fprintf( stdout, "chroma_format=%d\n", chroma_format_idc );
	    if( chroma_format_idc==3 )
	    {
	    	avc_separate_colour_plane_flag = GetBitStream( fp, 1 );
	    }
	    bit_depth_luma = GetBitStreamGolomb( fp );
	    bit_depth_chroma = GetBitStreamGolomb( fp );
	    if( bShowDetail )
	    fprintf( stdout, "bit_depth_luma  =%d\n", bit_depth_luma );
	    if( bShowDetail )
	    fprintf( stdout, "bit_depth_chroma=%d\n", bit_depth_chroma );
	    bypass_flag = GetBitStream( fp, 1 );
	    if( bShowDetail )
	    fprintf( stdout, "bypass_flag=%d\n", bypass_flag );
	    matrix_present_flag = GetBitStream( fp, 1 );
	    if( bShowDetail )
	    fprintf( stdout, "scaling_matrix_flag=%d\n", matrix_present_flag );
	    if( matrix_present_flag )
	    {
	    	int i;
	    	int n = chroma_format_idc!=3 ? 8 : 12;
		if( bShowDetail )
	    	fprintf( stdout, "matrix_present(%d)\n", n );
	    	for( i=0; i<n; i++ )
		{
		    int seq_scaling_list_present_flag;
		    seq_scaling_list_present_flag  = GetBitStream( fp, 1 );
		    if( seq_scaling_list_present_flag )
		    {
		    	int bits = 0;
		    	if( i<6 )
			{
			    bits=16;
			} else {
			    bits=64;
			}
			int b;
			for( b=0; b<bits; b++ )
			{
		    	int delta_scale = GetBitStreamGolomb( fp );
			if( bShowDetail )
			fprintf( stdout, "delta_scale=%d\n", delta_scale );
			}
		    }
		}
//		if( bShowDetail )
//		fprintf( stdout, "matrix_present_flag : under construction\n" );
//		EXIT();
	    }
	    break;
	}
	avc_log2_max_frame_num_minus4 = GetBitStreamGolomb( fp );
	if( bShowDetail )
	{
	    fprintf( stdout, "log2_max_frame_num_minus4=%d\n", 
		avc_log2_max_frame_num_minus4 );
	}
	avc_pic_order_cnt_type = GetBitStreamGolomb( fp );
	if( bShowDetail )
	fprintf( stdout, "pic_order_cnt_type=%d\n", avc_pic_order_cnt_type );
	if( avc_pic_order_cnt_type==0 )
	{
	    avc_log2_max_pic_order_cnt_lsb_minus4 = GetBitStreamGolomb( fp );
	    if( bShowDetail )
	    {
		fprintf( stdout, "log2_max_pic_order_cnt_lsb_minus4=%d\n", 
		    avc_log2_max_pic_order_cnt_lsb_minus4 );
		fprintf( stdout, "MaxPicOrderCntLsb=%d\n",
			1<<(avc_log2_max_pic_order_cnt_lsb_minus4+4+1) );
	    }
	} else if( avc_pic_order_cnt_type==1 )
	{
	    avc_delta_pic_order_always_zero_flag  = GetBitStream( fp, 1 );
	    offset_for_non_ref  = GetBitStreamGolomb( fp );
	    offset_for_top_for_bottom  = GetBitStreamGolomb( fp );
	    num_ref_frames  = GetBitStreamGolomb( fp );
	    if( bShowDetail )
		fprintf( stdout, "delta_pic_order_always_zero_flag=%d\n", 
		    avc_delta_pic_order_always_zero_flag );
	    if( bShowDetail )
	    fprintf( stdout, "offset_for_non_ref=%d\n", offset_for_non_ref );
	    if( bShowDetail )
		fprintf( stdout, "offset_for_top_for_bottom=%d\n", 
	    	offset_for_top_for_bottom );
	    if( bShowDetail )
	    fprintf( stdout, "num_ref_frames=%d\n", num_ref_frames );
	    for( n=0; n<num_ref_frames; n++ )
	    {
		offset_for_ref_frame[n]  = GetBitStreamGolomb( fp );
	    	if( bShowPOC )
		fprintf( stdout, "offset_for_ref_frame[%d]=%d\n",
			n, offset_for_ref_frame[n] );
	    }
	}
	max_num_ref_frames  = GetBitStreamGolomb( fp );
	if( bShowDetail )
	fprintf( stdout, "max_num_ref_frames=%d\n", max_num_ref_frames );
	gaps_allowed_flag = GetBitStream( fp, 1 );
	int pic_width_in_mbs_minus1        ;
	int pic_height_in_map_units_minus1 ;
	//
#if 1
	if( bShowDetail )
	fprintf( stdout, 
	"pic_width_in_mbs_minus1 at (0x%X,%d),(0x%X,%d),(0x%llX)\n", 
		BitAddr, BitOffset, BitAddr+BitOffset/8, BitOffset%8,
		SrcAddr(BitAddr+BitOffset/8,0) );
#endif
	int BitSt = BitOffset;
	pic_width_in_mbs_minus1        = GetBitStreamGolomb( fp );
	UpdateProcedureGolomb( n_sequenceParameters, ID_HSV, BitOffset-BitSt,
		GolombValue(GolombNext(pic_width_in_mbs_minus1,1)) );
	///
	BitSt = BitOffset;
	pic_height_in_map_units_minus1 = GetBitStreamGolomb( fp );
	UpdateProcedureGolomb( n_sequenceParameters, ID_VSV, BitOffset-BitSt,
		GolombValue(GolombNext(pic_width_in_mbs_minus1,1)) );
	//
	pic_width = (pic_width_in_mbs_minus1+1)*16;
	pic_height= (pic_height_in_map_units_minus1+1)*16;
	if( bShowDetail )
	fprintf( stdout, "pic_width =%d\n", pic_width );
	if( bShowDetail )
	fprintf( stdout, "pic_height=%d\n", pic_height );

	if( nEditFrameMbs>=0 )
	{	// make frame_mbs_only_flag = X
	    ShowBitAddr( );
	    DoUpdate( BitAddr, BitOffset+BitSkip*8, 1, nEditFrameMbs );
	}
	avc_frame_mbs_only_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "frame_mbs_only_flag=%d\n", avc_frame_mbs_only_flag );

	if( nEditFrameMbs>=0 )
	{
	    if( avc_frame_mbs_only_flag==1 )
	    {
	    	if( nEditFrameMbs==0 )	// 1->0
		{
		    SpecialStartAddr = BitAddr;
		    SpecialStartBits = BitOffset;
		    SpecialEndBits   = BitOffset+1;
		    bEditSPS = EDIT_INS;
		}
	    } else {
	    	if( nEditFrameMbs==1 )	// 0->1
		{
		    SpecialStartAddr = BitAddr;
		    SpecialStartBits = BitOffset;
		    SpecialEndBits   = BitOffset+1;
		    bEditSPS = EDIT_CUT;
		}
	    }
	}
	if( avc_frame_mbs_only_flag==0 )
	{
	    adaptive_frame_field_flag = GetBitStream( fp, 1 );
	} 
	direct_8x8_inference_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "direct_8x8=%d\n", direct_8x8_inference_flag );
	frame_cropping_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "cropping=%d\n", frame_cropping_flag );
	if( frame_cropping_flag )
	{
	    frame_crop_left_offset   = GetBitStreamGolomb( fp );
	    frame_crop_right_offset  = GetBitStreamGolomb( fp );
	    frame_crop_top_offset    = GetBitStreamGolomb( fp );
	    frame_crop_bottom_offset = GetBitStreamGolomb( fp );
	    if( bShowDetail )
	    {
		fprintf( stdout, "crop_left  =%d\n", frame_crop_left_offset );
		fprintf( stdout, "crop_right =%d\n", frame_crop_right_offset );
		fprintf( stdout, "crop_top   =%d\n", frame_crop_top_offset );
		fprintf( stdout, "crop_bottom=%d\n", frame_crop_bottom_offset );
	    }
	}
	vui_parameters_present_flag = GetBitStream( fp, 1 );
	if( bShowDetail )
	fprintf( stdout, "vui_parameters=%d\n", vui_parameters_present_flag );

	int time_scale=(-1);
	int num_units_in_tick=(-1);
	int fixed_framerate_flag=(-1);
	if( vui_parameters_present_flag )
	{
	    vui_parameters( fp, buffer, seq_parameter_set_id,
	    	&num_units_in_tick, &time_scale, &fixed_framerate_flag );
	}
//	bDebugGol = 0;

	n_sequenceParameters++;

	{
	static char fixed[][8] = { " - ", "nofix", "fixed" };
	char profile_str[80];
	char ip = avc_frame_mbs_only_flag ? 'P' : 'I';
	int height = pic_height;
	if( avc_frame_mbs_only_flag==0 )
	    height=height*2;
	switch( profile_idc )
	{
	case 66 :
	    sprintf( profile_str, "Constrained Baseline profile" );
	    sprintf( profile_str, "Extended profile" );
	    break;
	case 77 :
	    sprintf( profile_str, "Main profile" );
	    break;
	}

	if( time_scale<0 )
	{
	fprintf( stdout, 
"SPS(%d) : Profile(%d) Const(0x%02X) Level(%d) : %4dx%4d no_fps %c (%s)\n",
	    seq_parameter_set_id,
	    profile_idc,
	    constraint,
	    level_idc,
	    pic_width,
	    height,
	    ip,
	    fixed[fixed_framerate_flag+1] );
	} else {
	fprintf( stdout, 
"SPS(%d) : Profile(%d) Const(0x%02X) Level(%d) : %4dx%4d %d/%d/2Hz %c (%s)\n",
	    seq_parameter_set_id,
	    profile_idc,
	    constraint,
	    level_idc,
	    pic_width,
	    height,
	    time_scale,
	    num_units_in_tick,
	    ip,
	    fixed[fixed_framerate_flag+1] );
	}
	}

#if 0
	if( skipContent( fp, buffer, 0 )==1 )
	{
	    ret = 1;
	} else {
	    EXIT();
	}
#endif
	if( bEditSPS )
	{
	    int SpecialTermAddr=BitAddr;
	    int SpecialTermBits=BitOffset;
	    fprintf( stdout, "Special%d (%X,%d) (%X,%d) (%X,%d)\n",
	    	bEditSPS,
	    	SpecialStartAddr, SpecialStartBits,
	    	SpecialEndAddr, SpecialEndBits,
	    	SpecialTermAddr, SpecialTermBits );
	    g_update_addrS[g_update_countS] = BitAddr;
	    g_update_bit_S[g_update_countS] = SpecialStartBits;
	    g_update_bit_E[g_update_countS] = SpecialEndBits;
	    g_update_bit_T[g_update_countS] = SpecialTermBits;
	    g_update_mode [g_update_countS] = bEditSPS;
	    g_update_countS++;
	}
	if( bDumpSPS )
	{
	    int i=0, j=0;
	    for( i=0; i<4; i++ )
	    {
	    	fprintf( stdout, "%02X ", buffer[i] );
	    }
	    if( BitBuffer )
	    {
		for( j=0; j<BitReaded/8; j++ )
		{
		    fprintf( stdout, "%02X ", BitBuffer[j] );
		    if( ((i+j)&15)==15 )
			fprintf( stdout, "\n" );
		}
	    }
	    if( (i+j)&15 )
		fprintf( stdout, "\n" );
	}
	return ret;
}

// 2012.9.27 : try
int PictureParameterSet( FILE *fp, unsigned char *buffer )
{
int ret=0;
int i;

	if( bShowDetail )
	fprintf( stdout, "PictureParameterSet()\n" );
	// -------------------------------------------
	InitBitStream( );
	bDebugGolB = bDebugGol;
	//
	//
	int pic_parameter_set_id = GetBitStreamGolomb( fp );
	int seq_parameter_set_id = GetBitStreamGolomb( fp );
	PPStoSPS[pic_parameter_set_id] = seq_parameter_set_id;
	avc_PPS_id = pic_parameter_set_id;
	if( bShowDetail )
	{
		fprintf( stdout, "PPStoSPS[%d]=%d\n", 
			pic_parameter_set_id,
			seq_parameter_set_id );
	}
	int entropy_coding_mode_flag = GetBitStream( fp, 1 );
	avc_bottom_field_pic_order_in_frame_present_flag =GetBitStream( fp, 1 );
	int num_slice_groups_minus1 = GetBitStreamGolomb( fp );

	int slice_group_change_direction_flag=(-1);
	int slice_group_change_rate_minus1   =(-1);
	int pic_size_in_map_units_minus1     =(-1);
	if( num_slice_groups_minus1>0 )
	{
	    int iGroup;
	    int slice_group_map_type = GetBitStreamGolomb( fp );
	    switch( slice_group_map_type )
	    {
	    case 0 :
	    	for( iGroup=0; iGroup<=num_slice_groups_minus1; iGroup++ )
		{
		    int run_length_minus1 = GetBitStreamGolomb( fp );
		    if( bShowDetail )
		    fprintf( stdout, "run_length_minus1=%d\n",
			    run_length_minus1 );
		}
		break;
	    case 2 :
	    	for( iGroup=0; iGroup<=num_slice_groups_minus1; iGroup++ )
		{
		    int top_left = GetBitStreamGolomb( fp );
		    int bottom_right = GetBitStreamGolomb( fp );
		    if( bShowDetail )
		    {
		    	fprintf( stdout, "top_left=%d\n", top_left );
			fprintf( stdout, "bottom_right=%d\n", bottom_right );
		    }
		}
		break;
	    case 3 :
	    case 4 :
	    case 5 :
		slice_group_change_direction_flag = GetBitStream( fp, 1 );
		slice_group_change_rate_minus1 = GetBitStreamGolomb( fp );
		break;
	    case 6 :
	    	pic_size_in_map_units_minus1 = GetBitStreamGolomb( fp );
		for( i=0; i<=pic_size_in_map_units_minus1; i++ )
		{
		    int slice_group_id = GetBitStream( fp, 
					    num_slice_groups_minus1+1 );
		    if( bShowDetail )
		    {
		    	fprintf( stdout, "slice_group_id[%d]=%d\n",
				i, slice_group_id );
		    }
		}
		break;
	    }
	}
	int num_ref_idx_l0_default_active_minus1 = GetBitStreamGolomb( fp );
	int num_ref_idx_l1_default_active_minus1 = GetBitStreamGolomb( fp );
	int weighted_pred_flag  = GetBitStream( fp, 1 );
	int weighted_bipred_idc = GetBitStream( fp, 2 );
	int pic_init_qp_minus26 = GetBitStreamGolomb( fp );
	int pic_init_qs_minus26 = GetBitStreamGolomb( fp );
	int chroma_qp_index_offset = GetBitStreamGolomb( fp );
	int deblocking_filter_control_present_flag = GetBitStream( fp, 1 );
	int constrained_intra_pred_flag    = GetBitStream( fp, 1 );
	avc_redundant_pic_cnt_present_flag = GetBitStream( fp, 1 );

	if( bShowDetail )
	{
	    fprintf( stdout, "pic_parameter_set_id = %d\n", 
	    	pic_parameter_set_id );
	    fprintf( stdout, "seq_parameter_set_id = %d\n",
		seq_parameter_set_id );
	    fprintf( stdout, "entropy_coding_mode_flag = %d\n",
		entropy_coding_mode_flag );
	    fprintf( stdout, 
	    	"bottom_field_pic_order_in_frame_present_flag = %d\n", 
		avc_bottom_field_pic_order_in_frame_present_flag );
	    fprintf( stdout, "num_slice_groups_minus1 = %d\n",
		num_slice_groups_minus1 );
	    fprintf( stdout, "num_ref_idx_l0_default_active_minus1=%d\n",
		num_ref_idx_l0_default_active_minus1 );
	    fprintf( stdout, "num_ref_idx_l1_default_active_minus1=%d\n",
		num_ref_idx_l1_default_active_minus1 );
	    fprintf( stdout, "weighted_pred_flag =%d\n",
		weighted_pred_flag  );
	    fprintf( stdout, "weighted_bipred_idc=%d\n",
		weighted_bipred_idc );
	    fprintf( stdout, "pic_init_qp_minus26=%d\n",
		pic_init_qp_minus26 );
	    fprintf( stdout, "pic_init_qs_minus26=%d\n",
		pic_init_qs_minus26 );
	    fprintf( stdout, "chroma_qp_index_offset=%d\n",
		chroma_qp_index_offset );
	    fprintf( stdout, "deblocking_filter_control_present_flag=%d\n",
		deblocking_filter_control_present_flag );
	    fprintf( stdout, "constrained_intra_pred_flag=%d\n",
		constrained_intra_pred_flag );
	    fprintf( stdout, "redundant_pic_cnt_present_flag=%d\n",
		avc_redundant_pic_cnt_present_flag );
	}
#if 1
	if( skipContent( fp, buffer, 0 )==1 )
	{
	    ret = 1;
	} else {
	    EXIT();
	}
#endif
	return ret;
}

int ScalabilitySEI( FILE *fp, unsigned char *buffer )
{
int n, j;
int temporal_id_nesting_flag = (-1);
int priority_layer_info_present_flag = (-1);
int priority_id_setting_flag = (-1);
int num_layers_minus1 = (-1);
int layer_id = (-1);
int priority_id = (-1);
int discardable_flag = (-1);
int dependency_id = (-1);
int quality_id = (-1);
int temporal_id = (-1);
int sub_pic_layer_flag = (-1);
int sub_region_layer_flag = (-1);
int iroi_division_info_present_flag = (-1);
int profile_level_info_present_flag = (-1);
int bitrate_info_present_flag = (-1);
int frm_rate_info_present_flag = (-1);
int frm_size_info_present_flag = (-1);
int layer_dependency_info_present_flag = (-1);
int parameter_sets_info_present_flag = (-1);
int bitstream_restriction_info_present_flag = (-1);
int exact_inter_layer_pred_flag = (-1);
int exact_sample_value_match_flag = (-1);
int layer_conversion_flag = (-1);
int layer_output_flag = (-1);
int layer_profile_level_idc = (-1);
int avg_bitrate = (-1);
int max_bitrate_layer = (-1);
int max_bitrate_layer_representation = (-1);
int max_bitrate_calc_window = (-1);
int constant_frm_rate_idc = (-1);
int avg_frm_rate = (-1);
int frm_width_in_mbs_minus1  = (-1);
int frm_height_in_mbs_minus1 = (-1);
int base_region_layer_id = (-1);
int dynamic_rect_flag = (-1);
int horizontal_offset = (-1);
int vertical_offset   = (-1);
int region_width      = (-1);
int region_height     = (-1);
int roi_id = (-1);
int iroi_grid_flag = (-1);
int grid_width_in_mbs_minus1 = (-1);
int grid_height_in_mbs_minus1 = (-1);
int num_rois_minus1 = (-1);
int first_mb_in_roi = (-1);
int roi_width_in_mbs_minus1 = (-1);
int roi_height_in_mbs_minus1 = (-1);

	// ------------------------------------------------------
	fprintf( stdout, "ScalabilitySEI()\n" );
	InitBitStream( );
//	bDebugGolB = bDebugGol = 1;
	bDebugGolB = bDebugGol;
	temporal_id_nesting_flag         = GetBitStream( fp, 1 );
	priority_layer_info_present_flag = GetBitStream( fp, 1 );
	priority_id_setting_flag         = GetBitStream( fp, 1 );
	num_layers_minus1                = GetBitStreamGolomb( fp );
	for( n=0; n<=num_layers_minus1; n++ )
	{
	    layer_id                                = GetBitStreamGolomb( fp );
	    priority_id                             = GetBitStream( fp, 6 );
	    discardable_flag                        = GetBitStream( fp, 1 );
	    dependency_id                           = GetBitStream( fp, 3 );
	    quality_id                              = GetBitStream( fp, 4 );
	    temporal_id                             = GetBitStream( fp, 3 );
	    sub_pic_layer_flag                      = GetBitStream( fp, 1 );
	    sub_region_layer_flag                   = GetBitStream( fp, 1 );
	    iroi_division_info_present_flag         = GetBitStream( fp, 1 );
	    profile_level_info_present_flag         = GetBitStream( fp, 1 );
	    bitrate_info_present_flag               = GetBitStream( fp, 1 );
	    frm_rate_info_present_flag              = GetBitStream( fp, 1 );
	    frm_size_info_present_flag              = GetBitStream( fp, 1 );
	    layer_dependency_info_present_flag      = GetBitStream( fp, 1 );
	    parameter_sets_info_present_flag        = GetBitStream( fp, 1 );
	    bitstream_restriction_info_present_flag = GetBitStream( fp, 1 );
	    exact_inter_layer_pred_flag             = GetBitStream( fp, 1 );
	    if( sub_pic_layer_flag || iroi_division_info_present_flag )
		exact_sample_value_match_flag       = GetBitStream( fp, 1 );
	    layer_conversion_flag                   = GetBitStream( fp, 1 );
	    layer_output_flag                       = GetBitStream( fp, 1 );
	    if( profile_level_info_present_flag )
	    {
		layer_profile_level_idc = GetBitStream( fp, 24 );
		fprintf( stdout, "layer_profile_level=%X\n",
			layer_profile_level_idc );
	    }
	    if( bitrate_info_present_flag==1 )
	    {
		avg_bitrate                      = GetBitStream( fp, 16 );
		max_bitrate_layer                = GetBitStream( fp, 16 );
		max_bitrate_layer_representation = GetBitStream( fp, 16 );
		max_bitrate_calc_window          = GetBitStream( fp, 16 );
	    }
	    if( frm_rate_info_present_flag==1 )
	    {
		constant_frm_rate_idc = GetBitStream( fp, 2 );
		avg_frm_rate          = GetBitStream( fp, 16 );
	    }
	    if( frm_size_info_present_flag==1 )
	    {
		frm_width_in_mbs_minus1  = GetBitStreamGolomb( fp );
		frm_height_in_mbs_minus1 = GetBitStreamGolomb( fp );
	    }
	    if( sub_region_layer_flag==1 )
	    {
		base_region_layer_id = GetBitStreamGolomb( fp );
		dynamic_rect_flag = GetBitStream( fp, 1 );
		if( dynamic_rect_flag==0 )
		{
		    horizontal_offset = GetBitStream( fp, 16 );
		    vertical_offset   = GetBitStream( fp, 16 );
		    region_width      = GetBitStream( fp, 16 );
		    region_height     = GetBitStream( fp, 16 );
		}
	    }
	    if( sub_pic_layer_flag==1 )
		roi_id = GetBitStreamGolomb( fp );
	    if( iroi_division_info_present_flag==1 )
	    {
		iroi_grid_flag = GetBitStream( fp, 1 );
		if( iroi_grid_flag )
		{
		    grid_width_in_mbs_minus1 = GetBitStreamGolomb( fp );
		    grid_height_in_mbs_minus1 = GetBitStreamGolomb( fp );
		} else {
		    num_rois_minus1 = GetBitStreamGolomb( fp );
		    for( j=0; j<num_rois_minus1; j++ )
		    {
			first_mb_in_roi = GetBitStreamGolomb( fp );
			roi_width_in_mbs_minus1 = GetBitStreamGolomb( fp );
			roi_height_in_mbs_minus1 = GetBitStreamGolomb( fp );
		    }
		}
	    }
	}

	return 0;
}
// =============================================================
// SEI
//
int initial_cpb_removal_delay[8];
int initial_cpb_removal_delay_offset[8];

void SEI( char msg[], int payloadSize )
{
	if( bShowDetail )
	fprintf( stdout, "==============\n" );
	fprintf( stdout, "SEI : %s(%s) size=0x%X\n", 
//		msg, AddrStr(g_addr), payloadSize );
		msg, AddrStr2(g_addr), payloadSize );
}

int buffering_period( FILE *fp, unsigned char buffer[], int payloadSize )
{
int set_id=(-1);
int i;
	SEI( "buffering_period SEI", payloadSize );
#if 1
	set_id = GetBitStreamGolomb( fp );
	if( bShowDetail )
	fprintf( stdout, "id=%d\n", set_id );
	int NalHrdBpPresentFlag = avc_nal_hrd_parameters_present_flag[PPStoSPS[avc_PPS_id]];
	int VclHrdBpPresentFlag = avc_vcl_hrd_parameters_present_flag[PPStoSPS[avc_PPS_id]];
	if( bShowDetail )
	fprintf( stdout, "NalHrdBpPrsentFlag=%d\n", NalHrdBpPresentFlag );
	if( bShowDetail )
	fprintf( stdout, "VclHrdBpPrsentFlag=%d\n", VclHrdBpPresentFlag );
	if( bShowDetail )
	fprintf( stdout, "cpb_cnt=%d\n", avc_cpb_cnt );
	if( NalHrdBpPresentFlag==1 )
	{
	    for( i=0; i<=avc_cpb_cnt; i++ )
	    {
//	    	initial_cpb_removal_delay[i] = GetBitStreamGolomb( fp );
//	    	initial_cpb_removal_delay_offset[i] = GetBitStreamGolomb( fp );
	    	initial_cpb_removal_delay[i] = 
		    GetBitStream( fp, avc_initial_cpb_removal_delay_length );
	    	initial_cpb_removal_delay_offset[i] =
		    GetBitStream( fp, avc_initial_cpb_removal_delay_length );
		if( bShowDetail )
		fprintf( stdout, "initial_cpb_removal_delay[%d]=%d\n",
			i, initial_cpb_removal_delay[i] );
		if( bShowDetail )
		fprintf( stdout, "initial_cpb_removal_delay_offset[%d]=%d\n",
			i, initial_cpb_removal_delay_offset[i] );
	    }
	}
	if( VclHrdBpPresentFlag==1 )
	{
	    for( i=0; i<=avc_cpb_cnt; i++ )
	    {
/*
	    	initial_cpb_removal_delay[i] = GetBitStreamGolomb( fp );
	    	initial_cpb_removal_delay_offset[i] = GetBitStreamGolomb( fp );
*/
	    	initial_cpb_removal_delay[i] = 
		    GetBitStream( fp, avc_initial_cpb_removal_delay_length );
	    	initial_cpb_removal_delay_offset[i] =
		    GetBitStream( fp, avc_initial_cpb_removal_delay_length );
		if( bShowDetail )
		fprintf( stdout, "initial_cpb_removal_delay[%d]=%d\n",
			i, initial_cpb_removal_delay[i] );
		if( bShowDetail )
		fprintf( stdout, "initial_cpb_removal_delay_offset[%d]=%d\n",
			i, initial_cpb_removal_delay_offset[i] );
	    }
	}
	return 0;
#else
	if( skipContent( fp, buffer, 0 )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
#endif
}


int pic_timing( FILE *fp, unsigned char buffer[], int payloadSize )
{
int NumClockTS=1;
int i;
int cpb_removal_delay = (-1);
int dpb_output_delay  = (-1);
int pic_struct = (-1);
int clock_timestamp_flag = (-1);
int ct_type = (-1);
int nuit_field_base_flag = (-1);
int counting_type = (-1);
int full_timestamp_flag = (-1);
int discontinuity_flag = (-1);
int cnt_dropped_flag = (-1);
int n_frames = (-1);
int seconds_value = (-1);
int minutes_value = (-1);
int hours_value   = (-1);
int seconds_flag  = (-1);
int minutes_flag  = (-1);
int hours_flag  = (-1);
int time_offset = (-1);

//	bDebugGolB = bDebugGol = 1;
	bDebugGolB = bDebugGol;
	SEI( "pic_timing SEI", payloadSize );
#if 1
	if( bRemovePicStruct )
	{
	    SpecialStartAddr = BitAddr;
	    SpecialStartBits = BitOffset;
	}

	if( bShowDetail )
	fprintf( stdout, "CpbDpbDelaysPresentFlag(%d:%d)=%d\n",
		avc_PPS_id, PPStoSPS[avc_PPS_id],
		avc_CpbDpbDelaysPresentFlag[PPStoSPS[avc_PPS_id]] );

	if( avc_CpbDpbDelaysPresentFlag[PPStoSPS[avc_PPS_id]]==1 )
	{
	    cpb_removal_delay = GetBitStream( fp, 
	    	avc_cpb_removal_delay_length );
	    dpb_output_delay  = GetBitStream( fp, 
	    	avc_dpb_output_delay_length );
	    if( bShowDetail )
	    fprintf( stdout, "cpb_removal_delay=%d(0x%X)\n", 
	    	cpb_removal_delay, cpb_removal_delay );
	    if( bShowDetail )
	    fprintf( stdout, "dpb_output_delay =%d\n", dpb_output_delay  );
	}

	if( bShowDetail )
	fprintf( stdout, "pic_struct_present_flag(%d)=%d\n",
	    avc_PPS_id,
	    avc_pic_struct_present_flag[PPStoSPS[avc_PPS_id]] );
	if( avc_pic_struct_present_flag[PPStoSPS[avc_PPS_id]]==1 )
	{
/*
	    SpecialStartAddr = BitAddr;
	    SpecialStartBits = BitOffset;
*/
	    pic_struct = GetBitStream( fp, 4 );
	    switch( pic_struct )
	    {
	    case 0 :
	    case 1 :
	    case 2 :
	    	NumClockTS = 1;
		break;
	    case 3 :
	    case 4 :
	    case 7 :
	    	NumClockTS = 2;
		break;
	    case 5 :
	    case 6 :
	    case 8 :
	    	NumClockTS = 3;
		break;
	    default :
	    	fprintf( stdout, "Unknown pic_struct(%d)\n", pic_struct );
		break;
	    }
	    if( bShowDetail )
	    fprintf( stdout, "pic_struct=%d\n", pic_struct );
	    if( bShowDetail )
	    fprintf( stdout, "NumClockTS=%d\n", NumClockTS );
	    for( i=0; i<NumClockTS; i++ )
	    {
		if( bShowDetail )
		fprintf( stdout, "NumClockTS(%d/%d)\n", i, NumClockTS );
		clock_timestamp_flag = GetBitStream( fp, 1 );
		if( bShowDetail )
		    fprintf( stdout, "clock_timestamp_flag=%d\n",
			clock_timestamp_flag );
		if( clock_timestamp_flag==1 )
		{
		    ct_type              = GetBitStream( fp, 2 );
		    if( bShowDetail )
		    fprintf( stdout, "ct_type=%d\n", ct_type );
		    nuit_field_base_flag = GetBitStream( fp, 1 );
		    counting_type        = GetBitStream( fp, 5 );
		    full_timestamp_flag  = GetBitStream( fp, 1 );
		    discontinuity_flag   = GetBitStream( fp, 1 );
		    cnt_dropped_flag     = GetBitStream( fp, 1 );
		    n_frames             = GetBitStream( fp, 8 );
		    if( bShowDetail )
		    fprintf( stdout, "n_frames=%d\n", n_frames );
		    if( bShowDetail )
		    fprintf( stdout, "full_timestamp_flag=%d\n", 
		    	full_timestamp_flag );
		    if( full_timestamp_flag==1 )
		    {
			seconds_value = GetBitStream( fp, 6 );
			minutes_value = GetBitStream( fp, 6 );
			hours_value   = GetBitStream( fp, 5 );
		    } else {
			seconds_flag  = GetBitStream( fp, 1 );
			if( bShowDetail )
			fprintf( stdout, "seconds_flag=%d\n", seconds_flag );
			if( seconds_flag )
			{
			    seconds_value = GetBitStream( fp, 6 );
			    minutes_flag  = GetBitStream( fp, 1 );
			    if( bShowDetail )
			    fprintf( stdout, "minutes_flag=%d\n", minutes_flag );
			    if( minutes_flag )
			    {
				minutes_value = GetBitStream( fp, 6 );
				hours_flag  = GetBitStream( fp, 1 );
				fprintf( stdout, "hours_flag=%d\n", 
				    hours_flag );
				if( hours_flag )
				{
				    hours_value = GetBitStream( fp, 5 );
				}
			    }
			}
		    }
		    if( seconds_value>=0 )
		    fprintf( stdout, "seconds_value=%d\n", seconds_value );
		    if( minutes_value>=0 )
		    fprintf( stdout, "minutes_value=%d\n", minutes_value );
		    if( hours_value>=0 )
		    fprintf( stdout, "hours_value  =%d\n", hours_value );
		    if( avc_time_offset_length>0 )
		    {
			if( bShowDetail )
			fprintf( stdout, "time_offset_length=%d\n", 
				avc_time_offset_length );
//			time_offset = GetBitStreamGolomb( fp );
// 2011/9/29
			time_offset = GetBitStream( fp, 
				avc_time_offset_length );
			if( bShowDetail )
			fprintf( stdout, "time_offset =%d(0x%X)\n", 
				time_offset, time_offset );
		    }
		}
	    }
//	fprintf( stdout, "BitSkip=%d\n", BitSkip );
	    if( bRemovePicStruct )
	    {
		int addr1 = SpecialStartAddr + SpecialStartBits/8;
		int addr2 = BitAddr          + BitOffset       /8;
		int addr;
		int SP=BitSkip;
		DoUpdate( addr1-2, 0, 8, 0x03 );	// filler_payload
		DoUpdate( addr1-1, 0, 8, payloadSize+SP );
		for( addr=addr1; addr<=(addr2+SP); addr++ )
		{
		    DoUpdate( addr, 0, 8, 0xFF );	// filler_payload
		}
	    }
	}
	return 0;
#else
	if( skipContent( fp, buffer, bDebugSkip )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
#endif
}

// 2011.7.28
int filler_payload( FILE *fp, unsigned char buffer[], int payloadSize )
{
int i;
int ff_byte;
int error=0;

	bDebugGolB = bDebugGol;
	SEI( "filler_payload", payloadSize );
#if 1
	for( i=0; i<payloadSize; i++ )
	{
	    ff_byte = GetBitStream( fp, 8 );
	    if( ff_byte!=0xFF )
	    {
	    	fprintf( stdout, "ff_byte=0x%02X\n", ff_byte );
		error++;
	    }
	}
	if( error==0 )
	    return 0;
	else
	    return 1;
#else
	if( skipContent( fp, buffer, bDebugSkip )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
#endif
}

int user_data_registered( FILE *fp, unsigned char buffer[], int payloadSize )
{
int i;
	bDebugGolB = bDebugGol;
	SEI( "user_data_registered", payloadSize );
#if 1
	unsigned char user_data;
	if( bUserData )
	{
	    fprintf( stdout, "[UserData] pts  = 0x%04X%06X\n", 
//		    userdata_ptsh, userdata_ptsl );
		    g_PTSH, g_PTSL );
	    fprintf( stdout, "[UserData] size = 0x%08X\n", payloadSize );
	    fprintf( stdout, "[UserData] data =" );
	}
	for( i=0; i<payloadSize; i++ )
	{
	    user_data = GetBitStream( fp, 8 );
	    if( bUserData )
		fprintf( stdout, " %02X", user_data );
	}
	if( bUserData )
	    fprintf( stdout, "\n" );
	b_user_data = 1;
	return 0;	// 2012.11.12
#else
	if( skipContent( fp, buffer, bDebugSkip )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
#endif
}

int user_data_unregistered( FILE *fp, unsigned char buffer[], int payloadSize )
{
int i;
	bDebugGolB = bDebugGol;
	SEI( "user_data_unregistered", payloadSize );
#if 1
	unsigned char user_data;
	if( bUserData )
	{
	    fprintf( stdout, "[UserData] pts  = 0x%04X%06X\n", 
//		    userdata_ptsh, userdata_ptsl );
		    g_PTSH, g_PTSL );
	    fprintf( stdout, "[UserData] size = 0x%08X\n", payloadSize );
	    fprintf( stdout, "[UserData] data =" );
	}
	for( i=0; i<payloadSize; i++ ) 
	{
	    user_data = GetBitStream( fp, 8 );
	    if( bUserData )
		fprintf( stdout, " %02X", user_data );
	}
	if( bUserData )
	    fprintf( stdout, "\n" );
	b_user_data = 1;
	return 0;	// 2012.11.12
#else
	if( skipContent( fp, buffer, bDebugSkip )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
#endif
}

int recovery_point( FILE *fp, unsigned char buffer[], int payloadSize )
{
int recovery_frame_cnt       = (-1);
int exact_match_flag         = (-1);
int broken_link_flag         = (-1);
int changing_slice_group_idc = (-1);

//	bDebugGolB = bDebugGol = 1;
	bDebugGolB = bDebugGol;
	SEI( "recovery_point SEI", payloadSize );
#if 1
	recovery_frame_cnt       = GetBitStreamGolomb( fp );
	exact_match_flag         = GetBitStream( fp, 1 );
	broken_link_flag         = GetBitStream( fp, 1 );
	changing_slice_group_idc = GetBitStream( fp, 2 );
	if( bShowDetail )
	{
	fprintf( stdout, "recovery_frame_cnt=%d\n", recovery_frame_cnt );
	fprintf( stdout, "exact_match_flag=%d\n", exact_match_flag );
	fprintf( stdout, "broken_link_flag=%d\n", broken_link_flag );
	fprintf( stdout, "changing_slice_group=%d\n", 
		changing_slice_group_idc );
	}
	return 0;
#else
	if( skipContent( fp, buffer, bDebugSkip )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
#endif
}
int frame_packing_arrangement( FILE *fp, unsigned char buffer[], 
	int payloadSize )
{
int frame_packing_arrangement_id       = (-1);
int frame_packing_arrangement_cancel_flag = (-1);
int frame_packing_arrangement_type = (-1);
int quincunx_sampling_flag         = (-1);
int content_interpretation_type    = (-1);
int spatial_flipping_flag          = (-1);
int frame0_flipped_flag            = (-1);
int field_views_flag               = (-1);
int current_frame_is_frame0_flag   = (-1);
int frame0_self_contained_flag     = (-1);
int frame1_self_contained_flag     = (-1);
int frame0_grid_position_x = (-1);
int frame0_grid_position_y = (-1);
int frame1_grid_position_x = (-1);
int frame1_grid_position_y = (-1);
int frame_packing_arrangement_reserved_byte = (-1);
int frame_packing_arrangement_repetition_period = (-1);
int frame_packing_arrangement_extension_flag = (-1);
int i;
//	bDebugGolB = bDebugGol = 1;
	bDebugGolB = bDebugGol;
	SEI( "frame_packing_arrangement SEI", payloadSize );
	
	int pos = ftell(fp);
	unsigned int l_addr = g_addr;
//	fprintf( stdout, "pos=0x%x\n", pos );
	unsigned char user_data;
	if( bUserData )
	{
	    fprintf( stdout, "[UserData] pts  = 0x%04X%06X\n", 
//		    userdata_ptsh, userdata_ptsl );
		    g_PTSH, g_PTSL );
	    fprintf( stdout, "[UserData] size = 0x%08X\n", payloadSize );
	    fprintf( stdout, "[UserData] data =" );
	}
	for( i=0; i<payloadSize; i++ )
	{
	    user_data = GetBitStream( fp, 8 );
	    if( bUserData )
		fprintf( stdout, " %02X", user_data );
	}
	if( bUserData )
	    fprintf( stdout, "\n" );
	b_user_data = 1;
//	fprintf( stdout, "fseek(%X)%X,%X\n", pos, g_addr, payloadSize );
	fseek( fp, pos, SEEK_SET );
//	g_addr -= payloadSize;
	g_addr = l_addr;
	InitBitStream();
#if 1
	frame_packing_arrangement_id       = GetBitStreamGolomb( fp );
	fprintf( stdout, "frame_packing_arrangement_id=%d\n",
		frame_packing_arrangement_id );
	frame_packing_arrangement_cancel_flag = GetBitStream( fp, 1 );
	fprintf( stdout, "frame_packing_arrangement_cancel_flag=%d\n",
		frame_packing_arrangement_cancel_flag );
	if( frame_packing_arrangement_cancel_flag==0 )
	{
	    frame_packing_arrangement_type = GetBitStream( fp, 7 );
	    fprintf( stdout, "frame_packing_arrangement_type=%d\n",
		frame_packing_arrangement_type );
	    quincunx_sampling_flag         = GetBitStream( fp, 1 );
	    content_interpretation_type    = GetBitStream( fp, 6 );
	    spatial_flipping_flag          = GetBitStream( fp, 1 );
	    frame0_flipped_flag            = GetBitStream( fp, 1 );
	    field_views_flag               = GetBitStream( fp, 1 );
	    current_frame_is_frame0_flag   = GetBitStream( fp, 1 );
	    frame0_self_contained_flag     = GetBitStream( fp, 1 );
	    frame1_self_contained_flag     = GetBitStream( fp, 1 );
	    if( (quincunx_sampling_flag==0)
	    && (frame_packing_arrangement_type!=5) )
	    {
		frame0_grid_position_x = GetBitStream( fp, 4 );
		frame0_grid_position_y = GetBitStream( fp, 4 );
		frame1_grid_position_x = GetBitStream( fp, 4 );
		frame1_grid_position_y = GetBitStream( fp, 4 );
	    }
	    frame_packing_arrangement_reserved_byte = GetBitStream( fp, 8 );
	    frame_packing_arrangement_repetition_period = 
	    	GetBitStreamGolomb( fp );
	}
	frame_packing_arrangement_extension_flag = GetBitStream( fp, 1 );
	fprintf( stdout, "frame_packing_arrangement_extension_flag=%d\n",
	    frame_packing_arrangement_extension_flag );

	if( bFramePackingArrangement )
	    fprintf( stdout, 
	    "FPA[%d %d %d %d %d %d %d %d %d %d %d %1x%1x%1x%1x %02x %d %d]\n", 
	        frame_packing_arrangement_id,
	        frame_packing_arrangement_cancel_flag,
	        frame_packing_arrangement_type,
	        quincunx_sampling_flag,
	        content_interpretation_type,
	        spatial_flipping_flag,
	        frame0_flipped_flag,
	        field_views_flag,
	        current_frame_is_frame0_flag,
	        frame0_self_contained_flag,
	        frame1_self_contained_flag,
	        (frame0_grid_position_x == (-1) ? 0 : frame0_grid_position_x),
	        (frame0_grid_position_y == (-1) ? 0 : frame0_grid_position_y),
	        (frame1_grid_position_x == (-1) ? 0 : frame1_grid_position_x),
	        (frame1_grid_position_y == (-1) ? 0 : frame1_grid_position_y),
	        frame_packing_arrangement_reserved_byte,
	        frame_packing_arrangement_repetition_period,
	        frame_packing_arrangement_extension_flag );

	return 0;
#else
	if( skipContent( fp, buffer, bDebugSkip )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
#endif
}
int sub_seq_characteristics( FILE *fp, unsigned char buffer[], int payloadSize )
{
	SEI( "sub_seq_characteristics SEI", payloadSize );
	fprintf( stdout, "No parse\n" );
	if( skipContent( fp, buffer, 0 )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
}

int scene_info( FILE *fp, int payloadSize )
{
int scene_info_present_flag = (-1);
int scene_id = (-1);
int scene_transition_type = (-1);
int second_scene_id = (-1);
	// -------------------------------------------------
	SEI( "scene_info", payloadSize );
	scene_info_present_flag = GetBitStream( fp, 1 );
	fprintf( stdout, "scene_info_present_flag = %d\n", 
		scene_info_present_flag );
	if( scene_info_present_flag==1 )
	{
	    scene_id = GetBitStreamGolomb( fp );
	    fprintf( stdout, "scene_id = %d\n", scene_id );
	    scene_transition_type = GetBitStreamGolomb( fp );
	    fprintf( stdout, "scene_transition_typ = %d\n", 
	    	scene_transition_type );
	    if( scene_transition_type>3 )
		second_scene_id = GetBitStreamGolomb( fp );
	}
	return 0;
}

//int pan_scan_rect( FILE *fp, unsigned char *buffer )
int pan_scan_rect( FILE *fp, int payloadSize )
{
int id=(-1);
int cancel_flag=(-1);
int cnt_minus1=(-1);
int left_offset=(-1);
int right_offset=(-1);
int top_offset=(-1);
int bottom_offset=(-1);
int period=(-1);
int i;
	// -------------------------------------------------
	SEI( "pan_scan_rect", payloadSize );
	int tmp = bDebugGolB;
	bDebugGolB = 1;

	id          = GetBitStreamGolomb( fp );
	cancel_flag = GetBitStream( fp, 1 );
	fprintf( stdout, "id=%d\n", id );
	fprintf( stdout, "pan_scan_rect_cancel_flag=%d\n", cancel_flag );
	if( cancel_flag==0 )
	{
	    cnt_minus1  = GetBitStreamGolomb( fp );
	    for( i=0; i<=cnt_minus1; i++ )
	    {
		int BitSt;
		BitSt = BitOffset;
		left_offset   = GetBitStreamGolomb( fp );
//		int next = GolombNext( left_offset, value[ID_PANL] );
//		fprintf( stdout, "Update Golomb(%d->%d)\n", left_offset, next );
		UpdateProcedureGolomb( n_pan_scan, 
		    ID_PANL, BitOffset-BitSt,
		    GolombValue(GolombNext(left_offset, value[ID_PANL])) );

		BitSt = BitOffset;
		right_offset  = GetBitStreamGolomb( fp );
		UpdateProcedureGolomb( n_pan_scan, 
		    ID_PANR, BitOffset-BitSt,
		    GolombValue(GolombNext(right_offset, value[ID_PANR])) );

		BitSt = BitOffset;
		top_offset    = GetBitStreamGolomb( fp );
		UpdateProcedureGolomb( n_pan_scan, 
		    ID_PANT, BitOffset-BitSt,
		    GolombValue(GolombNext(top_offset, value[ID_PANT])) );

		BitSt = BitOffset;
		bottom_offset = GetBitStreamGolomb( fp );
		UpdateProcedureGolomb( n_pan_scan, 
		    ID_PANB, BitOffset-BitSt,
		    GolombValue(GolombNext(bottom_offset, value[ID_PANB])) );

		fprintf( stdout, 
		"pan_scan_cnt(%d) : left=%d, right=%d, top=%d, bottom=%d\n",
			i,
			left_offset,
			right_offset,
			top_offset,
			bottom_offset );
	    }
	    period = GetBitStreamGolomb( fp );
	    fprintf( stdout, "pan_scan_repetition_period=%d\n", period );
	}

	bDebugGolB = tmp;
	n_pan_scan ++;

	return 0;
}

int quality_layer_integrity_check( FILE *fp, unsigned char *buffer )
{
int i;
int cnt_minus1 = (-1);

	// -------------------------------------------------
	fprintf( stdout, "==============\n" );
	fprintf( stdout, "quality_layer_integrity_check() : (%s)\n", 
		AddrStr(BitAddr+BitOffset/8) );
	int tmp = bDebugGolB;
	bDebugGolB = 1;

	{
	    int entry_dependency_id;
	    int quality_layer_crc  ;
	    cnt_minus1  = GetBitStreamGolomb( fp );
	    fprintf( stdout, "num_minus1=%d\n", cnt_minus1 );
	    for( i=0; i<=cnt_minus1; i++ )
	    {
		entry_dependency_id   = GetBitStream( fp,  3 );
		quality_layer_crc     = GetBitStream( fp, 16 );
		fprintf( stdout, "%d : %d, %d\n",
			i, 
			entry_dependency_id,
			quality_layer_crc );
	    }
	}

	bDebugGolB = tmp;

	return 0;
}

int deblocking_filter_display_preference( FILE *fp, unsigned char *buffer,
	int payloadSize )
{
	SEI( "deblocking_filter_display_preference SEI", payloadSize );
	fprintf( stdout, "No parse\n" );
	if( skipContent( fp, buffer, 0 )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
}

int SupplementalEnhancementInformation( FILE *fp, unsigned char *buffer );

int mvc_scalable_nesting( FILE *fp, unsigned char buffer[], int payloadSize )
{
int ret=(-1);
	fprintf( stdout, "-----------------------------------------------\n" );
	SEI( "mvc_scalable_nesting SEI", payloadSize );
	int operation_point_flag = GetBitStream( fp, 1 );
	if( bShowMvcScalable )
	fprintf( stdout, "operation_point_flag=%d\n", operation_point_flag );
	if( operation_point_flag==1 )
	{
	    int num_view_components_op_minus1 = GetBitStreamGolomb( fp );
	    if( bShowMvcScalable )
	    fprintf( stdout, "num_view_components_op_minus1=%d\n",
	    	num_view_components_op_minus1 );
	    int i;
	    for( i=0; i<=num_view_components_op_minus1; i++ )
	    {
	    	int sei_op_view_id = GetBitStream( fp, 10 );
		if( bShowMvcScalable )
		fprintf( stdout, "sei_op_view_id = %2d\n", sei_op_view_id );
	    }
	    int sei_op_temporal_id = GetBitStream( fp, 3 );
	    if( bShowMvcScalable )
	    fprintf( stdout, "temporal_id = %d\n", sei_op_temporal_id );
	} else {
	    int all_view_components_in_au_flag = GetBitStream( fp, 1 );
	    if( bShowMvcScalable )
	    fprintf( stdout, "all_view_components_in_au_flag = %d\n", 
	    	all_view_components_in_au_flag );
	    if( all_view_components_in_au_flag==0 )
	    {
		int num_view_components_minus1 = GetBitStreamGolomb( fp );
		if( bShowMvcScalable )
		fprintf( stdout, "num_view_components_minus1=%d\n",
		    num_view_components_minus1 );
		int i;
		for( i=0; i<=num_view_components_minus1; i++ )
		{
		    int sei_view_id = GetBitStream( fp, 10 );
		    if( bShowMvcScalable )
		    fprintf( stdout, "sei_view_id = %2d\n", sei_view_id );
		}
	    }
	}
	fprintf( stdout, "-----------------------------------------------\n" );
	int aa = BitOffset&7;
	if( bDebugSEI )
	fprintf( stdout, "BitOffset=%d, aa=%d\n", BitOffset, aa );
	if( aa>0 )
	{
	     int dummy = GetBitStream( fp, 8-aa );
	     if( bDebug )
	     fprintf( stdout, "Dummy %d bits=0x%X\n", 8-aa,dummy );
	}
	ret = SupplementalEnhancementInformation( fp, buffer );
	if( ret==1 )
	{
	    buffer[1] = GetBitStream( fp, 8 );
	    buffer[2] = GetBitStream( fp, 8 );
	    buffer[3] = GetBitStream( fp, 8 );
	    fprintf( stdout, "(%02X %02X %02X)\n",
	    	buffer[1], buffer[2], buffer[3] );
	} else {
	    if( skipContent( fp, buffer, 0 )==1 )
	    {
	    } else {
		EXIT();
	    }
	}
	return 1;
}

int scalability_info( FILE *fp, unsigned char buffer[], int payloadSize )
{
	fprintf( stdout, "-----------------------------------------------\n" );
	SEI( "scalability_info SEI", payloadSize );

	int temporal_id_nesting_flag = GetBitStream( fp, 1 );
	int priority_layer_info_present_flag = GetBitStream( fp, 1 );
	int priority_id_setting_flag = GetBitStream( fp, 1 );
	int num_layers_minus1 = GetBitStreamGolomb( fp );

fprintf( stdout, "temporal_id_nesting_flag=%d\n", temporal_id_nesting_flag );
fprintf( stdout, "priority_layer_info_present_flag=%d\n", priority_layer_info_present_flag );
fprintf( stdout, "priority_id_setting_flag=%d\n", priority_id_setting_flag );
fprintf( stdout, "num_layers_minus1=%d\n", num_layers_minus1 );
/*
	for( i=0; i<=num_layers_minus1; i++ )
	{
	    int layer_id = GetBitStreamGolomb( fp );
	    int priority_id = GetBitStream( fp, 6 );
	}
*/
	if( skipContent( fp, buffer, 0 )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
}
int view_scalability_info( FILE *fp, unsigned char buffer[], int payloadSize )
{
	fprintf( stdout, "-----------------------------------------------\n" );
	SEI( "view_scalability_info SEI", payloadSize );

	if( skipContent( fp, buffer, 0 )==1 )
	{
	} else {
	    EXIT();
	}
	return 1;
}
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
int reserved_sei( FILE *fp, unsigned char buffer[], int payloadSize )
{
int i;
	fprintf( stdout, "-----------------------------------------------\n" );
	SEI( "reserved SEI", payloadSize );
#if 1
	for( i=0; i<payloadSize; i++ ) 
	{
	    int dummy = GetBitStream( fp, 8 );
	    if( bDebug )
	    	fprintf( stdout, "%02X ", dummy );
	}
	    if( bDebug )
	    	fprintf( stdout, "\n" );
#else
	if( skipContent( fp, buffer, 0 )==1 )
	{
	} else {
	    EXIT();
	}
#endif
	fprintf( stdout, "-----------------------------------------------\n" );
	return 1;
}

int SupplementalEnhancementInformation( FILE *fp, unsigned char *buffer )
{
int payloadType = (-1);
int payloadSize = (-1);
int nFF=0;
	// -------------------------------------------------
	if( bShowDetail )
	fprintf( stdout, "SupplementalEnhancementInformation()\n" );

	if( bDebugSEI )
	fprintf( stdout, "Addr(%s)\n", AddrStr(g_addr) );

	if( Packets==NULL )
	{
	    fprintf( stdout, "Packets=NULL\n" );
	    return -1;
	}
	int nSEI=0;
	InitBitStream( );
	while( 1 )
	{
	    if( bDebugSEI )
	    {
	    	fprintf( stdout, "+++++++++++++++(%2d)++++++++++++++\n", nSEI );
	    }
	    nFF=0;
	    do {
		payloadType     = GetBitStream( fp, 8 );
		if( payloadType==0xFF )
		    nFF++;
	    } while( payloadType==0xFF );
	    payloadType += nFF*0xFF;

	    nFF=0;
	    do {
		payloadSize     = GetBitStream( fp, 8 );
		if( payloadSize==0xFF )
		    nFF++;
	    } while( payloadSize==0xFF );
	    payloadSize += nFF*0xFF;
	    if( bDebugSEI )
	    {
	    fprintf( stdout, "payloadType=0x%X\n", payloadType );
	    fprintf( stdout, "payloadSize=0x%X\n", payloadSize );
	    }
	    Packets[0x0600 | payloadType]++;

//	    InitBitStream( );
	    int sei_start = BitOffset;
	    // SEI payload
	    if( payloadSize==0 )
	    {
		if( bDebugSEI )
	    	fprintf( stdout, "SEI done\n" );
#if 0
		char str[1024];
		sprintf( str, "SEI(%02X) ??", payloadType );
		SEI( str, payloadSize );
#endif
	    	break;
	    }
	    switch( payloadType )
	    {
	    case 0 :
		if( buffering_period( fp, buffer, payloadSize )==1 )
		    return 4;
		break;
	    case 1 :
		if( pic_timing( fp, buffer, payloadSize )==1 )
		    return 4;
		break;
	    case 3 :	// 2011.7.28
		if( filler_payload( fp, buffer, payloadSize )!=0 )
		    return 4;
		break;
	    case 4 :
		if( user_data_registered( fp, buffer, payloadSize )!=0 )
		    return 4;
		break;
	    case 5 :
		if( user_data_unregistered( fp, buffer, payloadSize )!=0 )
		    return 4;
		break;

	    case 6 :
		if( recovery_point( fp, buffer, payloadSize )!=0 )
		    return 4;
		break;
	    case 45 :
		if( frame_packing_arrangement( fp, buffer, payloadSize )==1)
		    return 4;
		break;

	    case 12 :
		sub_seq_characteristics( fp, buffer, payloadSize );
		return 4;
	    case 9 :
		scene_info( fp, payloadSize );
		break;
	    case 2 :
		pan_scan_rect( fp, payloadSize );
		break;
	// akagawa
	    case 32 :
		quality_layer_integrity_check( fp, buffer );
		break;
	// AKB
	    case 20 :
		if( deblocking_filter_display_preference( fp, buffer,
			payloadSize )==1 )
			return 4;
		break;
	// MVC (victor)
	    case 37 :
		if( mvc_scalable_nesting( fp, buffer, payloadSize )==1 )
		    return 4;
		break;
	    case 24 :
		if( scalability_info( fp, buffer, payloadSize )==1 )
		    return 4;
		break;
	// MVC (allegro)
	    case 38 :
	    	if( view_scalability_info( fp, buffer, payloadSize )==1 )
		    return 4;
	    	break;
	    default :
		fprintf( stdout, 
			"payloadType(%d) : not implemented (%s)\n",
			payloadType, AddrStr(g_addr) );
		if( payloadType>45 )
		{
		    if( reserved_sei( fp, buffer, payloadSize )==1 )
			return 4;
		} else {
		    if( bSkipError==0 )
			EXIT();
		    else
		    	fprintf( stdout, "SkipError\n" );
		}
		break;
	    }
	    ShowBitAddr( );

	    int rest = payloadSize*8;
	    if( bDebugSEI )
	    {
	    fprintf( stdout, 
		    "sei_start=%d,restBit=%d,BitOffset=%d,BitSkip=%d*8\n", 
		    sei_start,
		    rest, BitOffset, BitSkip );
	    fprintf( stdout, "rest=%d, payloadSize=%d\n", rest, payloadSize);
	    fprintf( stdout, "BitOffset=%d, BitSkip=%d\n", 
	    	BitOffset, BitSkip);
	    }
	    if( (BitOffset-BitSkip*8-sei_start)>rest )
	    {
	    	fprintf( stdout, "payloadSize=%d\n", payloadSize );
	    	fprintf( stdout, 
		    "restBit=%d < (BitOffset=%d,BitSkip=%d*8,sei_start=%d)\n", 
		    rest, BitOffset, BitSkip, sei_start );
		if( bSkipError==0 )
		    EXIT();
		else
		    fprintf( stdout, "SkipError\n" );
	    }
	    rest -= (BitOffset-sei_start);	// 2011.9.29
	    while( rest>0 )
	    {
	    	int dummy;
	    	int size = (rest&7) ? rest&7 : 8;
		dummy = GetBitStream( fp, size );
	    if( bDebugSEI )
		fprintf( stdout, 
		"dummy(rest=%2d, size=%d, dummy=%02X)\n", rest, size, dummy );
		rest -= size;
	    }
	    if( bDebugSEI )
	    {
	    fprintf( stdout, "g_addr=%X\n", g_addr );
	    fprintf( stdout, "BitOffset=%d, BitSkip=%d\n", 
	    	BitOffset, BitSkip);
	    }
	    nSEI++;
	}
	    if( bDebugSEI )
	    	fprintf( stdout, "===============(%2d)===============n", nSEI );
	buffer[0]=0;
	buffer[1]=0;
	if( payloadType==0 )
	    return 2;	// readed size
	else
	    return 1;	// readed size
}
// --------------------------------------------------------------------------

int nal_unit_header_svc_extension( FILE *fp, unsigned char *buffer )
{
	fprintf( stdout, "-----------------------------------------------\n" );
	fprintf( stdout, "nal_unit_header_svc_extension()\n" );
	if( skipContent( fp, buffer, 0 )==1 )
	{
	} else {
	    EXIT();
	}
	return 0;
}
int mvc_extension = 0;
int mvc_non_idr_flag     = (-1);
int mvc_priority_id      = (-1);
int mvc_view_id          = (-1);
int mvc_temporal_id      = (-1);
int mvc_anchor_pic_flag  = (-1);
int mvc_inter_view_flag  = (-1);
int nal_unit_header_mvc_extension( FILE *fp, unsigned char *buffer )
{
	fprintf( stdout, "nal_unit_header_mvc_extension()\n" );
	mvc_extension = 1;
	mvc_non_idr_flag     = GetBitStream( fp, 1 );
	mvc_priority_id      = GetBitStream( fp, 6 );
	mvc_view_id          = GetBitStream( fp, 10 );
	mvc_temporal_id      = GetBitStream( fp, 3 );
	mvc_anchor_pic_flag  = GetBitStream( fp, 1 );
	mvc_inter_view_flag  = GetBitStream( fp, 1 );
	int reserved_one_bit = GetBitStream( fp, 1 );
	if( bShowMvcExtention )
	{
	fprintf( stdout, "non_idr_flag    =%d\n", mvc_non_idr_flag );
	fprintf( stdout, "priority_id     =%d\n", mvc_priority_id );
	fprintf( stdout, "view_id         =%d\n", mvc_view_id );
	fprintf( stdout, "temporal_id     =%d\n", mvc_temporal_id );
	fprintf( stdout, "anchor_pic_flag =%d\n", mvc_anchor_pic_flag );
	fprintf( stdout, "inter_view_flag =%d\n", mvc_inter_view_flag );
	fprintf( stdout, "reserved_one_bit=%d\n", reserved_one_bit );
	}
	return 0;
}

// -------------------------------------------------------------

int AccessUnitDelimiter( FILE *fp, unsigned char *buffer )
{
int picType=(-1);
	// -------------------------------------------------
	InitBitStream( );
	picType = GetBitStream( fp, 3 );
	if( bShowDetail )
	fprintf( stdout, "AccessUnitDelimiter(%d)\n", picType );
	avc_IdrPicFlag = 0;
	if( picType==0 )
	{
	    fprintf( stdout, "IDR begin(%s)\n", AddrStr(g_addr) );
	    avc_IdrPicFlag = 1;
	    // Reset parameters
	    avc_cpb_cnt = (-1);
	    avc_time_offset_length = (-1);

	    avc_nal_hrd_parameters_present_flag[PPStoSPS[avc_PPS_id]]=(-1);
	    avc_vcl_hrd_parameters_present_flag[PPStoSPS[avc_PPS_id]]=(-1);
	    avc_pic_struct_present_flag        [PPStoSPS[avc_PPS_id]]=(-1);
	    avc_CpbDpbDelaysPresentFlag        [PPStoSPS[avc_PPS_id]]=(-1);
	}
	return 0;
}

int FillerData( FILE *fp, unsigned char *buffer )
{
int ffByte;
int nSize=0;
	InitBitStream( );
	int tmp = bDebugGolB;
	bDebugGolB = 0;
	while( 1 )
	{
//	fprintf( stdout, "0x%X,%d : ", g_addr, BitOffset );
	    ffByte = GetBitStream( fp, 8 );
	    nSize++;
	    if( ffByte!=0xFF )
		break;
	}
	bDebugGolB = tmp;
	if( bShowDetail )
	fprintf( stdout, "FillerData() : %d bytes\n", nSize );
	return 0;
}

int Slice_header( FILE *fp, unsigned char *buffer, 
	int nal_unit_type, int nal_ref_idc )
{
int field_pic_flag = (-1);
int bEdit = EDIT_NONE;
int tmp = bDebugGolB;

	InitBitStream( );
	bDebugGolB = 0;

//	if( bShowDetail )
//	fprintf( stdout, "Slice_header()\n" );
	int first_mb_in_slice    = GetBitStreamGolomb( fp );
	int slice_type           = GetBitStreamGolomb( fp );
	int pic_parameter_set_id = GetBitStreamGolomb( fp );
	if( PPStoSPS[pic_parameter_set_id]<0 )
	{
	    fprintf( stdout, "************ Error ************\n" );
	    fprintf( stdout, "Invalid pic_parameter_set_id(%d)\n",
		    pic_parameter_set_id );
//	    EXIT();
	}
	avc_PPS_id = pic_parameter_set_id;
//	fprintf( stdout, "PPS_id=%d\n", avc_PPS_id );
	if( avc_separate_colour_plane_flag==1 )
	{
	    int colour_plane_id = GetBitStream( fp, 1 );
	    if( bShowDetail )
		fprintf( stdout, "colour_plane_id = %d\n", colour_plane_id );
	}
//	int frame_num            = GetBitStreamGolomb( fp );
	int frame_num_bits = avc_log2_max_frame_num_minus4+4;
	int frame_num            = GetBitStream( fp, frame_num_bits );
	if( bShowDetail )
	{
	fprintf( stdout, "first_mb_in_slice = %d\n", first_mb_in_slice );
	fprintf( stdout, "slice_type        = %d\n", slice_type        );
	fprintf( stdout, "pic_parameter_set = %d\n", pic_parameter_set_id );
	fprintf( stdout, "frame_num         = %d(%dbits)\n", 
		frame_num, frame_num_bits );
	}

/* slice_type
0	P
1	B
2	I
3	SP
4	SI
5	P
6	B
7	I
8	SP
9	SI
*/
#define PCT_I	1
#define PCT_P	2
#define PCT_B	3
	if ( first_mb_in_slice == 0 )
	{
	    switch (slice_type) {
	    case 2:
	    case 4:
	    case 7:
	    case 9:
		picture_coding_type = PCT_I;
		break;
	    case 0:
	    case 3:
	    case 5:
	    case 8:
		picture_coding_type = PCT_P;
		break;
	    default:
		picture_coding_type = PCT_B ;
		break;
	    }
	    if (b_user_data) 
	    {
	    	if( bUserData )
		    fprintf( stdout, 
			"[UserData] picture_coding_type = 0x%08X\n", 
			(UINT)picture_coding_type );
		b_user_data = 0;
	    }
	}

	if( nEditFrameMbs>=0 )
	{
	    if( avc_frame_mbs_only_flag==0 )
	    {
		if( nEditFrameMbs==1 )	// 0->1
		{	// delete field_pic_flag
		    SpecialStartAddr = BitAddr;
		    SpecialStartBits = BitOffset;
		    bEdit = EDIT_CUT;
		}
	    } else {
		if( nEditFrameMbs==0 )	// 1->0
		{	// add field_pic_flag
		    SpecialStartAddr = BitAddr;
		    SpecialStartBits = BitOffset;
		    SpecialEndBits   = BitOffset+1;
		    bEdit = EDIT_INS;
		}
	    }
	}
	if( avc_frame_mbs_only_flag==0 )
	{
	    field_pic_flag = GetBitStream( fp, 1 );
	    if( bShowDetail )
	    fprintf( stdout, "field_pic_flag = %d\n", field_pic_flag );
	    if( field_pic_flag )
	    {
		int bottom_field_flag = GetBitStream( fp, 1 );
		if( bShowDetail )
		    fprintf( stdout, "bottom_field_flag = %d\n", 
			bottom_field_flag );
	    }
	} 
	if( nEditFrameMbs>=0 )
	{
	    if( avc_frame_mbs_only_flag==0 )
	    {
		if( nEditFrameMbs==1 )	// 0->1
		{	// delete field_pic_flag
		    SpecialEndBits   = BitOffset;
		}
	    } else {
		if( nEditFrameMbs==0 )	// 1->0
		{	// add field_pic_flag
		}
	    }
	}

	if( bEdit )
	{
	    int SpecialTermAddr=BitAddr;
	    int SpecialTermBits=BitOffset;
	    fprintf( stdout, "Special%d (%X,%d) (%X,%d) (%X,%d)\n",
	    	bEditSPS,
	    	SpecialStartAddr, SpecialStartBits,
	    	SpecialEndAddr, SpecialEndBits,
	    	SpecialTermAddr, SpecialTermBits );
	    g_update_addrS[g_update_countS] = BitAddr;
	    g_update_bit_S[g_update_countS] = SpecialStartBits;
	    g_update_bit_E[g_update_countS] = SpecialEndBits;
	    g_update_bit_T[g_update_countS] = SpecialTermBits;
	    g_update_mode [g_update_countS] = bEdit;
	    g_update_countS++;
	}

	int pic_order_cnt_lsb   = (-1);
	int delta_pic_order_cnt = (-1);
	if( bParsePOC )
	{
	    if( avc_IdrPicFlag )
	    {
		int idr_pic_id = GetBitStreamGolomb( fp );
		if( bShowDetail )
		fprintf( stdout, "idr_pic_id = %d\n", idr_pic_id );
	    }
	    if( avc_pic_order_cnt_type==0 )
	    {
		int pic_order_cnt_lsb_bits=
			avc_log2_max_pic_order_cnt_lsb_minus4+4;
		pic_order_cnt_lsb = GetBitStream( fp, pic_order_cnt_lsb_bits );
		if( bShowDetail )
		{
		    fprintf( stdout, "pic_order_cnt_lsb=%d(%dbits)\n", 
			    pic_order_cnt_lsb, pic_order_cnt_lsb_bits );
		}
		if( avc_bottom_field_pic_order_in_frame_present_flag 
		 && (field_pic_flag==0) )
		{
		    int delta_pic_order_cnt_bottom = GetBitStreamGolomb( fp );
		    if( bShowDetail )
		    {
			fprintf( stdout, "delta_pic_order_cnt_bottom = %d\n", 
			    delta_pic_order_cnt_bottom );
		    }
		}
	    } else if( (avc_pic_order_cnt_type==1)
		    && (avc_delta_pic_order_always_zero_flag==0))
	    {
		delta_pic_order_cnt = GetBitStreamGolomb( fp );
		if( bShowDetail )
		{
		    fprintf( stdout, "delta_pic_order_cnt[0]=%d\n", 
			    delta_pic_order_cnt );
		}
		if( avc_bottom_field_pic_order_in_frame_present_flag 
		 && (field_pic_flag==0) )
		{
		    delta_pic_order_cnt = GetBitStreamGolomb( fp );
		    if( bShowDetail )
		    {
			fprintf( stdout, "delta_pic_order_cnt[1]=%d\n", 
				delta_pic_order_cnt );
		    }
		}
	    }
	}
	if( bParseSlice )
	{
	    fprintf( stdout, "picture_coding_type=%d\n",
		    picture_coding_type );
	    if( avc_redundant_pic_cnt_present_flag )
	    {
		int redundant_pic_cnt = GetBitStreamGolomb( fp );
		if( bShowDetail )
		{
		    fprintf( stdout, "redundant_pic_cnt=%d\n",
			    redundant_pic_cnt );
		}
	    }
	    if( picture_coding_type==PCT_B )
	    {
		int direct_spatial_mv_pred_flag = GetBitStream( fp, 1 );
		if( bShowDetail )
		{
		    fprintf( stdout, "direct_spatial_mv_pred_flag=%d\n",
			    direct_spatial_mv_pred_flag );
		}
	    }
	    if( (picture_coding_type==PCT_P)
	     || (picture_coding_type==PCT_B) )
	    {
		int num_ref_idx_active_override_flag = GetBitStream( fp, 1 );
		if( num_ref_idx_active_override_flag )
		{
		    int num_ref_idx_active_minus1 = GetBitStreamGolomb( fp );
		    if( bShowDetail )
		    {
			fprintf( stdout, "num_ref_idx_active_minus1=%d\n",
			    num_ref_idx_active_minus1 );
		    }
		    if( picture_coding_type==PCT_B )
		    {
			int num_ref_idx_ll_active_minus1 = 
				GetBitStreamGolomb( fp );
			if( bShowDetail )
			{
			    fprintf( stdout, 
			    	"num_ref_idx_ll_active_minus1=%d\n",
				num_ref_idx_ll_active_minus1 );
			}
		    }
		}
	    }
	    if( nal_unit_type==20 )
	    {
    //	    ref_pic_list_mvc_modification();
	    } else {
    //	    ref_pic_list_modification();
    fprintf( stdout, "ref_pic_list_modification()\n" );
    fprintf( stdout, "slice_type=%d\n", slice_type );
		if( ((slice_type%5)!=2) && ((slice_type%5)!=4) )
		{	// !PCT_I (PCT_P or PCT_B)
		    int ref_pic_list_modification_flag_l0 = 
		    	GetBitStream( fp, 1 );
		    if( bShowDetail )
		    {
			fprintf( stdout, 
			    "ref_pic_list_modification_flag_l0=%d\n",
			    ref_pic_list_modification_flag_l0 );
		    }
		    if( ref_pic_list_modification_flag_l0 )
		    {
		    	int nCount=0;
			int modification_of_pic_nums_idc = 0;
			while( modification_of_pic_nums_idc !=3 )
			{
			    modification_of_pic_nums_idc = 
				    GetBitStreamGolomb( fp );
			    if( bShowDetail )
			    {
				fprintf( stdout, 
				    "%d : modification_of_pic_nums_idc=%d\n",
				    nCount++, modification_of_pic_nums_idc );
			    }
			    if( (modification_of_pic_nums_idc==0)
			     || (modification_of_pic_nums_idc==1) )
			    {
				int abs_diff_pic_num_minus1 = 
				    GetBitStreamGolomb( fp );
				if( bShowDetail )
				{
				    fprintf( stdout, 
					"abs_diff_pic_num_minus1=%d\n",
					    abs_diff_pic_num_minus1 );
				}
			    } else if( modification_of_pic_nums_idc==2 )
			    {
				int long_term_pic_num = 
					GetBitStreamGolomb( fp );
				if( bShowDetail )
				{
				    fprintf( stdout, "long_term_pic_num=%d\n",
					    long_term_pic_num );
				}
			    }
			}
		    }
		}
		if( (slice_type%5)==1 )
		{	// PCT_B
		    int ref_pic_list_modification_flag_l1 = 
		    	GetBitStream( fp, 1 );
		    if( bShowDetail )
		    {
			fprintf( stdout, 
			    "ref_pic_list_modification_flag_l1=%d\n",
			    ref_pic_list_modification_flag_l1 );
		    }
		    if( ref_pic_list_modification_flag_l1 )
		    {
			int modification_of_pic_nums_idc = 0;
		    	int nCount=0;
			while( modification_of_pic_nums_idc !=3 )
			{
			    modification_of_pic_nums_idc = 
				    GetBitStreamGolomb( fp );
			    if( bShowDetail )
			    {
				fprintf( stdout, 
				    "%d : modification_of_pic_nums_idc=%d\n",
				    nCount, modification_of_pic_nums_idc );
			    }
			    if( (modification_of_pic_nums_idc==0)
			     || (modification_of_pic_nums_idc==1) )
			    {
				int abs_diff_pic_num_minus1 = 
				    GetBitStreamGolomb( fp );
				if( bShowDetail )
				{
				    fprintf( stdout, 
				    	"abs_diff_pic_num_minus1=%d\n",
					    abs_diff_pic_num_minus1 );
				}
			    } else if( modification_of_pic_nums_idc==2 )
			    {
				int long_term_pic_num = GetBitStreamGolomb( fp );
				if( bShowDetail )
				{
				    fprintf( stdout, "long_term_pic_num=%d\n",
					    long_term_pic_num );
				}
			    }
			}
		    }
		}
	    }
	}

/*
int mvc_non_idr_flag     = (-1);
int mvc_priority_id      = (-1);
int mvc_view_id          = (-1);
int mvc_temporal_id      = (-1);
int mvc_anchor_pic_flag  = (-1);
int mvc_inter_view_flag  = (-1);
*/
	if( mvc_extension )
	{
	    fprintf( stdout, 
	    	"MVC:SliceHeader(type=%d,pct=%d,anchor=%d,view=%d)\n", 
		slice_type, picture_coding_type, 
		mvc_anchor_pic_flag, mvc_view_id );
	    mvc_anchor_pic_flag = (-1);
	    mvc_extension = 0;
	} else {
	    if( pic_order_cnt_lsb>=0 )
	    {
		fprintf( stdout, 
		    "SliceHeader(type=%d,pct=%d,poc_lsb=%3d,%dbits)\n", 
		    slice_type, picture_coding_type, 
		    pic_order_cnt_lsb,
		    avc_log2_max_pic_order_cnt_lsb_minus4+4 );
	    } else if( delta_pic_order_cnt>=0 )
	    {
		fprintf( stdout, 
		    "SliceHeader(type=%d,pct=%d,deltapoc=%3d,%dbits)\n", 
		    slice_type, picture_coding_type, 
		    delta_pic_order_cnt,
		    avc_log2_max_pic_order_cnt_lsb_minus4+4 );
	    }
	}

	bDebugGolB = tmp;
	return 0;
}

int Counts[256];

int CountNAL( int addrS, int bitsS, int addrE, int bitsE, int code )
{
	addrS -= 4;
	if( bShowNALinfo )
	fprintf( stdout, "CountNAL(0x%X,%d-0x%X,%d, Code(%d))\n", 
		addrS, bitsS, addrE, bitsE, code );
	int addr_diff = addrE-addrS;
	int bits_diff = bitsE-bitsS;
//	int size = (7+addr_diff+bits_diff)/8;
	int size = addr_diff+(7+bits_diff)/8;	// 2012.9.28
	if( bShowNALinfo )
	fprintf( stdout, "Code(%02X) : %X:%d(%X:%d) - %X:%d(%X:%d) (0x%X)\n", 
		code, 
		addrS, bitsS, (addrS+bitsS/8), bitsS%8,
		addrE, bitsE, (addrE+bitsE/8), bitsE%8,
		size );
	Counts[code] += size;
	return size;
}

int ShowSliceSize( UINT Ug_addr, int es_addr, UINT PTSH, UINT PTSL )
{
	if( PTSH==0xFFFFFFFF )
	{
	    fprintf( stdout, 
		"Slice size=%6d (%8X,%8X) PTS=-:--------\n", 
		g_addr-es_addr-4-4, es_addr+4, g_addr-4 );
	} else {
	    int hour, min, sec, msec;
	    TcTime32( PTSH, PTSL, &hour, &min, &sec, &msec );
	    fprintf( stdout, 
		"Slice size=%6d (%8X,%8X) PTS=%1X:%08X (%2d:%02d:%02d.%03d)\n", 
		g_addr-es_addr-4-4, es_addr+4, g_addr-4,
		PTSH, PTSL, hour, min, sec, msec );
	}
	return 0;
}

int AnalyzeAVC( FILE *fp, FILE *pts_fp )
{
int eof=0;
unsigned char buffer[BUF_SIZE];
unsigned int ID;
int readed=0;
int readP=0, size;
int i, ret=0;
int addrS=(-1);
int addrE=(-1);
int bitsS=(-1);
int bitsE=(-1);
int bFirst=1;
unsigned int PTSH=0xFFFFFFFF, PTSL=0xFFFFFFFF, DTSH=0xFFFFFFFF, DTSL=0xFFFFFFFF;

	if( Packets==NULL )
	{
	    fprintf( stdout, "Packets=NULL\n" );
	    return -1;
	}
	for( i=0; i<256; i++ )
	{
	    Counts[i] = 0;
	}
	while( eof==0 )
	{
	    if( readP<4 )
	    {
	    	size = 4-readP;
//		fprintf( stdout, "gread@%d, %d\n", readP, size );
		readed = gread( &buffer[readP], 1, size, fp );
		if( readed<size )
		{
		    CannotRead( "Prefix" );
		    break;
		}
		readP+=size;
	    }
	    if( (buffer[0]==0x00)
	     && (buffer[1]==0x00)
	     && (buffer[2]==0x00) )
	    {
	    	memcpy( &buffer[0], &buffer[1], 3 );
		readed = gread( &buffer[3], 1, 1, fp );
		if( readed<1 )
		{
		    CannotRead( "Prefix" );
		    break;
		}
		continue;
	    }

	    if( (buffer[0]!=0x00)
	     || (buffer[1]!=0x00)
	     || (buffer[2]!=0x01) )
	    {
	    	if( bFirst )
		{
		    if( skipContent( fp, buffer, 0 )==1 )
		    {
			readP=4;
		    } else {
		    	eof=1;
		    }
		} else {
		    fprintf( stdout, 
		"AnalyzeAVC : Invalid Prefix %02X %02X %02X : @(%s)\n",
			buffer[0], buffer[1], buffer[2], AddrStr(g_addr-4) );
		    if( (buffer[1]==0) && (buffer[2]==0) )
		    {
			memcpy( &buffer[0], &buffer[1], 3 );
			readed = gread( &buffer[3], 1, 1, fp );
			continue;
		    }
		    if( bSkipError )
		    {
		    	fprintf( stdout, "SkipError\n" );
		    	// Skip to next start code
			if( skipContent( fp, buffer, 0 )==1 )
			{
			    readP=4;
			} else {
			    eof=1;
			}
		    } else {
			EXIT();
		    }
		}
	    } else {
		bFirst=0;
		ID = buffer[3];
		int forbidden_zero_bit = (ID>>7) &    1;
		int nal_ref_idc        = (ID>>5) &    3;
		int nal_unit_type      = (ID>>0) & 0x1F;
		readP=0;
		{
//		    if( bDump )
			fprintf( stdout, "%02X %02X %02X %02X : ",
			    buffer[0], buffer[1], buffer[2], buffer[3] );
		    Packets[ID]++;
		    InitBitStream( );
		    addrS = BitAddr;
		    bitsS = BitOffset;
		    // ID : nal_unit_typ = 0..31
		    if( (ID>=0xE0) && (ID<=0xEF) )	// Video
		    {
			// use gread() only
			unsigned int pes_addr = g_addr-4;
			if( bShowDetail )
			fprintf( stdout, 
	"---------------------------------------------------------\n" );
			PES_header( fp, buffer, bDisplayTS,
				&PTSH, &PTSL, &DTSH, &DTSL );
			if( PTSH==0xFFFFFFFF )
			{
			    fprintf( stdout, "ID=%02X : PES_header(%s)\n", 
				ID, AddrStr2(pes_addr) );
			} else {
			    int hour, min, sec, msec;
			    TcTime32( PTSH, PTSL, &hour, &min, &sec, &msec );
			    if( DTSH!=0xFFFFFFFF )
			    {
			    int hour2, min2, sec2, msec2;
			    TcTime32( DTSH, DTSL, &hour2, &min2, &sec2, &msec2);
			    fprintf( stdout, 
    "ID=%02X : PES_header(%s) PTS=%2d:%02d:%02d.%03d,DTS=%2d:%02d:%02d,%03d\n", 
				ID, AddrStr2(pes_addr), 
				hour, min, sec, msec,
				hour2, min2, sec2, msec2 );
			    } else {
			    fprintf( stdout, 
			"ID=%02X : PES_header(%s) PTS=%2d:%02d:%02d.%03d\n", 
				ID, AddrStr2(pes_addr), hour, min, sec, msec );
			    }
			}
			fprintf( pts_fp, "%8X %8llX : %4X %08X, %4X %08X\n",
				pes_addr, SrcAddr(pes_addr,0),
				(UINT)(PTSH & 0xFFFF), PTSL, 
				(UINT)(DTSH & 0xFFFF), DTSL );
			//
			BitAddr = g_addr;
			bitsE = 0;
			addrE = BitAddr;
			bitsE = BitOffset;
			CountNAL( addrS, bitsS, addrE, bitsE, 0xE0 );
			es_addr = g_addr;	// 2012.9.3
		    } else if( forbidden_zero_bit==0 )
		    {
			switch( nal_unit_type )
			{
		    // 1 :
			case 0x01 :
			    fprintf( stdout, 
				"ID=%02X : Slice (non-IDR picture) (%s)\n", 
//				ID, AddrStr(g_addr) );
				ID, AddrStr2(g_addr) );
			    Slice_header( fp, buffer, 1, nal_ref_idc );
	#if 1
			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
	#else
			    addrE = BitAddr;
			    bitsE = BitOffset;
	#endif
			    CountNAL( addrS, bitsS, addrE, bitsE, 0x1 );
			    ShowSliceSize( g_addr, es_addr, PTSH, PTSL );
			    break;
		    // 5 : IDR picutre slice
			case 0x05 :	// 2012.2.9
			    fprintf( stdout, 
				"ID=%02X : Slice (IDR picture) (%s)\n", 
//				ID, AddrStr(g_addr) );
				ID, AddrStr2(g_addr) );
			    Slice_header( fp, buffer, 5, nal_ref_idc );

			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
			    CountNAL( addrS, bitsS, addrE, bitsE, 0x5 );
			    ShowSliceSize( g_addr, es_addr, PTSH, PTSL );
			    break;
		    // 6 : SEI
			case 6 :
			    fprintf( stdout, "ID=%02X : SEI(%s)\n", 
//				    ID, AddrStr(g_addr) );
				    ID, AddrStr2(g_addr) );
			    ret = SupplementalEnhancementInformation( fp, 
			    	buffer );
			    if( ret>0 )
				readP = ret;
//			    fprintf( stdout, "ret=%d, readP=%d\n", ret, readP );
			    addrE = BitAddr;
			    bitsE = BitOffset;
			    CountNAL( addrS, bitsS, addrE, bitsE, 0x06 );
//			    fprintf( stdout, "g_addr=%X\n", g_addr );
			    break;
		    // 7 : SPS
			case 0x07 :	// 2012.2.9
			case 0x27 :	// 2010.12.9
			case 0x67 :
			    fprintf( stdout, 
				"ID=%02X : Sequence parameter set(%s) (%s)\n", 
				ID, AddrStr(g_addr), DtsTimeStr() );
			    ret = SequenceParameterSet( fp, buffer );
			    if( ret==1 )
				readP=4;
			    else if( ret<0 )
				eof=1;
			    addrE = BitAddr;
			    bitsE = BitOffset;
			    CountNAL( addrS, bitsS, addrE, bitsE, 0x7 );
			    break;
		    // 8 : PPS
			case 0x08 :	// 2012.2.9
			    fprintf( stdout, 
				"ID=%02X : Picture parameter set:PPS(%s)\n", 
				ID, AddrStr(g_addr) );
	#if 0
			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
	#else
			    ret = PictureParameterSet( fp, buffer );
			    if( ret==1 )
				readP=4;
			    else if( ret<0 )
				eof=1;
			    addrE = BitAddr;
			    bitsE = BitOffset;
	#endif
			    CountNAL( addrS, bitsS, addrE, bitsE, 0x8 );
			    break;
		    // 9 : AU delimiter
			case 9 :
			    fprintf( stdout, "ID=%02X : AUD(%s)\n", 
//					ID, AddrStr(g_addr) );
					ID, AddrStr2(g_addr) );
			    ret = AccessUnitDelimiter( fp, buffer );
			    if( ret<0 )
				eof=1;
			    else if( ret>0 )
				readP = ret;
			    addrE = BitAddr;
			    bitsE = BitOffset;
			    CountNAL( addrS, bitsS, addrE, bitsE, 0x09 );
			    break;
		    // 10 : End of Sequence
			case 10 :
			    fprintf( stdout, 
				"ID=%02X : End of sequence (%s)\n", 
				ID, AddrStr(g_addr) );
	#if 1
			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
	#else
			    addrE = BitAddr;
			    bitsE = BitOffset;
	#endif
			    size = CountNAL( addrS, bitsS, addrE, bitsE, 0xA );
			    break;
		    // 11 : End of stream
			case 11 :	// 2012/5/7 for intel encoder
			    fprintf( stdout, 
				"ID=%02X : End of stream (%s)\n", 
				ID, AddrStr(g_addr) );
	#if 1
			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
	#else
			    addrE = BitAddr;
			    bitsE = BitOffset;
	#endif
			    size = CountNAL( addrS, bitsS, addrE, bitsE, 0xA );
			    break;
		    // 12 : Filler data
			case 0x0C :
			    fprintf( stdout, "ID=%02X : FillerData(%s)\n", 
//				ID, AddrStr(g_addr) );
				ID, AddrStr2(g_addr) );
			    ret = FillerData( fp, buffer );
			    if( ret<0 )
				eof=1;
			    else if( ret>0 )
				readP = ret;
			    addrE = BitAddr;
			    bitsE = BitOffset;
			    size = CountNAL( addrS, bitsS, addrE, bitsE, 0xC );
			    if( bShowDetail )
			    fprintf( stdout, "Filler size=%d\n", size );
			    break;
		    // 14 : Prefix NAL unit
			case 0x0E :
			    fprintf( stdout, "ID=%02X : Prefix NAL unit(%s)\n", 
				ID, AddrStr(g_addr) );
			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
			    break;
		    // 15
			case 0x0F :	// Subset sequence parameter set
			    fprintf( stdout, 
			"ID=%02X : Subset sequence parameter set (%s)\n", 
				ID, AddrStr(g_addr) );
			    ret = SequenceParameterSet( fp, buffer );
			    if( ret<0 )
				eof=1;
			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
			    break;
		    // 20 : Coded slice extension
			case 0x14 :
			    fprintf( stdout, 
				"ID=%02X : Coded slice extension (%s)\n", 
				ID, AddrStr(g_addr) );
			    {
				int svc_extension_flag = GetBitStream( fp, 1 );
				if( bShowMvcExtention )
				fprintf( stdout, "svc_extension_flag=%d\n",
					svc_extension_flag );
				if( svc_extension_flag )
				{
				    nal_unit_header_svc_extension( fp, buffer );
				} else {
				    nal_unit_header_mvc_extension( fp, buffer );
				}
			    }
			    Slice_header( fp, buffer, 20, nal_ref_idc );

			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
			    {
			    int bShow = bShowNALinfo;
    //			bShowNALinfo = 1;
			    size = CountNAL( addrS, bitsS, addrE, bitsE, 0xA );
			    bShowNALinfo = bShow;
			    }
			    ShowSliceSize( g_addr, es_addr, PTSH, PTSL );
			    break;
		    // 24
			case 0x18 :
			    fprintf( stdout, 
				"ID=%02X : VDRD NAL unit (%s)\n", 
				ID, AddrStr(g_addr) );
			    if( skipContent( fp, buffer, 0 )==1 )
			    {
				readP=4;
			    } else {
				eof=1;
			    }
			    addrE = g_addr;
			    bitsE = 0;
			    break;
			default :
			    fprintf( stdout, 
			    "ID=%02X : Not implemented in AnaylzeAVC (%s)\n", 
				ID, AddrStr(g_addr) );
			    if( bSkipError==0 )
			    {
				EXIT();
			    } else {
				fprintf( stdout, "=========================\n");
				fprintf( stdout, "SkipError\n" );
				if( skipContent( fp, buffer, 0 )==1 )
				{
				    readP=4;
				} else {
				    eof=1;
				}
			    }
			    break;
			}
		    } else {
		    	fprintf( stdout, "forbidden_zero_bit!=0\n" );
			    if( bSkipError==0 )
			    {
				EXIT();
			    } else {
				fprintf( stdout, "=========================\n");
				fprintf( stdout, "SkipError\n" );
				if( skipContent( fp, buffer, 0 )==1 )
				{
				    readP=4;
				} else {
				    eof=1;
				}
			    }
		    }
		}
	    }
	}
	fprintf( stdout, "eof=%d\n", eof );
	ShowUpdate( );
	for( i=0; i<256; i++ )
	{
	    if( Counts[i]>0 )
		fprintf( stdout, "Code[%02X] = 0x%X\n", i, Counts[i] );
	}
	return 0;
}
#endif



void TS_addr_Dump( long *TS_addr, int nTS )
{
int n;
    fprintf( stdout, "TS_addr\n" );
	for( n=0; n<nTS; n++ )
	{
	    fprintf( stdout, "TS(%5d) : %8X\n", n, (UINT)TS_addr[n] );
	}
}

int Remux( char *srcFilename, char *outFilename, 
	char *textFilename, FILE *pts_fp, int Threshold )
{
int index;

FILE *ts_fp = fopen( "ts.bin", "wb" );

#define MAX_PCR 1024*1024*1
long long *PCR_addr;
long long *PCR_data;
int nPCR=0;
#define MAX_DTS 1024*1024*1
long long *DTS_addr;
long long *DTS_data;
int nDTS=0;
// 16M*188=3G max
#define MAX_TS 1024*1024*16
unsigned long long *TS_addr = NULL;
int nTS=0;

#define MAX_DATA 1024*1024*8
unsigned long long *DATA_addr = NULL;
long long *DATA_pts  = NULL;
int nDATA=0;
#define MAX_NULL 1024*1024*8
unsigned long long *NULL_addr = NULL;
int nNULL=0;

int n;

	fprintf( stdout, "Remux(%s->%s)\n", srcFilename, outFilename );
	fprintf( stdout, "Threshold=%d(%d)\n", Threshold, Threshold/90000 );

	PCR_addr = (long long *)malloc( MAX_PCR*8 );
	if( PCR_addr==NULL )
	{
	    fprintf( stdout, "Can't alloc PCR_addr\n" );
	    exit( 1 );
	}
	PCR_data = (long long *)malloc( MAX_PCR*8 );
	if( PCR_data==NULL )
	{
	    fprintf( stdout, "Can't alloc PCR_data\n" );
	    exit( 1 );
	}
	DTS_addr = (long long *)malloc( MAX_DTS*8 );
	if( DTS_addr==NULL )
	{
	    fprintf( stdout, "Can't alloc DTS_addr\n" );
	    exit( 1 );
	}
	DTS_data = (long long *)malloc( MAX_DTS*8 );
	if( DTS_data==NULL )
	{
	    fprintf( stdout, "Can't alloc DTS_data\n" );
	    exit( 1 );
	}
	TS_addr = (unsigned long long *)malloc( MAX_TS*8 );
	if( TS_addr==NULL )
	{
	    fprintf( stdout, "Can't alloc TS_addr\n" );
	    exit( 1 );
	}
	DATA_addr = (unsigned long long *)malloc( MAX_DATA*8 );
	if( DATA_addr==NULL )
	{
	    fprintf( stdout, "Can't alloc DATA_addr\n" );
	    exit( 1 );
	}
	DATA_pts  = (long long *)malloc( MAX_DATA*8 );
	if( DATA_pts==NULL )
	{
	    fprintf( stdout, "Can't alloc DATA_pts\n" );
	    exit( 1 );
	}
	NULL_addr = (unsigned long long *)malloc( MAX_NULL*8 );
	if( NULL_addr==NULL )
	{
	    fprintf( stdout, "Can't alloc NULL_addr\n" );
	    exit( 1 );
	}

	fprintf( stdout, "Copy to ts.bin with erasing ts file\n" );
	if( ts_fp==NULL )
	{
	    fprintf( stdout, "Can't open ts.bin\n" );
	    exit( 1 );
	}
	FILE *src_fp = fopen( srcFilename, "rb" );
	if( src_fp==NULL )
	{
	    fprintf( stdout, 
		"Remux(srcFilename) Can't open %s\n", srcFilename );
	    exit( 1 );
	}
	FILE *outfile = fopen( outFilename, "wb" );
	if( outfile==NULL )
	{
	    fprintf( stdout, "Remux(outfile) Can't open %s\n", outFilename );
	    exit( 1 );
	}
	int total = 0;
#define TS_BUF_SIZE 188*1024
	unsigned char TsBuffer[TS_BUF_SIZE];
	unsigned char NullBuffer[192];
	int size, readed, written=0;

	// Extract ts
	memset( NullBuffer, 0xFF, 192 );
	NullBuffer[0] = 0x47;
	NullBuffer[1] = 0x1F;
	NullBuffer[2] = 0xFF;
	NullBuffer[3] = 0x1F;
	int validText=1;
	if( ReadAddrFile( textFilename, 
		srcFilename, DATA_addr, NULL, &nDATA, MAX_DATA )<0 )
	{
	    validText=0;
//	    exit( 1 );
	}
// -------------------------------------------------------------------
// Copy XX.ts to ts.bin and overwrite with null packet
// -------------------------------------------------------------------
	if( validText )
	{
	    for( index=0; index<nDATA; index++ )
	    {
		int ts_addr = DATA_addr[index];
		if( ts_addr>total )
		{
    //		fprintf( stdout, "Copy(%X:%X)\n", ts_addr-total, total );
		    while( total<ts_addr )
		    {
			int size = ts_addr-total;
			if( size>TS_BUF_SIZE )
			    size = TS_BUF_SIZE;
			readed = fread( TsBuffer, 1, size, src_fp );
			if( readed<size )
			{
			    fprintf( stdout, "readed=%d/%d@0x%X\n", 
				readed, size, total );
			    exit( 1 );
			}
			int rest = size;
			while( rest>0 )
			{
			    written = fwrite( TsBuffer, 1, rest, outfile );
			    if( written<1 )
			    {
				fprintf( stdout, "TsBuffer:written=%d/%d@0x%X\n", 
				    written, rest, total );
				exit( 1 );
			    }
			    rest -= written;
			}
			total += readed;
		    }
		}
		size = 188;
    //	    fprintf( stdout, "Write(%X:%X)\n", size, total );
		readed = fread( TsBuffer, 1, size, src_fp );
		if( readed<size )
		{
		    fprintf( stdout, "readed=%d/%d@0x%X\n", 
			readed, size, total );
		    exit( 1 );
		}
		written = fwrite( TsBuffer, 1, size, ts_fp );
		if( written<size )
		{
		    fprintf( stdout, "TsBuffer:written=%d/%d@0x%X\n", 
			written, size, total );
		    exit( 1 );
		}
		written = fwrite( NullBuffer, 1, size, outfile );
		if( written<size )
		{
		    fprintf( stdout, "NullBuffer:written=%d/%d@0x%X\n", 
			written, size, total );
		    exit( 1 );
		}
		total += readed;
	    }
	    // Rest
	    {
		size = TS_BUF_SIZE;
		while( written>0 )
		{
		    readed = fread( TsBuffer, 1, size, src_fp );
		    written = fwrite( TsBuffer, 1, readed, outfile );
		}
	    }
	} else {
	    while( 1 )
	    {
	    	int size=1024*4;
		int readed;
		readed  = fread ( TsBuffer, 1, size, src_fp );
		if( readed<1 )
		    break;
		written = fwrite( TsBuffer, 1, readed, outfile );
	    }
	}
	fclose( src_fp );
	fclose( outfile );
	fclose( ts_fp );

	fprintf( stdout, "Copy done\n" );

	fprintf( stdout, "nTS=%d\n", nTS );

#if 0
	TS_addr_Dump( TS_addr, nTS );
#endif
// ----------------------------------------------------------
//  Read PTS file
// ----------------------------------------------------------
	// DTS
	fprintf( stdout, "Read pts file\n" );
	while( 1 )
	{
	    if( fgets( (char *)TsBuffer, 1024, pts_fp )==NULL )
	    {
	    	fprintf( stdout, "EOF\n" );
		break;
	    }
	    int addr1, ptsAddr;
	    int ptsH, ptsL;
	    int dtsH, dtsL;
	    sscanf( (char *)TsBuffer, "%X %X : %X %X, %X %X",
	    	&addr1, &ptsAddr, &ptsH, &ptsL, &dtsH, &dtsL );
	    DTS_addr[nDTS] = ptsAddr;
//	    DTS_data[nDTS] = ptsL;
	    int DTS = dtsL;
	    if( DTS==0xFFFFFFFF )
	    	DTS = ptsL;
	    DTS_data[nDTS] = DTS;	 // use DTS
	    nDTS++;
	    if( nDTS>=MAX_DTS )
	    {
	    	fprintf( stdout, "Too many DTS (%d)\n", nDTS );
		exit( 1 );
	    }
//	    fprintf( stdout, "%8X : %8X\n", addr2, ptsL );
	}
	fprintf( stdout, "Read done (%d DTS)\n", nDTS );

// ----------------------------------------------------------
//  Read PCR file
// ----------------------------------------------------------
	fprintf( stdout, "Read PCR file\n" );
	FILE *pcr_fp = fopen( "PCR.txt", "r" );
	if( pcr_fp==NULL )
	{
	    fprintf( stdout, "Can't open PCR.txt\n" );
	    exit( 1 );
	}
	while( 1 )
	{
	    if( fgets( (char *)TsBuffer, 1024, pcr_fp )==NULL )
	    {
	    	fprintf( stdout, "EOF\n" );
		break;
	    }
	    int addr, pid, pcrH, pcrL;
	    unsigned long long PCR;
	    sscanf( (char *)TsBuffer, "%X : %X : %X,%X %llX",
	    	&addr, &pid, &pcrH, &pcrL, &PCR );
	    PCR_addr[nPCR] = addr;
	    PCR_data[nPCR] = PCR;
	    nPCR++;
	    if( nPCR>=MAX_PCR )
	    {
	    	fprintf( stdout, "Too many PCR (%d)\n", nPCR );
		exit( 1 );
	    }
//	    fprintf( stdout, "%8X : %9llX\n", addr, PCR );
	}
	fclose( pcr_fp );
	fprintf( stdout, "Read done (%d PCR)\n", nPCR );

	// NULL(PID=0x1FFF) data
	if( ReadAddrFile( "PES-1FFF.txt", 
		srcFilename, NULL_addr, NULL, &nNULL, 
		MAX_NULL )<0 )
	    exit( 1 );
#if 0
	TS_addr_Dump( TS_addr, nTS );
#endif
	int nD=0, nN=0;
	long long DataAddr, NullAddr;
	for( n=0; ; n++ )
	{
	    if( (nD>=nDATA) && (nN>=nNULL) )
	    	break;
	    if( nD<nDATA )
	    	DataAddr = DATA_addr[nD];
	    else
	    	DataAddr = 0xFFFFFFFFFFll;
	    if( nN<nNULL )
	    	NullAddr = NULL_addr[nN];
	    else
	    	NullAddr = 0xFFFFFFFFFFll;
	    if( DataAddr<NullAddr )
	    {
	    	TS_addr[nTS] = DataAddr;
		nD++;
	    } else if( DataAddr>NullAddr )
	    {
	    	TS_addr[nTS] = NullAddr;
		nN++;
	    } else
	    	break;
//	    fprintf( stdout, "%5d : %8X\n", nTS, TS_addr[nTS] );
	    nTS++;
	}
#if 0
	TS_addr_Dump( TS_addr, nTS );
#endif
// ----------------------------------------------------------
//  Write new TS file
// ----------------------------------------------------------
	fprintf( stdout, "Update\n" );
	// Make TS_addr and PCR
	int nPcr=0;
//	unsigned long long PCR = PCR_data[0];
	long long PCR = PCR_data[0];
	n=0;
	int pk, pt=0;
	int nFree=0;
	long long DTS = DTS_data[0];
	int fd;
	int mapSize = 4096*2;
	ts_fp = fopen( "ts.bin", "rb" );
	if( ts_fp==NULL )
	{
	    fprintf( stdout, "Can't open ts.bin\n" );
	    exit( 1 );
	}
	fd = open( outFilename, O_RDWR );
	if( fd==(-1) )
	{
	    fprintf( stdout, 
	    "Remux(outFilename) Can't open %s\n", outFilename );
	    exit( 1 );
	}
	unsigned int WrAddr = 0;
	int nCont=0;
	int L_Free=(-2);
	for( pk=0; pk<nDATA; pk++ )
	{
	    if( bDebugRemux )
		fprintf( stdout, "DATA(%6d): %8llX : ", pk, DATA_addr[pk] );
	    while( (DTS_addr[pt]-0x20)<DATA_addr[pk] )
	    {
		pt++;
		if( pt>=nDTS )
		    break;
		DTS = DTS_data[pt];
//		fprintf( stdout, "%8X %9llX\n", DTS_addr[pt], DTS );
	    }
	    unsigned long nAddr = DTS_addr[pt+1]; 
	    int FrameSize = nAddr-DTS_addr[pt];
	    if( FrameSize<0 )
	    	FrameSize = 0;
	    int deltaPCR = FrameSize * (PCR_data[10]-PCR_data[0])
	                             / (PCR_addr[10]-PCR_addr[0]);
	    fprintf( stdout, "DTS=%9llX (%llX) (%8X,%6d)\n",
	    	DTS, DTS-Threshold, FrameSize, deltaPCR );
	    // Search free ts area
	    int bNoSpace=0;
	    while( 1 )
	    {
		if( nFree>=nTS )
		{
		    fprintf( stdout, "No more free area (%d)\n", nFree );
		    bNoSpace=1;
		    break;
		}
//		fprintf( stdout, "%6d : %10d : ", nFree, TS_addr[nFree] );
		while( PCR_addr[nPcr]<TS_addr[nFree] )
		{
#if 0
		    fprintf( stdout, 
			"nPcr=%5d, PCR_addr=%8X, TS_addr=%8X\n",
				nPcr, PCR_addr[nPcr], TS_addr[nFree] );
#endif
		    nPcr++;
		    if( nPcr>=nPCR )
			break;
		    PCR = PCR_data[nPcr];
		}
#if 0
	    	fprintf( stdout, "nFree=%d, nPcr=%5d, nPCR=%5d, PCR=%9llX\n", 
			nFree, nPcr, nPCR, PCR );
		fflush( stdout );
#endif
		if( PCR>=(DTS-Threshold-deltaPCR) )
		{
		    if( bDebugRemux )
		    {
			fprintf( stdout, "TS(%6d) : %9llX : ", 
			    nFree, TS_addr[nFree] );
			fprintf( stdout, "PCR=%9llX,DTS=%8X\n", 
				PCR, (UINT)DTS );
		    }
		    if( (nFree-L_Free)==1 )
		    	nCont++;
		    else
		    	nCont=0;
		    L_Free = nFree;
//		    if( nCont>128 )
//		    if( nCont>32 )
		    if( nCont>16 )
		    {
		    	fprintf( stdout, "Insert (nCont=%d)\n", nCont );
		    	nFree++;
		    }
		    WrAddr = TS_addr[nFree];
		    nFree++;
		    break;
		}
		nFree++;
	    }
	    if( bNoSpace )
	    	break;
	    if( bDebugRemux )
		fprintf( stdout, "WrAddr(%8X)\n", WrAddr );
	    {
		unsigned char *data;
	    // mmap
		data = (unsigned char *)mmap( (caddr_t)0, mapSize, 
				    PROT_READ | PROT_WRITE, MAP_SHARED,
				    fd, WrAddr & 0xFFFFF000 );
		if( data==(unsigned char *)-1) 
		{
		    fprintf( stdout, "Can't mmap\n" );
		    exit( 1 );
		}
		int offset = WrAddr & 0xFFF;
		unsigned char *ptr = &data[offset];
#if 0
		fprintf( stdout, "Write(%8X:%8X)\n", 
			WrAddr & 0xFFFFF000,
			offset );
#endif
		readed = fread( ptr, 1, 188, ts_fp );
		if( readed<188 )
		{
			fprintf( stdout, "readed=%d\n", readed );
		}
	    // munmap
		if( munmap( data, mapSize )==(-1) )
		{
		    fprintf( stdout, "Can't munmap\n" );
		    exit( 1 );
		}
	    }
	}
	close( fd );

	// Rest
	int rest=0;
	if( pk<nDATA )
	{
	    FILE *append = fopen( outFilename, "ab" );
	    if( append==NULL )
	    {
	    	fprintf( stdout, "Can't append\n" );
		exit( 1 );
	    }
	    for( ; pk<nDATA; pk++ )
	    {
	    	int written;
		unsigned char restBuf[188];
		readed = fread( restBuf, 1, 188, ts_fp );
		if( readed<188 )
		{
		    fprintf( stdout, "rest=%d\n", rest );
		    break;
		}
		rest+=readed;
		written = fwrite( restBuf, 1, 188, append );
		if( written<188 )
		{
		    fprintf( stdout, "Can't write(%X)\n", rest );
		}
		written = fwrite( NullBuffer, 1, 188, append );
		if( written<188 )
		{
		    fprintf( stdout, "Can't write(%X)\n", rest );
		}
	    }
	    fclose( append );
	}
	fprintf( stdout, "rest=%X\n", rest );
	fclose( ts_fp );
	fprintf( stdout, "done\n" );

	fprintf( stdout, "nFree=%d, nTS=%d\n", nFree, nTS );

	return 0;
}

// -------------------------------------------------------------------------

#define MODE_MPG	0
#define MODE_AVC	1
#define MODE_AVS	2
#define MODE_HEADER	8
#define MODE_REMUX	9

// ---------------------------------------------
// header item
//
/*
#define ID_HSV		 1
#define ID_VSV		 2
#define ID_ARI		 3
#define ID_FRC		 4
#define ID_PALI		 5
#define ID_PS		 6
#define ID_CP		 7
#define ID_TC		 8
#define ID_MXC		 9
#define ID_DHS		10
#define ID_DVS		11
// for AVC
#define ID_SARW		12
#define ID_SARH		13
#define ID_LVL		14
//
#define ID_PANL		15
#define ID_PANR		16
#define ID_PANT		17
#define ID_PANB		18

#define ID_OVSP		19	// present_flag
#define ID_OVSA		20	// appropriate_flag

#define ID_MAX		21
*/
typedef struct HeaderItem {
int id;
char name[10];
} headerItem_t;

static struct HeaderItem headerItem[] = {
{ID_HSV,	"HSV"	},		// horizontal_size_value
{ID_VSV,	"VSV"	},		// vertical_size_value
{ID_ARI,	"ARI"	},		// aspect_ratio_information
{ID_FRC,	"FRC"	},		// frame_rate
{ID_PALI,	"PALI"	},		// profile_and_level_indication
{ID_PS,		"PS"	},		// prograssive_sequence
{ID_CP,		"CP"	},		// colour_primaries
{ID_TC,		"TC"	},		// transfer_characteristics
{ID_MXC,	"MXC"	},		// matrix_coefficients
{ID_DHS,	"DHS"	},		// display_horizontal_size
{ID_DVS,	"DVS"	},		// display_vertical_size

{ID_SARW,	"SARW"	},		// sar_width
{ID_SARH,	"SARH"	},		// sar_height
{ID_LVL,	"LVL"	},		// level

{ID_PANL,	"PANL"	},		// pan_left_offset
{ID_PANR,	"PANR"	},		// pan_right_offset
{ID_PANT,	"PANT"	},		// pan_top_offset
{ID_PANB,	"PANB"	},		// pan_bottom_offset

{ID_OVSP,	"OVSP"	},		// overscan_present_flag
{ID_OVSA,	"OVSA"	},		// overscan_appropriate_flag

{-1,		""	}
};
int bDebugUpdateBits = 0;

int UpdateBits( unsigned char buffer[], int bitOffset, int size, int data )
{
int i;
unsigned int inData, wrData, wrMask, outData;
unsigned int MaskA[32];
unsigned int MaskB[32];
int nByte = (bitOffset+size+7)/8;

	if( bDebugUpdateBits )
	fprintf( stdout, "nByte=%d\n", nByte );
	MaskA[1] = 0x80000000;
	MaskB[1] = 0x00000001;
	for( i=2; i<32; i++ )
	{
	    MaskA[i] = (MaskA[i-1]>>1) | 0x80000000;
	    MaskB[i] = (MaskB[i-1]<<1) | 0x00000001;
	}
	inData = (buffer[0]<<24)
	       | (buffer[1]<<16)
	       | (buffer[2]<< 8)
	       | (buffer[3]<< 0);
	wrData = (data&MaskB[size])<<(32-bitOffset-size);
	wrMask =       MaskA[size] >>bitOffset;
	outData= (inData & (wrMask^0xFFFFFFFF))
		| wrData;
	unsigned int nOutData = outData;
	for( i=0; i<nByte; i++ )
	{
	    buffer[i] = (nOutData>>24)&0xFF;
	    if( bDebugUpdateBits )
	    fprintf( stdout, "%08X %02X\n", nOutData, buffer[i] );
	    nOutData=nOutData<<8;
	}
	if( bShowUpdate )
	{
	    fprintf( stdout, "UpdateBits(%d,%d,%d)\n", bitOffset, size, data );
	    fprintf( stdout, "inData =%8X\n", inData );
	    fprintf( stdout, "wrData =%8X\n", wrData );
	    fprintf( stdout, "wrMask =%8X\n", wrMask );
	    fprintf( stdout, "outData=%8X\n", outData );
	}
	if( bDebugUpdateBits )
	{
	    for( i=0; i<4; i++ )
	    {
		fprintf( stdout, "%02X ", buffer[i] );
	    }
	    fprintf( stdout, "\n" );
	}
	return 0;
}

int ReadByte( unsigned char *ptr, int addr, int bit )
{
	unsigned char *ubuffer = (unsigned char *)(ptr+(addr & 0x0FFF));
	int byteOffset = bit/8;
	unsigned char byte = ubuffer[byteOffset];
	return byte;
}

int ReadBit( unsigned char *ptr, int addr, int bit )
{
	int bitOffset  = bit%8;
	unsigned char byte = ReadByte( ptr, addr, bit );
/*
	fprintf( stdout, "ReadBit(%X,%d)=%02X,%d\n", 
		addr, bit, byte, bitOffset );
*/
	if( byte & (1<<(7-bitOffset)) )
	    return 1;
	else
	    return 0;
}

int WriteBit( unsigned char *ptr, int addr, int bit, int data )
{
	unsigned char *ubuffer = (unsigned char *)(ptr+(addr & 0x0FFF));
	int byteOffset = bit/8;
	int bitOffset  = bit%8;
	unsigned char byte = ubuffer[byteOffset];
	unsigned char Set  = (1<<(7-bitOffset));
	unsigned char Mask = (1<<(7-bitOffset)) ^ 0xFF;
	if( data )
	    byte = byte | Set;
	else
	    byte = byte & Mask;
	ubuffer[byteOffset] = byte;
/*
	fprintf( stdout, "WriteBit(%X,%d:%d) = %02X\n", 
		addr, bit, data, byte );
*/
	return 0;
}

void swap( unsigned int *value1, unsigned int *value2 )
{
unsigned int tmp = *value1;
	*value1 = *value2;
	*value2 = tmp;
}

int CopyFile( FILE *infile, FILE *outfile, int size )
{
unsigned char buffer[BUF_SIZE];
int bFull = 0;
	if( size<0 )
	    bFull = 1;
	int rest = size;
	while( (rest>0) || bFull )
	{
	    int readed, written;
	    int copySize=0;
	    if( bFull )
	    	copySize = BUF_SIZE;
	    else
		copySize = (rest>BUF_SIZE) ? BUF_SIZE
	    				   : rest;
	    readed  = fread ( buffer, 1, copySize, infile );
	    if( readed<1 )
	    {
	    	fprintf( stdout, "EOF\n" );
		break;
	    }
	    written = fwrite( buffer, 1, readed, outfile );
	    if( written<1 )
	    {
	    	fprintf( stdout, "Can't write(rest=%X)\n", rest );
		return -1;
	    }
	    rest -= written;
	}
	return 0;
}

// -------------------------------------------------------------------------

void pesUsage( char *prg )
{
	fprintf( stdout, "%s filename\n", prg );
	exit( 1 );
}

int pes( int argc, char *argv[] )
{
int i;
char *filename = NULL;
int args=0;
FILE *bin_fp = NULL;
FILE *pts_fp = NULL;
//unsigned char buffer[BUF_SIZE];
int addr=0;
int Error=0;
int nItem = (-1);
int mode = MODE_MPG;
int bEditDirect=0;
int Threshold=90000;	// 1sec

	fprintf( stdout, "pes start\n" );
	fflush( stdout );
//int Packets[MAX_PACKETS+4];	// 16bit
	Packets = (int *)malloc( 4*(MAX_PACKETS+4) );
	if( Packets==NULL )
	{
	    fprintf( stdout, "Can't malloc Packtes\n" );
	    exit( 1 );
	}
	for( i=0; i<(MAX_PACKETS+4); i++ )
	{
	    Packets[i] = 0;
	}
	Packets[MAX_PACKETS+0] = 0x12345678;
	Packets[MAX_PACKETS+1] = 0x9ABCDEF0;
	for( i=0; i<ID_MAX; i++ )
	{
	    items[i] = 0;
	    value[i] = (-1);
	}

#if 1
	init_AVC();
#else
	for( i=0; i<MAX_SPS; i++ )
	{
	    avc_nal_hrd_parameters_present_flag[i]=(-1);
	    avc_vcl_hrd_parameters_present_flag[i]=(-1);
	    avc_pic_struct_present_flag[i]=(-1);
	    avc_CpbDpbDelaysPresentFlag[i]=(-1);
	    PPStoSPS[i] = (-1);
	}
#endif
	g_update_addr = (unsigned int *)malloc( 4*MAX_UPDATE );
	g_update_bits = (unsigned int *)malloc( 4*MAX_UPDATE );
	g_update_size = (unsigned int *)malloc( 4*MAX_UPDATE );
	g_update_data = (unsigned int *)malloc( 4*MAX_UPDATE );

	g_update_addrS = (unsigned int *)malloc( 4*MAX_UPDATE );
	g_update_bit_S = (unsigned int *)malloc( 4*MAX_UPDATE );// remove start
	g_update_bit_E = (unsigned int *)malloc( 4*MAX_UPDATE );// remove end
	g_update_bit_T = (unsigned int *)malloc( 4*MAX_UPDATE );//structure end 
	g_update_mode  = (unsigned int *)malloc( 4*MAX_UPDATE );
	if( g_update_addrS==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_addrS\n" );
	    exit( 1 );
	}
	if( g_update_bit_S==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_bit_S\n" );
	    exit( 1 );
	}
	if( g_update_bit_E==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_bit_E\n" );
	    exit( 1 );
	}
	if( g_update_bit_E==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_bit_E\n" );
	    exit( 1 );
	}
	if( g_update_mode==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_mode\n" );
	    exit( 1 );
	}
	if( g_update_addr==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_addr\n" );
	    exit( 1 );
	}
	if( g_update_bits==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_bits\n" );
	    exit( 1 );
	}
	if( g_update_size==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_size\n" );
	    exit( 1 );
	}
	if( g_update_data==NULL )
	{
	    fprintf( stdout, "Can't malloc g_update_data\n" );
	    exit( 1 );
	}
	for( i=0; i<MAX_UPDATE; i++ )
	{
	    g_update_addr[i] = 0xFFFFFFFF;
	    g_update_bits[i] = 0;
	    g_update_size[i] = 0;
	    g_update_data[i] = 0;
	    g_update_mode[i] = 0;
	}
	for( i=1; i<argc; i++ )
	{
	    if( argv[i][0]=='=' )
	    {
	    	switch( argv[i][1] )
		{
		case 'S' :
		    mode = MODE_AVS;
		    break;

		case 'b' :
		    bShowBitAddr=1;		// Show BitAddr/Offset/Readed
		    break;
		case 't' :
		    // make timing_info_present_flag=0 and remove timing_info
		    bRemoveTimingInfo = 1;
		    fprintf( stdout, "RemoveTimingInfo\n" );
		    break;
		case 'p' :
		    // make pic_struct_present_flag=0 and remove pic_struct
		    bRemovePicStruct = 1;
		    fprintf( stdout, "RemovePicStruct\n" );
		    break;
		case 'f' :
		    // make frame_mbs_only_flag=0
		    nEditFrameMbs = atoi( &argv[i][2] );
		    fprintf( stdout, "EditFrameMbs=%d\n", nEditFrameMbs );
		    break;
		case 'P' :
		    bDebugPES=1;
		    break;
		case 'D' :
		    bDSS=1;
		    break;
		default :
		    fprintf( stdout, "Unknown parameter %s\n", argv[i] );
		    exit( 1 );
		}
	    } else if( argv[i][0]=='-' )
	    {
	    	switch( argv[i][1] )
		{
		case 'N' :
		    bShowDetail=0;
		    bShowNALinfo=0;
		    break;
		case 'n' :
//		    bShowDetail=1;
		    bShowNALinfo=1;
		    break;
		case 'D' :
		    bDump = 1;
		    break;
		case 'W' :
		    bShow = 1;
		    break;
		case 'E' :
		    bSkipError=1;
		    break;
		case 'F' :
//		    bForceAnalyze=1;
		    break;
// -----------------------------------------------------------------	
		case 'A' :
		    mode = MODE_AVC;
		    break;
		case 'M' :
		    mode = MODE_MPG;
		    bAlarmAVC=0;
		    break;
		case 'H' :
		    mode = MODE_HEADER;
		    break;
		case 'h' :
		    mode = MODE_HEADER;
		    break;
		case 'R' :
		    fprintf( stdout, "Remux\n" );
		    mode = MODE_REMUX;
		    Threshold = atoi( &argv[i][2] );
		    if( Threshold<1 )
		    	Threshold=90000;	// 1sec
		    break;
// -----------------------------------------------------------------	
		case 'V' :
		    bDebug = 1;
		    break;
		case 'S' :
		    bDumpSequenceDisplayExtension = 1;
		    bDumpSequenceExtension = 1;
		    bDumpSequence = 1;
		    break;
		case 'a' :
		    bUseAddrFile = 0;
		    fprintf( stdout, "bUseAddrFile=%d\n", bUseAddrFile );
		    break;
		case 'T' :
		    bDisplayTS = 1;
		    break;
		case 's' :
		    bDumpSlice = 1;
		    break;
		case 'C' :
		    nSelSt = atoi( &argv[i][2] );
		    break;
		case 'c' :
		    nSelEn = atoi( &argv[i][2] );
		    break;
		case 'I' :
		    {
			int j;
		    	int id=(-1);
			char *keyword = &argv[i][2];
			int len = strlen(keyword);
		    	for( j=0; headerItem[j].id>=0; j++ )
			{
#if 0
			    fprintf( stdout, "%d:%s,%d\n",
			    	j, headerItem[j].name, headerItem[j].id );
#endif
			    if( strncmp( keyword, headerItem[j].name, len )==0 )
			    {
				id = headerItem[j].id;
				break;
			    }
			}
			if( id<0 )
			{
			    fprintf( stdout, "id(%s) not found\n", keyword );
			    EXIT();
			} else {
			    fprintf( stdout, "%s = %d\n", keyword, id );
			}
			nItem = id;
			items[nItem]++;
			fprintf( stdout, "items[%d]=%d\n", 
			    nItem, items[nItem] );
		    }
		    break;
		case 'p' :
		    fromPts = GetValue( &argv[i][2], &Error );
		    break;
		case 'd' :
		    fromDts = GetValue( &argv[i][2], &Error );
		    break;
		case 'i' :
		    if( nItem>=0 )
		    {
			value[nItem] = GetValue( &argv[i][2], &Error );
			fprintf( stdout, "value[%d] = %d\n", 
				nItem, value[nItem] );
		    }
		    break;
		default :
		    fprintf( stdout, "Unknown parameter %s\n", argv[i] );
		    exit( 1 );
		}
	    } else if( argv[i][0]=='+' )
	    {
	    	switch( argv[i][1] )
		{
		case 'S' :
		    bDumpSPS=1;
		    break;
		case 's' :
		    bParseSlice=1;
		    break;
		case 'e' :
		    bDebugSEI=1;		// Debug SEI
		    break;
		case 'U' :
		    bUserData=1;
		    break;
		case 'F' :
		    bFramePackingArrangement=1;
		    break;
		case 'P' :
		    PtsOffset = atoi( &argv[i][2] );
		    fprintf( stdout, "PtsOffset=%d\n", PtsOffset );
		    bShowDetail = 0;
		    break;
		case 'p' :
		    toPts = GetValue( &argv[i][2], &Error );
		    break;
		case 'd' :
		    toDts = GetValue( &argv[i][2], &Error );
		    break;
		case 'D' :
		    DtsOffset = atoi( &argv[i][2] );
		    fprintf( stdout, "DtsOffset=%d\n", DtsOffset );
		    bShowDetail = 0;
		    break;
		case 'E' :
		    bEditDirect = 1;
		    fprintf( stdout, "bEditDirect=%d\n", bEditDirect );
		    break;
		case 'Z' :
		    bShowDetail = 1;
		    break;
		case 'O' :
		    bShowPOC = 1;
		    break;
		case 'M' :
		    bShowMvcExtention=1;
		    break;
		case 'm' :
		    bShowMvcScalable=1;
		    break;
		default :
		    fprintf( stdout, "Unknown parameter %s\n", argv[i] );
		    exit( 1 );
		}
	    } else {
	    	switch( args )
		{
		case 0 :
		    filename = argv[i];
		    break;
		case 1 :
		    break;
		}
	    }
	}

	if( filename==NULL )
	{
	    pesUsage( argv[0] );
	}
	char srcFilename[1024];
	char binFilename[1024];
	char txtFilename [1024];
	char ptsFilename[1024];
	char outFilename[1024];
	int period=(-1);
	for( i=0; i<strlen(filename); i++ )
	{
	    if( filename[i]=='.' )
	    	period = i;
	}
	if( period>0 )
	{
	    char head[1024];
	    memcpy( head, filename, strlen(filename)+1 );
	    head[period] = 0;
	    memcpy( binFilename, filename, strlen(filename)+1 );
	    snprintf( txtFilename, 1023, "%s.txt", head );
	    snprintf( ptsFilename, 1023, "%s.pts", head );
	} else {
	    snprintf( binFilename, 1023, "%s.bin", filename );
	    snprintf( txtFilename, 1023, "%s.txt", filename );
	    snprintf( ptsFilename, 1023, "%s.pts", filename );
	}

	bin_fp = fopen( binFilename, "rb" );
	if( bin_fp==NULL )
	{
	    fprintf( stdout, "binFilename : Can't open %s\n", binFilename );
	    exit( 1 );
	}
	if( mode==MODE_REMUX )
	{
	    pts_fp = fopen( ptsFilename, "r" );
	    if( pts_fp==NULL )
	    {
		fprintf( stdout, "ptsFilename : Can't read %s\n", ptsFilename );
		exit( 1 );
	    }
	} else {
	    pts_fp = fopen( ptsFilename, "w" );
	    if( pts_fp==NULL )
	    {
		fprintf( stdout, 
			"ptsFilename : Can't write %s\n", ptsFilename );
		exit( 1 );
	    }
	}

	// --------------------------------------------------------
	fprintf( stdout, "pes:%s\n", binFilename );
	fprintf( stdout, "pts:%s\n", ptsFilename );
	switch( mode )
	{
	case MODE_MPG :
	    fprintf( stdout, "MPEG mode\n" );
	    break;
	case MODE_AVC :
	    fprintf( stdout, "AVC mode\n" );
	    break;
	case MODE_AVS :
	    fprintf( stdout, "AVS mode\n" );
	    break;
	case MODE_HEADER :
	    fprintf( stdout, "Header mode\n" );
	    break;
	case MODE_REMUX :
	    fprintf( stdout, "Remux mode\n" );
	    break;
	default :
	    fprintf( stdout, "Unknown  mode (%d)\n", mode );
	    break;
	}
	// --------------------------------------------------------
	// Read Address table
	initTsAddr( );
	if( bUseAddrFile )
	{
	    int nTS=0;
	    if( ReadAddrFile( txtFilename, 
	    	srcFilename, TsAddr, PesAddr,
	    	&nTS, ADDR_MAX )<0 )
	    {
	    	fprintf( stdout, "Can't use AddrFile ignore\n" );
//		exit( 1 );
	    }
	}
	fprintf( stdout, "PesAddr[0]=%X\n", (UINT)PesAddr[0] );
	// --------------------------------------------------------
	//  Analyze
#if 0
	g_update_addr[g_update_count] = 0x1D8E654;
	g_update_bits[g_update_count] = 32;
	g_update_size[g_update_count] = 14;
	g_update_data[g_update_count] = 712;
	g_update_count++;

	g_update_addr[g_update_count] = 0x1D8E654;
	g_update_bits[g_update_count] = 47;
	g_update_size[g_update_count] = 14;
	g_update_data[g_update_count] = 478;
	g_update_count++;

	g_update_addr[g_update_count] = 0x1DDABBE;
	g_update_bits[g_update_count] = 0x00;
	g_update_size[g_update_count] = 12;
	g_update_data[g_update_count] = 712;
	g_update_count++;
#else
	switch( mode )
	{
	case MODE_HEADER :
	    AnalyzeHeader( bin_fp, pts_fp );
	    break;
	case MODE_MPG :
	    AnalyzeMPG( bin_fp, pts_fp );
	    break;
	case MODE_AVC :
	    AnalyzeAVC( bin_fp, pts_fp );
	    break;
	case MODE_AVS :
	    AnalyzeAVS( bin_fp, pts_fp );
	    break;
	case MODE_REMUX :
	    if( srcFilename[0]==0 )
	    {
	    	FILE *fp = fopen( "PES-1FFF.txt", "r" );
		if( fp )
		{
		    if( fgets( srcFilename, 1023, fp )==NULL )
		    {
			fprintf( stdout, "Can't get srcFilename\n" );
			return -1;
		    }
		    fclose( fp );
		    for( i=0; i<strlen(srcFilename); i++ )
		    {
			if( srcFilename[i]=='\n' )
			    srcFilename[i] = 0;
			if( srcFilename[i]=='\r' )
			    srcFilename[i] = 0;
		    }
		    fprintf( stdout, "srcFilename = %s\n", srcFilename );
		}
	    }
	    sprintf( outFilename, "%s-", srcFilename );
	    Remux( srcFilename, outFilename, txtFilename, pts_fp, Threshold );
	    break;
	default :
	    fprintf( stdout, "Unknown format (%d)\n", mode );
	    exit( 1 );
	    break;
	}
#endif
	if( bin_fp )
	{
	    fclose( bin_fp );
	    bin_fp = NULL;
	}
	if( pts_fp )
	{
	    fclose( pts_fp );
	    pts_fp = NULL;
	}

	if( mode==MODE_HEADER )
	{
	    if( fromDts!=INVALID_OFFSET )
	    if( validStart>=0 )
	    {
	    	int total=0;
	    	char writeFilename[1024];
		sprintf( writeFilename, "out.bin" );
	    	FILE *wr_fp = fopen( writeFilename, "wb" );
		if( wr_fp==NULL )
		{
		    fprintf( stdout, 
		    	"Can't write %s\n", writeFilename );
		    exit( 1 );
		}
		bin_fp = fopen( binFilename, "rb" );
		if( bin_fp==NULL )
		{
		    fprintf( stdout, 
		    	"binFilename : Can't open %s\n", binFilename );
		    exit( 1 );
		}
		fseek( bin_fp, validStart, SEEK_SET );
		int Unit=1024*16;
		char copyBuf[Unit];
		int rest=0x7FFFFFFF;	// max
		if( validEnd>0 )
		    rest = validEnd-validStart;
		while( rest>0 )
		{
		    int readed=0;
		    int size=0;
		    if( rest>Unit )
			size = Unit;
		    else
			size = rest;
		    readed = fread( copyBuf, 1, size, bin_fp );
		    if( readed<1 )
			break;
		    fwrite( copyBuf, 1, readed, wr_fp );
		    rest -= readed;
		    total += readed;
		}
		fclose( wr_fp );
		fclose( bin_fp );
		fprintf( stdout, "%d bytes written\n", total );
	    }
	}

	// Make updated file
	int j, n;
	if( g_update_count>0 )
	{
	    fprintf( stdout, 
	    	"----------------------------------------------\n" );
	    fprintf( stdout, "g_update_count =%d\n", g_update_count );
	    fprintf( stdout, "g_update_countS=%d\n", g_update_countS );
	    fprintf( stdout, "Now swap\n" );
	    for( j=0; j<(g_update_count-0); j++ )
	    {
		int bSwapped=0;
		for( i=0; i<j; i++ )
		{
		    int bit1 = g_update_addr[i+0]*8+g_update_bits[i+0];
		    int bit2 = g_update_addr[i+1]*8+g_update_bits[i+1];
		    if( bit1>bit2 )
		    {
			swap( &g_update_addr[i+0], &g_update_addr[i+1] );
			swap( &g_update_bits[i+0], &g_update_bits[i+1] );
			swap( &g_update_size[i+0], &g_update_size[i+1] );
			swap( &g_update_data[i+0], &g_update_data[i+1] );
			bSwapped++;
		    }
		}
		if( bSwapped==0 )
		    break;
	    }
	    for( n=0; n<g_update_count; n++ )
	    {
	    	if( bShowUpdate )
		{
		    fprintf( stdout, "update 0x%X,%d,%d,%d\n",
			g_update_addr[n],
			g_update_bits[n],
			g_update_size[n],
			g_update_data[n] );
		}
	    }
	    fprintf( stdout, "%d item updated\n", g_update_count );
	}

	if( (g_update_count>0) || (g_update_countS>0) )
	{
	    if( bEditDirect==0 )
	    {
		sprintf( outFilename, "%s-", srcFilename );
		FILE *src_fp = fopen( srcFilename, "rb" );
		if( src_fp==NULL )
		{
		    fprintf( stdout, 
		    "srcFilename : Can't open %s\n", srcFilename );
		    exit( 1 );
		}
		FILE *outfile = fopen( outFilename, "wb" );
		if( outfile==NULL )
		{
		    fprintf( stdout, "outfile : Can't open %s\n", outFilename );
		    exit( 1 );
		}
		fprintf( stdout, "Copy %s to %s\n", srcFilename, outFilename );
		CopyFile( src_fp, outfile, -1 );

		fclose( src_fp );
		fclose( outfile );
	    } else {
		sprintf( outFilename, "%s", srcFilename );
	    }
	    // ------------------------------------------------
	    int fd;
	    int n;
	    int mapSize = 4096*2;
	    fprintf( stdout, "Update %s\n", outFilename );
	    fd = open( outFilename, O_RDWR );
	    if( fd==(-1) )
	    {
	    	fprintf( stdout, "outFilename : Can't open %s\n", outFilename );
		exit( 1 );
	    }
	    unsigned char *data;
	    // Update Bits
	    for( n=0; n<g_update_count; n++ )
	    {
	    	if( bShowUpdate )
		{
		    fprintf( stdout, "addr=%8X, bits=%X : ",
			g_update_addr[n], g_update_bits[n] );
		}

		addr = SrcAddr(g_update_addr[n] + g_update_bits[n]/8,0);
		g_update_bits[n]=g_update_bits[n]%8;

	    	if( bShowUpdate )
		{
		    fprintf( stdout, "addr=%8X, bits=%X\n",
			addr, g_update_bits[n] );
		}
	    // mmap
		data = (unsigned char *)mmap( (caddr_t)0, mapSize, 
				    PROT_READ | PROT_WRITE, MAP_SHARED,
				    fd, addr & 0xFFFFF000 );
		if( data==(unsigned char *)-1) 
		{
		    fprintf( stdout, "Can't mmap\n" );
		    exit( 1 );
		}
	    // update data
		{
		    unsigned char *ubuffer =
			    (unsigned char *)(data+(addr & 0x0FFF));
		    UpdateBits( ubuffer, 
			g_update_bits[n], g_update_size[n], g_update_data[n] );
		}
	    // munmap
		if( munmap( data, mapSize )==(-1) )
		{
		    fprintf( stdout, "Can't munmap\n" );
		    exit( 1 );
		}
	    }
	    // Special Update
	    for( n=0; n<g_update_countS; n++ )
	    {
		int bit;	
		fprintf( stdout, "=== %d\n", n );
		fprintf( stdout, 
		    "Special : addr=%8X, bits=%d, %d, %d (mode=%d)\n",
		    g_update_addrS[n], 
		    g_update_bit_S[n],
		    g_update_bit_E[n],
		    g_update_bit_T[n],
		    g_update_mode [n]
		    );
	    // mmap
		addr = SrcAddr(g_update_addrS[n],0);
		data = (unsigned char *)mmap( (caddr_t)0, mapSize, 
				    PROT_READ | PROT_WRITE, MAP_SHARED,
				    fd, addr & 0xFFFFF000 );
		if( data==(unsigned char *)-1) 
		{
		    fprintf( stdout, "Can't mmap\n" );
		    exit( 1 );
		}
#if 1
		fprintf( stdout, "addr=%X\n", addr );
		int j;
		for( j=0; j<16; j++ )
		{
		    fprintf( stdout, "%4d : ", (j*16+0)*8 );
		    for( i=0; i<16; i++ )
		    {
			int b = ReadByte( data, addr, (j*16+i)*8 );
			fprintf( stdout, "%02X ", b );
		    }
		    fprintf( stdout, "\n" );
		}
#endif
		if( g_update_mode[n]==EDIT_CUT )
		{
		    // S,E,T : S<-E
		    fprintf( stdout, "EDIT_CUT\n" );
		    for( bit=g_update_bit_E[n]; bit<g_update_bit_T[n]; bit++ )
		    {
			fprintf( stdout, "addr=%8X, bits=%d\n", addr, bit );
			int b, dst_bit;
			dst_bit = g_update_bit_S[n]+bit-g_update_bit_E[n];
			b = ReadBit( data, addr, bit );
			WriteBit( data, addr, dst_bit, b );
			fprintf( stdout, "%4X,%3d : %d : %4X,%3d : %02X\n",
			    addr, bit, b, addr, dst_bit,
			    ReadByte( data, addr, dst_bit ) );
		    }
		    for( bit=g_update_bit_S[n]
		    	    +g_update_bit_T[n]-g_update_bit_E[n];
			    bit<=g_update_bit_T[n]; bit++ )
		    {
			WriteBit( data, addr, bit, 0 );
		    }
		} else if( g_update_mode[n]==EDIT_INS )
		{
		    // S,E,T : S->E
		    fprintf( stdout, "EDIT_INS\n" );
//		    for( bit=g_update_bit_E[n]; bit<g_update_bit_T[n]; bit++ )
		    for( bit=g_update_bit_T[n]-1; 
		    	bit>=g_update_bit_E[n]; bit-- )
		    {
			fprintf( stdout, "addr=%8X, bits=%d\n", addr, bit );
			int b, dst_bit;
//			dst_bit = g_update_bit_S[n]+bit-g_update_bit_E[n];
// 2012/5/8 Edit
			dst_bit = bit+g_update_bit_E[n]-g_update_bit_S[n];
			b = ReadBit( data, addr, bit );
			WriteBit( data, addr, dst_bit, b );
			fprintf( stdout, "%4X,%3d : %d : %4X,%3d : %02X\n",
			    addr, bit, b, addr, dst_bit,
			    ReadByte( data, addr, dst_bit ) );
		    }
		    int b=0;
		    for( bit=g_update_bit_S[n]; 
		    	 bit<g_update_bit_E[n]; bit++ )
		    {
			WriteBit( data, addr, bit, b );
		    }
		}
	    // munmap
		if( munmap( data, mapSize )==(-1) )
		{
		    fprintf( stdout, "Can't munmap\n" );
		    exit( 1 );
		}
	    }
	    close( fd );
	}
	fprintf( stdout, "Packets[MAX_PACKETS+0] = %8X\n", 
		Packets[MAX_PACKETS+0] );
	fprintf( stdout, "Packets[MAX_PACKETS+1] = %8X\n", 
		Packets[MAX_PACKETS+1] );
	for( i=0; i<MAX_PACKETS; i++ )
	{
	    if( Packets[i]>0 )
	    {
		fprintf( stdout, "Packet[%04X] = %d\n", i, Packets[i] );
	    }
	}
	for( i=0; i<256; i++ )
	{
	    if( Counts[i]>0 )
	    {
		fprintf( stdout, "Counts[%04X] = %d\n", i, Counts[i] );
	    }
	}
	return 0;
}

