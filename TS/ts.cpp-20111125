
/*
	ts.cpp
			2010.10.XX  by T.Oda

	2011.4.8	Add '-a' option : bAll      : Save from begining
	2011.4.8	Add '-s' option : bShowAddr : show address
	2011.9.2	Add '+P' option : bPrintPCR : show PCR & address
	2011.9.5		Output pcr.txt file
	2011.9.13	'-W' option : Update PCR -WXX (PCR offset)
			'-c' option : bCutEnd
	2011.9.21	Output TTS.txt (TsPacketSize=192)
	2011.9.27	PCR 33bit
	2011.10.28	Debug : Last packet not broken
	2011.10.29	Debug : No PCR : make adapt_len = (-1) : NG
			Use TsPacketSize not WriteSize
	2011.10.31	Change PES-XXXX.txt output format
			TS-addr, TS-addr2, PES-addr, PES-size, PCR
	2011.11.23	TTS PES-XXXX.bin not correct
*/

//#define ODA

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

#include "tsLib.h"

#define TS_PACKET_SIZE 188

#define MODE_ADDR		0
#define MODE_DUMP		1
#define MODE_DUMP2		2
#define MODE_DUMP3		3
#define MODE_PID		4
#define MODE_PAT		5
#define MODE_PMT		6
#define MODE_CUT		9
#define MODE_OFF		10
#define MODE_PCR_ANALYZE	11
#define MODE_PCR_UPDATE		12
#define MODE_CUT_END		13

#define MODE_TEST		19

#define MAX_PIDS 64

int bDebug = 0;
int TsPacketSize = TS_PACKET_SIZE;
int bRemoveOtherPacket = 0;
int bCheckContinuous = 0;
int g_addr = 0;
int bWriteMsg=0;
int bAll=0;
int bShowAddr=0;
int bPrintPCR=0;
int bCutEnd=0;
unsigned long nLastAll=0;

// ------------------------------
#define MAX_PCRS 1024*1024
int PCR_PID[MAX_PCRS];
unsigned long PCR_addr[MAX_PCRS];
long long PCR_value[MAX_PCRS];
int nPCR=0;
double d_keisuL = 0;
unsigned long long PCR0=0xFFFFFFFF, PCR1=0;
unsigned long addr0=0xFFFFFFFF, addr1=0;
int PcrOffset=0;
unsigned long EndPts=0;

#define MAX_PACKETS 1024*1024*4
int TsPID[MAX_PACKETS];
//int TsPTS[MAX_PACKETS];
// ------------------------------

int gread( unsigned char *bytes, int sz, int n, FILE *fp )
{
int readed;
	readed = fread( bytes, sz, n, fp );
	if( readed>0 )
	    g_addr += (sz*readed);
//	fprintf( stdout, "%d bytes readed\n", sz*readed );
	return readed;
}
void Usage( char *prg )
{
	fprintf( stdout, "%s -A -D -C\n", prg );
	exit( 1 );
}

int Compare( char strA[], char strB[], int len )
{
int i;
int ret=0;
	for( i=0; i<len; i++ )
	{
	    if( strA[i] != strB[i] )
		ret++;
	    if( strA[i]==0 )
	    	break;
	    if( strB[i]==0 )
	    	break;
	}
	return ret;
}

int GetValue( char str[], int &Error )
{
int len = strlen( str );
int i;
int bHex  = 0;
int value = 0;
int sign = 1;

	Error=0;
	if( len>2 )	
	    if( Compare( str, "0x", 2 )==0 )
	    	bHex = 1;

	if( bHex )
	{
	    for( i=2; i<len; i++ )
	    {
	    	if( (str[i]>='0') && (str[i]<='9') )
		{
		    value = value*16 + (str[i]-'0');
		} else if( (str[i]>='A') && (str[i]<='F') )
		{
		    value = value*16 + (str[i]-'A'+10);
		} else if( (str[i]>='a') && (str[i]<='f') )
		{
		    value = value*16 + (str[i]-'a'+10);
		} else {
		    Error++;
		    break;
		}
	    }
	} else {
	    for( i=0; i<len; i++ )
	    {
	    	if( (i==0) && (str[i]=='-') )
		{
		    sign = (-1);
		} else if( (str[i]>='0') && (str[i]<='9') )
		{
		    value = value*10 + (str[i]-'0');
		} else {
		    Error++;
		    break;
		}
	    }
	}
	return value*sign;
} 

void CannotRead( char message[] )
{
    fprintf( stdout, "CannotRead(%s:0x%X)\n", message, g_addr );
}

int bDebugPES=0;
int bDisplayTS=0;
int bDump=0;

int PES_header( FILE *fp, unsigned char buffer[], int mode,
	unsigned long &PTSH, unsigned long &PTSL, 
	unsigned long &DTSH, unsigned long &DTSL )
{
int len;
int readed;
int i;
int offset=0;
	PTSH=0xFFFFFFFF;
	PTSL=0xFFFFFFFF;
	DTSH=0xFFFFFFFF;
	DTSL=0xFFFFFFFF;
	if( mode>0 )
	{
	fprintf( stdout, "------------------------\n" );
	fprintf( stdout, "PES_header(%X,%X)\n", g_addr );
	}
	readed = gread( buffer, 1, 2, fp );
	len = (buffer[0]<<8) | buffer[1];
	if( bDebugPES )
	fprintf( stdout, "PES_len=%8X\n", len );
	readed = gread( buffer, 1, 3, fp );
	if( readed<3 )
	{
	    CannotRead( "PES header top" );
	    return -1;
	}
	int PES_header_data_length = buffer[2];
#if 0
	for( i=0; i<3; i++ )
	{
	    fprintf( stdout, "%02X ", buffer[i] );
	}
	fprintf( stdout, "\n" );
#endif
	int bPTS=0;
	int bDTS=0;
	int flag1=buffer[0];
	int flag2=buffer[1];
	if( (flag1>>6)!=2 )
	    fprintf( stdout, "Invalid flag1 (%02X)\n", flag1 );
	bPTS = (flag2 & 0x80) ? 1 : 0;
	bDTS = (flag2 & 0x40) ? 1 : 0;
	flag1 = flag1 & 0x3F;
	flag2 = flag2 & 0x3F;
#if 0
	fprintf( stdout, "%02X:%d,%d:%02X, %02X\n", 
	    flag1, bPTS, bDTS, flag2, PES_header_data_length );
#endif
	offset=3;
	if( bDebugPES )
	fprintf( stdout, "PES_header_data_length=%d\n",
		PES_header_data_length );

	int head_addr = g_addr-offset;
	int stAddr, enAddr;
	readed = gread( &buffer[3], 1, PES_header_data_length, fp );
	if( readed<PES_header_data_length )
	{
	    CannotRead( "PES header data" );
	    return -1;
	}
	int PTS_H=(-1), PTS_L=(-1), DTS_H=(-1), DTS_L=(-1);
	if( bPTS )
	{
	    PTS_H = (buffer[offset+0]<< 0);
	    PTS_L = (buffer[offset+1]<<24)
		  | (buffer[offset+2]<<16)
		  | (buffer[offset+3]<< 8)
		  | (buffer[offset+4]<< 0);
	    if( bDisplayTS )
	    fprintf( stdout, "PTS=%02X:%08X (%02X,%02X,%02X,%02X,%02X)\n",
		    PTS_H, PTS_L, 
		    buffer[offset+0], buffer[offset+1], 
		    buffer[offset+2], buffer[offset+3],
		    buffer[offset+4] );
	    TS( PTS_H, PTS_L, &PTSH, &PTSL );
	    if( bDisplayTS )
	    fprintf( stdout, "PTS=%02X:%08X\n", PTSH, PTSL );

	    stAddr = head_addr+offset+0;
	    enAddr = head_addr+offset+5;
	    if( mode>0 )
		fprintf( stdout, "PTS(%8X,%8X)=%8X,%08X\n", 
			stAddr, enAddr, PTSH, PTSL );
#ifdef UPDATE
	    if( PtsOffset!=INVALID_OFFSET )
	    {
	    	if( ((fromPts!=INVALID_OFFSET) && (toPts!=INVALID_OFFSET)
		  && (PTSL>=fromPts) && (PTSL<=toPts))

		  || (((fromPts!=INVALID_OFFSET) && (toPts==INVALID_OFFSET))
		  && (PTSL>=fromPts) )

		  || (((fromPts==INVALID_OFFSET) && (toPts!=INVALID_OFFSET))
		  && (PTSL<=toPts) )

		  || ((fromPts==INVALID_OFFSET) && (toPts==INVALID_OFFSET))
		)
		{
		UpdateTS( stAddr, PTSH, PTSL, MODE_PTS, bPTS, bDTS, PtsOffset );
#if 0
		fprintf( stdout, "PtsUpdate(%8X,%8X)\n", PTSL, PtsOffset );
#endif
		}
	    }
#endif
	    offset+=5;
	} else {
	    if( bDump )
		fprintf( stdout, "No PTS\n" );
	}
	if( bDTS )
	{
	    DTS_H = (buffer[offset+0]<< 0);
	    DTS_L = (buffer[offset+1]<<24)
		  | (buffer[offset+2]<<16)
		  | (buffer[offset+3]<< 8)
		  | (buffer[offset+4]<< 0);
	    if( bDisplayTS )
	    fprintf( stdout, "DTS=%02X:%08X (%02X,%02X,%02X,%02X,%02X)\n",
		    DTS_H, DTS_L, 
		    buffer[offset+0], buffer[offset+1], 
		    buffer[offset+2], buffer[offset+3],
		    buffer[offset+4] );
	    TS( DTS_H, DTS_L, &DTSH, &DTSL );
	    if( bDisplayTS )
	    fprintf( stdout, "DTS=%02X:%08X\n", DTSH, DTSL );

	    stAddr = head_addr+offset+0;
	    enAddr = head_addr+offset+5;
	    if( mode>0 )
	    fprintf( stdout, "DTS(%8X,%8X)=%8X,%08X\n", 
	    	stAddr, enAddr, DTSH, DTSL );
#ifdef UPDATE
	    if( DtsOffset!=INVALID_OFFSET )
	    	if( ((fromDts!=INVALID_OFFSET) && (toDts!=INVALID_OFFSET)
		  && (DTSL>=fromDts) && (DTSL<=toDts))
		  || ((fromDts==INVALID_OFFSET) && (toDts==INVALID_OFFSET))
		)
		UpdateTS( stAddr, DTSH, DTSL, MODE_DTS, bPTS, bDTS, DtsOffset );
#endif
	    offset+=5;
	} else {
	    if( bDump )
		fprintf( stdout, "No DTS\n" );
	}
	if( bDisplayTS )
	if( bPTS & bDTS )
	    fprintf( stdout, "PTSDTS=%02X:%08X,%02X:%08X diff(%5d)\n",
	    	PTSH, PTSL, DTSH, DTSL, (PTSL-DTSL) );
	    else if( bPTS )
	    fprintf( stdout, "PTSDTS=%02X:%08X,--:-------- diff(%5d)\n",
	    	PTSH, PTSL, 0 );
	    else if( bDTS )
	    fprintf( stdout, "PTSDTS=--:--------,%02X:%08X diff(  ?  )\n",
	    	DTSH, DTSL );
	if( mode>0 )
	fprintf( stdout, "------------------------\n" );
//	return 0;
	return len;
}

int ParsePts( FILE *bin_fp, FILE *pts_fp )
{
unsigned char bytes [1024];
unsigned char buffer[1024];
int ReadOK;
unsigned long PTSH, PTSL, DTSH, DTSL;
int nPTS=0;
	g_addr=0;
	int state=0;
	while( 1 )
	{
	    ReadOK = gread( &bytes[state], 1, 1, bin_fp );
	    if( ReadOK<1 )
	    {
	    	fprintf( stdout, "EOF\n" );
		break;
	    }
	    switch( state )
	    {
	    case 0 :
	    	if( bytes[0]==0x00 )	// 00
		    state++;
		break;
	    case 1 :
	    	if( bytes[1]==0x00 )	// 00 00
		    state++;
		else
		    state=0;
		break;
	    case 2 :
	    	if( bytes[2]==0x01 )	// 00 00 01
		    state++;
		else if( bytes[2]==0x00 )	// 00 00 00
		{
		} else
		    state=0;
		break;
	    case 3 :
	    	if( (bytes[3]==0xE0) 	// Video
		 || (bytes[3]==0xC0) 	// Audio
		) {
		    PES_header( bin_fp, buffer, 0, PTSH, PTSL, DTSH, DTSL );
		    fprintf( pts_fp, "%8X %8X : %4X %08X, %4X %08X\n",
			    g_addr, SrcAddr(g_addr),
			    PTSH & 0xFFFF, PTSL, DTSH & 0xFFFF, DTSL );
		    nPTS++;
		}
		state = 0;
		break;
	    }
	}
	return nPTS;
}

#define MAX_PID	8192

int TsDump( char filename[], char editfile[], int pid[], int nPid, int mode )
{
FILE *ts_fp=NULL;
unsigned char bytes[1024*4];
int readed;
int PID=(-1);
unsigned int PCR_H=0xFFFFFFFF;
unsigned int PCR_L=0xFFFFFFFF;
int i;
struct stat Stat;
FILE *edit=NULL;
FILE *pcr_fp = NULL;
FILE *tts_fp = NULL;
FILE       *out_fp [MAX_PID];
FILE       *addr_fp[MAX_PID];
int       bPayload [MAX_PID];
int       nPayload [MAX_PID];
int       nCount   [MAX_PID];
unsigned long nAddr[MAX_PID];
unsigned long nLast[MAX_PID];
int 	     Lcount[MAX_PID];

static char outfile[] = "PES.bin";
int bRecord=0;
int bPrint=1;
// Error
int nSyncError=0;
unsigned long L_PCR_addr = 0xFFFFFFFF;
int PCR_interval_Error=0;

	for( i=0; i<MAX_PACKETS; i++ )
	{
	    TsPID[i] = -1;
//	    TsPTS[i] = -1;
	}
	g_addr = 0;

	fprintf( stdout, "TsDump(%s)\n", filename );
	pcr_fp = fopen( "PCR.txt", "w" );
	if( pcr_fp==NULL )
	{
	    fprintf( stdout, "Can't open PCR.txt\n" );
	}
	if( TsPacketSize==192 )
	{
	    tts_fp = fopen( "TTS.txt", "w" );
	}
	if( mode==2 )
	if( bAll )
	    bRecord = 1;
	for( i=0; i<MAX_PID; i++ )
	{
	    out_fp  [i] = NULL;
	    addr_fp [i] = NULL;
	    bPayload[i] = 0;
	    nPayload[i] = 0;
	    nCount  [i] = 0;
	    nAddr   [i] = 0;
	    nLast   [i] = 0;
	    Lcount  [i] = (-1);
	}
	if( stat( filename, &Stat )!=0 )
	{
	    fprintf( stdout, "Can't stat %s\n", filename );
	    exit( 1 );
	}
	int size = (int)Stat.st_size;
//	int packets = size/TS_PACKET_SIZE;
	int packets = size/TsPacketSize;
	fprintf( stdout, "size=%d, packets=%d\n", size, packets );
	ts_fp = fopen ( filename, "rb" );
	if( ts_fp==NULL )
	{
	    fprintf( stdout, "Can't open %s\n", filename );
	    exit( 1 );
	}
	if( editfile!=NULL )
	{
	    edit = fopen( editfile, "wb" );
	    if( edit==NULL )
	    {
	    	fprintf( stdout, "Can't write %s\n", editfile );
		exit( 1 );
	    }
	}
	if( mode<0 )
	    bPrint = 0;
	if( mode==2 )
	    bPrint = 0;
	int byteOffset=0;
	if( TsPacketSize==192 )
	{
	    byteOffset=4;
	}
	for( i=0; ; i++ )
	{
	    int n;
	    int SyncOK=0;
	    if( (i%10000)==0 )
	    {
		if( bDebug )
		    fprintf( stdout, "\r%d ", i );
    //		    fprintf( stdout, "*" );
		fflush( stdout );
	    }
	    int ReadOK;
	    ReadOK = gread( bytes, TsPacketSize, 1, ts_fp );
	    if( ReadOK<1 )
	    {
		fprintf( stdout, "\nEOF@%d(addr=0x%X,%d)\n", 
			i, g_addr, g_addr );
		break;
	    } else {
	    	readed = TsPacketSize;
	    }
	    int nRetry=0;
	    SyncOK=0;
	    int bEOF=0;
	    while( (SyncOK==0) && (bEOF==0) )
	    {
		if( bytes[byteOffset+0]==0x47 )
		{
		    PID = ((bytes[byteOffset+1]<<8) 
		         | (bytes[byteOffset+2]<<0)) & 0x1FFF;
		    SyncOK=1;
		} else {
		    PID = 0xFFFF;
		    if( nRetry==0 )
		    {
		    	int ii;
			nSyncError++;
			fprintf( stdout, "Invalid Sync Byte(%02X)@%X\n", 
			    bytes[byteOffset+0], g_addr-TsPacketSize );
			fprintf( stdout, "%8X : ", g_addr-TsPacketSize );
			for( ii=0; ii<(byteOffset+4); ii++ )
			{
			    fprintf( stdout, "%02X ", bytes[ii] );
			}
			fprintf( stdout, "\n" );
		    }
		    for( n=byteOffset; n<TsPacketSize; n++ )
		    {
			if( bytes[n]==0x47 )
			{
			    fprintf( stdout, "Sync? @%X\n", 
			    	g_addr-TsPacketSize+n );
			    memcpy( bytes, &bytes[n], TsPacketSize-n );
			    ReadOK = gread( &bytes[TsPacketSize-n], 
			    	n, 1, ts_fp );
			    if( ReadOK<1 )
			    	bEOF = 1;
			    else
			    	readed = TsPacketSize-n;
			    nRetry++;
			    break;
			}
		    }
		    if( n==TsPacketSize )
		    {
			    ReadOK = gread( &bytes[0], TsPacketSize, 1, ts_fp );
			    if( ReadOK<1 )
			    {
				fprintf( stdout, "EOF@%d(addr=0x%X,%d)\n", 
					i, g_addr, g_addr );
				break;
			    } else
			    	readed = TsPacketSize;
		    }
		}
		if( byteOffset==0 )
		{
		    int key = getc( ts_fp );
		    ungetc( key, ts_fp );
		    if( (key!=EOF) && (key!=0x47) )
		    {
			SyncOK=0;
			bytes[0] = 0;
		    }
		} else {
			if( tts_fp )
			fprintf( tts_fp, "%8X : %02X %02X %02X %02X\n",
			    g_addr-TsPacketSize, 
			    bytes[0], bytes[1], bytes[2], bytes[3] );
		}
	    }
	    int bDo=0;
	    int bPidMatch=0;
	    if( pid[0]<0 )
		bDo=1;
	    for( i=0; i<nPid; i++ )
	    {
		if( PID==pid[i] )
		{
		    bDo=1;
		    bPidMatch=1;
		    break;
		}
	    }
	    if( PID==0x1FFF )
	    	bDo=1;
	    unsigned char *byteS = &bytes[byteOffset];
	    if( SyncOK )
	    {
#ifdef ODA
int ii;
fprintf( stdout, "%8X : ", g_addr-TsPacketSize );
for( ii=0; ii<8; ii++ )
{
    fprintf( stdout, "%02X ", bytes[ii] );
}
fprintf( stdout, "\n" );
#endif
		int nTs = g_addr/TsPacketSize-1;
		if( nTs>=MAX_PACKETS )
		{
		    fprintf( stdout, "Too large packets(%d)\n", nTs );
		    exit( 1 );
		}
		TsPID[nTs] = PID;
	    	if( bShowAddr )
	    	fprintf( stdout, "%5d:%8X-%8X\n",
			i, g_addr-TsPacketSize, g_addr );
		int ts_error     = (byteS[1]>>7)&1;
		int payloadStart = (byteS[1]>>6)&1;
		int ts_priority  = (byteS[1]>>5)&1;
		int adapt = (byteS[3]>>4)&3;
		int count =  byteS[3]    &15;
		int adapt_len = byteS[4];
		int bOut=0;
		int skip=0;
		int bAdapt  =0;
//		if( (PID==pid) || (pid<0) )
		if( bDo )
		{
		    switch( adapt )
		    {
		    case 0 :	// ?
//			fprintf( stdout, "adapt=%d\n", adapt );
			break;
		    case 1 :	// no adapt
			bPayload[PID]=1;
			bAdapt  =0;
			break;
		    case 2 :	// adapt
			bPayload[PID]=0;
			if( adapt_len>0 )	// 2011/9/2
			    bAdapt  =1;
			break;
		    case 3 :	// adapt+payload
			bPayload[PID]=1;
			if( adapt_len>0 )	// 2011/9/2
			    bAdapt  =1;
			break;
		    default :
			fprintf( stdout, "Invalid adapt(%d)\n", adapt );
			exit( 1 );
			break;
		    }
		    skip+=4;	// Header 4byte
		    unsigned long curAddr = g_addr-TsPacketSize;
		    if( PID==0x1FFF )
		    {
    #if 0
			fprintf( stdout, 
				"%5d : %04X : %X,%X : ", i, PID, adapt, count );
			fprintf( stdout, "\n" );
    #endif
    			if( (L_PCR_addr!=0xFFFFFFF) && (d_keisuL>0) )
			{
			    int diff = curAddr-L_PCR_addr;
			    double d_offset;
			    d_offset = curAddr-L_PCR_addr;
			    d_offset = d_offset*d_keisuL;
			    int i_offset = (int)d_offset;
			    // PCR should be every 100ms (9000)
			    if( (i_offset>8900) && (PCR_interval_Error==0) )
			    {
				if( mode==(-1) )	// PCR_UPDATE
				{
#if 0
				    fprintf( stdout, 
				    " (PCR interval correct)" );
#endif
				    PID=pid[0];
				    bPidMatch = 1;
				    bAdapt  =1;
				    byteS[ 1] =  0x20 | ((PID&0xFF00)>>8);
				    byteS[ 2] =  (PID&0x00FF);
				    byteS[ 3] = 0x2C;
				    byteS[ 4] = 0xB7;
				    byteS[ 5] = 0x10;
				    byteS[ 6] = 0x00;
				    byteS[ 7] = 0x00;
				    byteS[ 8] = 0x00;
				    byteS[ 9] = 0x00;
				    byteS[10] = 0x00;
				    byteS[11] = 0x00;
				} else {
				    fprintf( stdout, 
				    	"PCR interval Error(%d)\n", i_offset );
				    PCR_interval_Error=1;
				}
			    } else {
				PCR_interval_Error=0;
			    }
			}
		    }
		    if( PID==0x1FFF )
		    {
    #if 0
			fprintf( stdout, 
				"%5d : %04X : %X,%X : ", i, PID, adapt, count );
			fprintf( stdout, "\n" );
    #endif
		    } else {
		    	nCount[PID]++;
			if( bAdapt )
			{
			    if( bPrint )
			    fprintf( stdout, 
				"%5d : %04X : %X,%X : ", i, PID, adapt, count );
			    bOut++;
			    int flag = byteS[5];
			    int bPCR  = flag & (1<<4);
			    int bOPCR = flag & (1<<3);
			    int bSPR  = flag & (1<<2);
			    int bPRV  = flag & (1<<1);
			    int bEXT  = flag & (1<<0);
			    {
				if( bPCR )
				{
				    unsigned long long LL;
				    PCR_H = (byteS[ 6]<< 8) | (byteS[ 7]<< 0);
				    PCR_L = (byteS[ 8]<<24) | (byteS[ 9]<<16)
					  | (byteS[10]<< 8) | (byteS[11]<< 0);
				    LL = (unsigned long long)PCR_H;
				    LL = (LL<<32) | PCR_L;

				    if( bPrint || bPrintPCR )
				    {
				    fprintf( stdout, "%02X %02X %02X %02X : ",
				    	byteS[0], byteS[1], byteS[2], byteS[3]);
				    fprintf( stdout, 
					"%02X (%02X) PCR : %08X,%08X : ", 
					adapt_len, flag, PCR_H, PCR_L );
				    if( bPrint==0 )
					fprintf( stdout, "%8X\n", 
						g_addr-TsPacketSize );
				    }
				    if( pcr_fp )
				    {
					fprintf( pcr_fp, 
					    "%8X : %04X : %08X,%08X %09llX\n",
					    g_addr-TsPacketSize,
					    PID,
					    PCR_H, PCR_L, LL>>15 );
				    }
				    {
				    	if( nPCR>=MAX_PCRS )
					{
					    fprintf( stdout, 
						"nPCR=%d\n", nPCR );
					    exit( 1 );
					}
				    	PCR_PID  [nPCR] = PID;
					PCR_addr [nPCR] = curAddr;
					PCR_value[nPCR] = LL;
					nPCR++;
				    }
				    if( bPidMatch )
				    {
					if( curAddr>=addr0 )
					{
					    if( mode==(-1) )	// PCR_UPDATE
					    {
					    unsigned long long curPCR =
						(LL>>15);
					    double d_offset;
					    d_offset = (curAddr-addr0);
					    d_offset = d_offset*d_keisuL;
					    unsigned long long newPCR =
					    (unsigned long long)d_offset+PCR0;
					    newPCR = newPCR+PcrOffset;
					    newPCR = newPCR & 0x1FFFFFFFFLL;
					    fprintf( stdout, 
					    "\nPCR update(%8X) %9llX->%9llX",
					    curAddr, curPCR, newPCR );

					    unsigned long nPCR_H =
					    	newPCR>>17;
					    unsigned long nPCR_L = 
					    	  (PCR_L & 0x7FFF)
						| (newPCR<<15) &0xFFFF8000;
					    byteS[ 6] = (nPCR_H>> 8)&0xFF;
					    byteS[ 7] = (nPCR_H>> 0)&0xFF;
					    byteS[ 8] = (nPCR_L>>24)&0xFF;
					    byteS[ 9] = (nPCR_L>>16)&0xFF;
					    byteS[10] = (nPCR_L>> 8)&0xFF;
					    byteS[11] = (nPCR_L>> 0)&0xFF;
					    }
					    L_PCR_addr = curAddr;
					}
				    }
				} else {
				    if( bPrint )
				    fprintf( stdout, "%02X (%02X) (No PCR) : ",
					adapt_len, flag );
				}
			    }
			    skip+=(1+adapt_len);
			}
			if( bPayload[PID] )
			{
			    nPayload[PID]++;
			    if( bPrint )
			    {
				if( bAdapt==0 )
				{
				    fprintf( stdout, "%5d : %04X : %X,%X : ",
					i, PID, adapt, count );
				    bOut++;
				}
			    }
			    if( payloadStart )
			    {
				if( bPrint )
				{
				    if( bOut==0 )
				    fprintf( stdout, "%5d : ", i );
				    fprintf( stdout, "Payload Start\n", i );
				}
				bOut=0;
				if( mode==2 )
				    bRecord = 1;
			    } else {
				if( bPrint )
				fprintf( stdout, "(Payload)", i );
			    }
			}
			if( Lcount[PID]>=0 )
			{
#if 0
	fprintf( stdout, "Check(%4d:%d->%d)\n", PID, Lcount[PID], count );
#endif
			    if( bCheckContinuous )
			    {
			    	int Ncount = (Lcount[PID]+1)&15;
				if( count!=Ncount )
				{
				    fprintf( stdout, 
				    "\n*** CC Update(%4d:%d:%d->%d) ***", 
					PID, Lcount[PID], count, Ncount );
				    int LbyteS = byteS[3];
				    byteS[3] = byteS[3] & 0xF0 | Ncount;
				    count = Ncount;
				}
			    }
			}
			Lcount[PID] = count;
		    }
		    if( bOut )
		    {
			if( bPrint )
			fprintf( stdout, "\n" );
			bOut=0;
		    }
		    if( mode==1 )
		    {
			fprintf( stdout, "%5d : %04X\n", i, PID );
			int j;
			for( j=0; j<TS_PACKET_SIZE; j++ )
			{
			    if( j%16==0 )
				fprintf( stdout, "%03X : ", j );
			    fprintf( stdout, "%02X ", bytes[j] );
			    if( j%16==15 )
				fprintf( stdout, "\n" );
			}
			if( j&15 )
				fprintf( stdout, "\n" );
		    }
//		    fprintf( stdout, "skip=%d @ 0x%X\n", skip, g_addr );
#if 1
		    int writeSize = 188-skip;
#else
		    int writeSize = TsPacketSize-skip;
		    if( TsPacketSize>188 )
		    {
			writeSize = writeSize - (TsPacketSize-188);
			if( writeSize<0 )
			{
				fprintf( stdout, "Error :\n" );
			    fprintf( stdout, "writeSize = %d\n",
				writeSize );
			    exit( 1 );
			}
		    }
#endif
#ifdef ODA
fprintf( stdout, "skip=%d, writeSize=%d, %d\n", skip, writeSize, TsPacketSize );
fflush( stdout );
#endif
		    if( bRecord )
		    {
			if( out_fp[PID]==NULL )
			{
			    char binFilename[1024];
			    sprintf( binFilename, "PES-%04X.bin", PID );
			    fprintf( stdout, "open(%s)\n", binFilename );
			    out_fp[PID] = fopen( binFilename, "wb" );
			    if( out_fp[PID]==NULL )
			    {
				fprintf( stdout, "Can't open bin [%s]\n",
				    binFilename );
				exit( 1 );
			    }
			}
			if( addr_fp[PID]==NULL )
			{
			    char addrFilename [1024];
			    sprintf( addrFilename , "PES-%04X.txt", PID );
			    fprintf( stdout, "open(%s)\n", addrFilename );
			    addr_fp[PID] = fopen( addrFilename, "wb" );
			    if( addr_fp[PID]==NULL )
			    {
				fprintf( stdout, "Can't open addr [%s]\n",
				    addrFilename );
				exit( 1 );
			    }
			    fprintf( addr_fp[PID], "%s\n", filename );
			}
			//
#if 0
			if( writeSize>0 )
			if( writeSize!=0xB8 )
			{
				fprintf( stdout, "writesSize=%d @0x%X\n",
					writeSize, g_addr );
				exit( 1 );
			}
#endif
			if( writeSize>0 )
			{
			    unsigned long long LL = PCR_H;
			    LL = (LL<<32) | PCR_L;
			    LL = LL>>15;
			    fprintf( addr_fp[PID], 
				"%8X, %8X, %8X, %4X, %8X %8X %9llX\n", 
#if 1
				g_addr-TsPacketSize,	// TS addr(top)
//				g_addr-writeSize, 	// TS addr(pes start)
				g_addr-TsPacketSize+skip,// TS addr(pes start)
				nAddr[PID], 		// PES addr
				writeSize,		// PES size
#endif
				PCR_H, PCR_L, LL );
			    int written = fwrite( &byteS[skip], 
				    writeSize, 1, out_fp[PID] );
			    if( written<1 )
			    {
				fprintf( stdout, "Can't write %s (%d)\n", 
				    outfile, writeSize );
				break;
			    } else {
				if( bWriteMsg )
				{
				fprintf( stdout, "%5d : %04X : %d : ", 
				    i, PID, adapt );
				fprintf( stdout, "%d written\n", writeSize );
				}
			    }
			} else {
			    if( bPrint )
			    {
			    fprintf( stdout, "%5d : %04X : %d : ", 
			    	i, PID, adapt );
			    fprintf( stdout, "No write data\n" );
			    }
			}
		    }
		    if( writeSize>0 )
		    {
			nAddr[PID] += writeSize;
			nLast[PID] = g_addr;
		    }
		}
	    }
	    if( editfile )
	    {
	    	int written=(-1);
	    	if( mode<0 )	// PCR update/CUT_END
		{
		} else {
//		    if( (PID==pid)
		    if( bPidMatch
		     || (PID<2) )
		    {
		    } else {
			if( bRemoveOtherPacket )
			{
			    memset( bytes, TsPacketSize, 0xFF );
			    byteS[0] = 0x47;
			    byteS[1] = 0x1F;
			    byteS[2] = 0xFF;
			    byteS[3] = 0x1F;
			}
		    }
		}
#if 0
		if( mode==(-2) )
		fprintf( stdout, "nLastAll=%8X\n", nLastAll );
#endif
		if( (bCutEnd==0) || (nLastAll>=g_addr) )
		{
		    written = fwrite( bytes, TsPacketSize, 1, edit );
		    if( written<1 )
		    {
			fprintf( stdout, "Can't write %s\n", editfile );
			break;
		    }
		}
	    }
	}
	for( i=0; i<MAX_PID; i++ )
	{
	    if( out_fp[i] )
		fclose( out_fp[i] );
	    if( addr_fp[i] )
		fclose( addr_fp[i] );
	}
	if( edit )
	    fclose( edit );
	fclose( ts_fp );
	nLastAll = 0;
	for( i=0; i<MAX_PID; i++ )
	{
	    if( nCount[i]>0 )
		fprintf( stdout, "PID(%04X) : nCount  =%d\n", i, nCount[i] );
	    if( nPayload[i]>0 )
		fprintf( stdout, "PID(%04X) : nPayload=%d\n", i, nPayload[i] );
	    if( nAddr[i]>0 )
	    {
		fprintf( stdout, "PID(%04X) : nAddr   =%8X(%8d) %8X\n", 
			i, nAddr[i], nAddr[i], nLast[i] );
		if( i<0x1FFF )
		    if( nLast[i]>nLastAll )
		    	nLastAll = nLast[i];
	    }
	}
	fprintf( stdout, "nLastAll=%8X\n", nLastAll );
	if( nSyncError>0 )
	    fprintf( stdout, "Sync Error = %d\n", nSyncError );
	if( pcr_fp )
	    fclose( pcr_fp );
	if( tts_fp )
	    fclose( tts_fp );
	
	// -----------------------------------------
	// get All PTS
	int IDS[MAX_PID];
	int nID=0;
	initTsAddr( );
	for( i=1; i<(MAX_PID-1); i++ )
	{
	    if( addr_fp[i] )
	    {
	    	FILE *pts_fp, *bin_fp;
	    	char binFile[1024];
	    	char txtFile[1024];
		char ptsFile[1024];
		sprintf( binFile, "PES-%04X.bin", i );
		sprintf( txtFile, "PES-%04X.txt", i );
		sprintf( ptsFile, "PES-%04X.pts", i );
	    	fprintf( stdout, "Parse [%s]\n", filename );
		int nTS=0;
		char tsFilename[1024];
		if( ReadAddrFile( txtFile, tsFilename, TsAddr, PesAddr,
		    &nTS, ADDR_MAX )<0 )
		    exit( 1 );
		bin_fp = fopen( binFile, "r" );
		if( bin_fp==NULL )
		{
		    fprintf( stdout, "Can't open [%s]\n", binFile );
		    exit( 1 );
		}
		fprintf( stdout, "bin[%s]\n", binFile );
		pts_fp = fopen( ptsFile, "w" );
		if( pts_fp==NULL )
		{
		    fprintf( stdout, "Can't open [%s]\n", ptsFile );
		    exit( 1 );
		}
		fprintf( stdout, "Pts[%s]\n", ptsFile );
		if( ParsePts( bin_fp, pts_fp )>0 )
		{
		    IDS[nID++] = i;
		}
		fclose( bin_fp );
		fclose( pts_fp );
	    }
	}
	FILE *fp;
	int p;
	char buffer[1024];
	FILE *out = fopen( "PCR-PTS.txt", "w" );
	if( out==NULL )
	{
	    fprintf( stdout, "Can't open PCR-PTS.txt\n" );
	    exit( 1 );
	}
	fprintf( out, "%10s,%10s,", "bytes", "PCR" );
	for( p=0; p<nID; p++ )
	{
	    fprintf( out, "PES-%04X  ,", IDS[p] );
	}
	fprintf( out, "\n" );
	fp = fopen( "PCR.txt", "r" );
	if( fp==NULL )
	{
	    fprintf( stdout, "Can't open PCR.txt\n" );
	    exit( 1 );
	}
	if( fp )
	{
	    while( 1 )
	    {
	    	long long ADDR, PCR;
		int pid, pcr_h, pcr_l;
	    	if( fgets( buffer, 1024, fp )==NULL )
		    break;
		sscanf( buffer, "%8X : %04X : %08X,%08X %09llX\n",
			&ADDR, &pid, &pcr_h, &pcr_l, &PCR );
		fprintf( out, "%10d,%10d,", ADDR, PCR );
		for( i=0; i<nID; i++ )
		{
#if 0
		    fprintf( out, "          ,", i );
#else
		    fprintf( out, ",", i );
#endif
		}
		fprintf( out, "\n" );
	    }
	    fclose( fp );
	}
	fprintf( stdout, "PCR done\n" );
	for( p=0; p<nID; p++ )
	{
	    char ptsFilename[1024];
	    sprintf( ptsFilename, "PES-%04X.pts", IDS[p] );
	    fprintf( stdout, "open(%s)\n", ptsFilename );
	    fflush( stdout );
	    fp = fopen( ptsFilename, "r" );
	    if( fp==NULL )
	    {
	    	fprintf( stdout, "Can't open %s\n", ptsFilename );
		exit( 1 );
	    }
	    fgets( buffer, 1024, fp );
	    while( 1 )
	    {
	    	if( fgets( buffer, 1024, fp )==NULL )
		    break;
		int ts_addr_top, ts_addr, pes_addr, size;
		int ptsH, ptsL;
		int dtsH, dtsL;
		sscanf( (char *)buffer, "%8X %8X : %4X %8X, %4X %8X",
		    &pes_addr, &ts_addr, &ptsH, &ptsL, &dtsH, &dtsL );
#if 0
		fprintf( stdout, "%s", buffer );
		fprintf( stdout, "%X,%X,%X,%X\n", 
			pes_addr, ts_addr, ptsH, ptsL );
#endif
#if 0
		fprintf( out, "%10d,          ,", ts_addr );
#else
		fprintf( out, "%10d,,", ts_addr );
#endif
		for( i=0; i<p; i++ )
		{
#if 0
		    fprintf( out, "          ,", i );
#else
		    fprintf( out, ",", i );
#endif
		}
		fprintf( out, "%10d,", ptsL );
		for( i=p+1; i<nID; i++ )
		{
#if 0
		    fprintf( out, "          ,", i );
#else
		    fprintf( out, ",", i );
#endif
		}
		fprintf( out, "\n" );
	    }
	    fclose( fp );
	}
	fclose( out );

	return 0;
}

int TsTest( char filename[], char outFilename[], int start, int pid )
{
FILE *fp=NULL;
unsigned char bytes[1024*4];
int readed;
int PID=(-1);
int PCR_H=(-1);
int PCR_L=(-1);
int i;
struct stat Stat;
FILE *edit=NULL;
FILE *out_fp [MAX_PID];
int bPayload [MAX_PID];
int nPayload [MAX_PID];
int nCount   [MAX_PID];
int nAddr    [MAX_PID];
int 	     Lcount[MAX_PID];
static char outfile[] = "PES.bin";
int bRecord=0;
int bPrint=1;
	for( i=0; i<MAX_PID; i++ )
	{
	    out_fp  [i] = NULL;
	    bPayload[i] = 0;
	    nPayload[i] = 0;
	    nCount  [i] = 0;
	    nAddr   [i] = 0;
	    Lcount  [i] = (-1);
	}
	if( stat( filename, &Stat )!=0 )
	{
	    fprintf( stdout, "Can't stat %s\n", filename );
	    exit( 1 );
	}
	int size = (int)Stat.st_size;
//	int packets = size/TS_PACKET_SIZE;
	int packets = size/TsPacketSize;
	fprintf( stdout, "size=%d, packets=%d\n", size, packets );
	fp = fopen ( filename, "rb" );
	if( fp==NULL )
	{
	    fprintf( stdout, "Can't open %s\n", filename );
	    exit( 1 );
	}
	for( i=0; ; i++ )
	{
	    if( (i%10000)==0 )
	    {
		if( bDebug )
		    fprintf( stdout, "\r%d ", i );
    //		    fprintf( stdout, "*" );
		fflush( stdout );
	    }
	    readed = gread( bytes, TsPacketSize, 1, fp );
	    if( readed<1 )
	    {
		fprintf( stdout, "\nEOF@%d(addr=0x%X,%d)\n", 
			i, g_addr, g_addr );
		break;
	    }
	    if( bytes[0]==0x47 )
		PID = ((bytes[1]<<8) | (bytes[2]<<0)) & 0x1FFF;
	    else {
	    	PID = 0xFFFF;
		fprintf( stdout, "Invalid Sync Byte(%02X)\n", bytes[0] );
	    }
	    int ts_error     = (bytes[1]>>7)&1;
	    int payloadStart = (bytes[1]>>6)&1;
	    int ts_priority  = (bytes[1]>>5)&1;
	    int adapt = (bytes[3]>>4)&3;
	    int count = bytes[3]&15;
	    int adapt_len = bytes[4];
	    int bOut=0;
	    int skip=0;
	    int bAdapt  =0;
	    if( (PID==pid) || (pid<0) )
	    {
	    	switch( adapt )
		{
		case 0 :	// ?
		    fprintf( stdout, "adapt=%d\n", adapt );
		    break;
		case 1 :	// no adapt
		    bPayload[PID]=1;
		    bAdapt  =0;
		    break;
		case 2 :	// adapt
		    bPayload[PID]=0;
		    bAdapt  =1;
		    break;
		case 3 :	// adapt+payload
		    bPayload[PID]=1;
		    bAdapt  =1;
		    break;
		default :
		    fprintf( stdout, "Invalid adapt(%d)\n", adapt );
		    exit( 1 );
		    break;
		}
		skip+=4;	// Header 4byte
		if( PID==0x1FFF )
		{
#if 0
		    fprintf( stdout, 
			    "%5d : %04X : %X,%X : ", i, PID, adapt, count );
		    fprintf( stdout, "\n" );
#endif
		} else {
		    if( bAdapt )
		    {
		    	if( bPrint )
			fprintf( stdout, 
			    "%5d : %04X : %X,%X : ", i, PID, adapt, count );
			bOut++;
			int flag = bytes[5];
			int bPCR  = flag & (1<<4);
			int bOPCR = flag & (1<<3);
			int bSPR  = flag & (1<<2);
			int bPRV  = flag & (1<<1);
			int bEXT  = flag & (1<<0);
			if( bPrint )
			{
			    if( bPCR )
			    {
				PCR_H = (bytes[ 6]<< 8) | (bytes[ 7]<< 0);
				PCR_L = (bytes[ 8]<<24) | (bytes[ 9]<<16)
				      | (bytes[10]<< 8) | (bytes[11]<< 0);
				fprintf( stdout, 
				    "%02X (%02X) PCR : %08X,%08X : ", 
				    adapt_len, flag, PCR_H, PCR_L );
			    } else {
				fprintf( stdout, "%02X (%02X) (No PCR) : ",
				    adapt_len, flag );
			    }
			}
			skip+=(1+adapt_len);
			if( Lcount[PID]>=0 )
			{
#if 1
			    if( bCheckContinuous )
			    if( ((Lcount[PID]+0)&15)!=count )
			    {
				fprintf( stdout, 
				"*** Update(%d:%d) ***\n", Lcount[PID], count );
				bytes[3] = bytes[3] & 0xF0 | Lcount[PID];
			    }
#else
			    bytes[3] = bytes[3] & 0xF0 | Lcount[PID];
#endif
			}
		    }
		    if( bPayload[PID] )
		    {
			nPayload[PID]++;
			if( payloadStart )
			{
			    if( bPrint )
			    {
				if( bOut==0 )
				fprintf( stdout, "%5d : ", i );
				fprintf( stdout, "Payload Start\n", i );
			    }
			    bOut=0;
			} else {
			}
		    }
		}
		if( bOut )
		{
		    if( bPrint )
		    fprintf( stdout, "\n" );
		    bOut=0;
		}
	    }
	}
	fclose( fp );
	return 0;
}

int GetTable( unsigned char **ptr,
	int *pTableID,
	int *pSecLen,
	int *pID,
	int *pSecNo,
	int *pLsecNo )
{
unsigned char *bytes = *ptr;
	//
	int section, ID;
	int tableID = *(bytes++);		// 5
	section = *(bytes++);			// 6
	section = (section<<8) | *(bytes++);	// 7
	int secLen = section & 0xFFF;
	if( (section>>12) != 0xB )
	{
	    fprintf( stdout, "Invalid section (%4X)\n", section );
	    return -1;
	}
	ID = *(bytes++);			// 8
	ID = (ID<<8) | *(bytes++);		// 9
	int version = *(bytes++);		// 10
	int secNo   = *(bytes++);		// 11
	int LsecNo  = *(bytes++);		// 12
	//
	*pTableID = tableID;
	*pSecLen = secLen;
	*pID = ID;
	*pSecNo = secNo;
	*pLsecNo = LsecNo;
	*ptr = bytes;
	return 0;
}

int DumpPAT( unsigned char *ptr )
{
	int tableID, secLen, TSID, secNo, LsecNo;
	if( GetTable( &ptr, 
		&tableID, &secLen, &TSID, &secNo, &LsecNo )<0 )
	    return -1;
	fprintf( stdout, "Table=%02X, Len=%4X, TSID=%04X (%02X:%02X)\n",
		tableID, secLen, TSID, secNo, LsecNo );
	int j;
	secLen-=8;
	for( j=0; j<(secLen-4); j+=4 )
	{
	    int programNo, PMT_PID;
	    programNo = *(ptr++);
	    programNo = (programNo<<8) | *(ptr++);
	    PMT_PID   = *(ptr++);
	    PMT_PID   = (PMT_PID  <<8) | *(ptr++);
	    fprintf( stdout, "Program = %04X, PMT_PID=%04X\n",
		programNo, PMT_PID & 0x1FFF );
	}
	int CRC;
	CRC = *(ptr++);
	CRC = (CRC<<8) | *(ptr++);
	CRC = (CRC<<8) | *(ptr++);
	CRC = (CRC<<8) | *(ptr++);
	fprintf( stdout, "CRC=%08X\n", CRC );
	return 0;
}

void DumpPMT( unsigned char *ptr )
{
int j, k;
int secPos=1;
	int tableID, secLen, PGMID, secNo, LsecNo;
	GetTable( &ptr, 
		&tableID, &secLen, &PGMID, &secNo, &LsecNo );
	fprintf( stdout, "Table=%02X, Len=%4X, PGMID=%04X (%02X:%02X)\n",
		tableID, secLen, PGMID, secNo, LsecNo );
	secPos+=8;
//	fprintf( stdout, "secPos=%d, secLen=%d\n", secPos, secLen );
	int PCR_PID, PGM_info;
	PCR_PID = *(ptr++);
	PCR_PID = (PCR_PID<<8) | *(ptr++);
	PGM_info = *(ptr++);
	PGM_info = (PGM_info<<8) | *(ptr++);
	if( (PCR_PID & 0xE000)!=0xE000 )
	    fprintf( stdout, "Invalid PCR_PID(%X)\n", PCR_PID );
	if( (PGM_info & 0xF000)!=0xF000 )
	    fprintf( stdout, "Invalid PGM_info(%X)\n", PGM_info );
	secPos+=4;
	PCR_PID  = PCR_PID  & 0x1FFF;
	PGM_info = PGM_info & 0x0FFF;
	fprintf( stdout, "PCR_PID=%04X, PGM_info=%04X : ",
		PCR_PID, PGM_info );
	for( j=0; j<PGM_info; j++ )
	{
	    fprintf( stdout, "%02X ", *(ptr++) );
	    secPos++;
	}
	fprintf( stdout, "\n" );
//	fprintf( stdout, "secPos=%d, secLen=%d\n", secPos, secLen );
	for( secPos; secPos<secLen; )
	{
	    int streamType, elemPID, ES_len;
	    streamType = *(ptr++);
	    elemPID    = *(ptr++);
	    elemPID    = (elemPID<<8) | *(ptr++);
	    ES_len     = (*ptr++);
	    ES_len     = (ES_len <<8) | *(ptr++);
	    secPos+=5;
	    if( (elemPID&0xE000)!=0xE000 )
	    	fprintf( stdout, "Invalid elemPID(%X)\n", elemPID );
	    if( (ES_len&0xF000)!=0xF000 )
	    	fprintf( stdout, "Invalid ES_len(%X)\n", ES_len );
	    elemPID = elemPID & 0x1FFF;
	    ES_len  = ES_len  & 0x0FFF;
	    fprintf( stdout, "StrmType=%02X, PID=%04X, info=%02X : ",
	    	streamType, elemPID, ES_len );
	    for( int k=0; k<ES_len; k++ )
	    {
	    	fprintf( stdout, "%02X ", *(ptr++) );
		secPos++;
	    }
	    fprintf( stdout, "\n" );
//	    fprintf( stdout, "secPos=%d, secLen=%d\n", secPos, secLen );
	}
	int CRC;
	CRC = *(ptr++);
	CRC = (CRC<<8) | *(ptr++);
	CRC = (CRC<<8) | *(ptr++);
	CRC = (CRC<<8) | *(ptr++);
	fprintf( stdout, "CRC=%08X\n", CRC );
}

int TsPAT( char filename[] )
{
FILE *fp=NULL;
unsigned char bytes[1024*4];
int readed;
int PID=(-1);
int i;
struct stat Stat;
int total=0;
	if( stat( filename, &Stat )!=0 )
	{
	    fprintf( stdout, "Can't stat %s\n", filename );
	    exit( 1 );
	}
	int size = (int)Stat.st_size;
//	int packets = size/TS_PACKET_SIZE;
	int packets = size/TsPacketSize;
	fprintf( stdout, "size=%d, packets=%d\n", size, packets );
	fp = fopen ( filename, "rb" );
	if( fp==NULL )
	{
	    fprintf( stdout, "Can't open %s\n", filename );
	    exit( 1 );
	}
	for( i=0; ; i++ )
	{
	    if( (i%10000)==0 )
	    {
		if( bDebug )
		    fprintf( stdout, "\r%d ", i );
    //		    fprintf( stdout, "*" );
		fflush( stdout );
	    }
	    readed = gread( bytes, TsPacketSize, 1, fp );
	    if( readed<1 )
	    {
		fprintf( stdout, "\nEOF@%d(addr=0x%X,%d)\n", 
			i, g_addr, g_addr );
		break;
	    }
	    if( bytes[0]==0x47 )
		PID = ((bytes[1]<<8) | (bytes[2]<<0)) & 0x1FFF;
	    int adapt = (bytes[3]>>4)&3;
	    int count = bytes[3]&15;
	    int adapt_len = bytes[4];
	    if( PID==0x0000 )	// PAT
	    {
//		fprintf( stdout, "adapt=%d, count=%d, adapt_len=%d\n",
//		    adapt, count, adapt_len );
		fprintf( stdout, "PID = %04X (%X)\n", PID, total );
		if( adapt_len==0 )
		    DumpPAT( &bytes[5] );
		else
		    DumpPAT( &bytes[5+adapt_len+1] );
	    } 
	    total += TsPacketSize;
	}
	fclose( fp );
	return 0;
}

int TsPMT( char filename[], int pids[MAX_PIDS], int nPid )
{
FILE *fp=NULL;
unsigned char bytes[1024*4];
int readed;
int PID=(-1);
int i;
struct stat Stat;
int total=0;
	if( stat( filename, &Stat )!=0 )
	{
	    fprintf( stdout, "Can't stat %s\n", filename );
	    exit( 1 );
	}
	int size = (int)Stat.st_size;
//	int packets = size/TS_PACKET_SIZE;
	int packets = size/TsPacketSize;
	fprintf( stdout, "size=%d, packets=%d\n", size, packets );
	fp = fopen ( filename, "rb" );
	if( fp==NULL )
	{
	    fprintf( stdout, "Can't open %s\n", filename );
	    exit( 1 );
	}
	for( i=0; ; i++ )
	{
	    if( (i%10000)==0 )
	    {
		if( bDebug )
		    fprintf( stdout, "\r%d ", i );
    //		    fprintf( stdout, "*" );
		fflush( stdout );
	    }
	    readed = gread( bytes, TsPacketSize, 1, fp );
	    if( readed<1 )
	    {
		fprintf( stdout, "\nEOF@%d(addr=0x%X,%d)\n", 
			i, g_addr, g_addr );
		break;
	    }
	    if( bytes[0]==0x47 )
		PID = ((bytes[1]<<8) | (bytes[2]<<0)) & 0x1FFF;
	    int adapt = (bytes[3]>>4)&3;
	    int count = bytes[3]&15;
	    int adapt_len = bytes[4];
	    int bDump = 0;
	    int n;
	    for( n=0; n<nPid; n++ )
	    {
		if( PID==pids[n] )	// PMT
		    bDump = 1;
	    }
	    if( bDump )	
	    {
	    	unsigned char *nPtr = &bytes[5];
	    	if( adapt & 2 )
		{
		    fprintf( stdout, "adapt_len = %d\n", adapt_len );
		    nPtr = &bytes[5+adapt_len+1];
		}
		fprintf( stdout, "PID = %04X (%X)\n", PID, total );
	    	DumpPMT( nPtr );
	    } 
	    total += TsPacketSize;
	}
	fclose( fp );
	return 0;
}

int TsPid( char filename[] )
{
FILE *fp=NULL;
unsigned char bytes[1024*4];
int readed;
int PID=(-1);
int i;
int PIDs[MAX_PID];
struct stat Stat;
	for( i=0; i<MAX_PID; i++ )
	    PIDs[i] = 0;
	if( stat( filename, &Stat )!=0 )
	{
	    fprintf( stdout, "Can't stat %s\n", filename );
	    exit( 1 );
	}
	int size = (int)Stat.st_size;
//	int packets = size/TS_PACKET_SIZE;
	int packets = size/TsPacketSize;
	fprintf( stdout, "size=%d, packets=%d\n", size, packets );
	fp = fopen ( filename, "rb" );
	if( fp==NULL )
	{
	    fprintf( stdout, "Can't open %s\n", filename );
	    exit( 1 );
	}
	for( i=0; ; i++ )
	{
	    if( (i%10000)==0 )
	    {
		if( bDebug )
		    fprintf( stdout, "\r%d ", i );
    //		    fprintf( stdout, "*" );
		fflush( stdout );
	    }
	    readed = gread( bytes, TsPacketSize, 1, fp );
	    if( readed<1 )
	    {
		fprintf( stdout, "\nEOF@%d(addr=0x%X,%d)\n", 
			i, g_addr, g_addr );
		break;
	    }
	    if( bytes[0]==0x47 )
		PID = ((bytes[1]<<8) | (bytes[2]<<0)) & 0x1FFF;
	    if( PIDs[PID]==0 )
	    {
		fprintf( stdout, "PID = %04X\n", PID );
	    }
	    PIDs[PID]++;
	}
	fclose( fp );
	fprintf( stdout, "-----------------------------------------------\n" );
	for( i=0; i<MAX_PID; i++ )
	{
	    if( PIDs[i]>0 )
	    {
		fprintf( stdout, "PID = %04X : %8d packets\n", i, PIDs[i] );
	    }
	}
	return 0;
}


#define MAX 1000	// 0-1000 

int TsCut( char *filename, char *outfile, int start, int end, int len )
{
struct stat Stat;
FILE *fp=NULL;
FILE *out=NULL;
long long ll;
int i;
//unsigned char bytes[TS_PACKET_SIZE+1];
unsigned char bytes[1024];
	if( TsPacketSize>1023 )
	{
	    fprintf( stdout, "Too large TsPacketSize(%d)\n",
		    TsPacketSize );
	    exit( 1 );
	}
	if( filename==NULL )
	{
	    fprintf( stdout, "Invaid filename\n" );
	    return -1;
	}
	if( outfile==NULL )
	{
	    fprintf( stdout, "Invaid outfile\n" );
	    return -1;
	}

	// File size
	if( stat( filename, &Stat )!=0 )
	{
	    fprintf( stdout, "Can't stat %s\n", filename );
	    return -1;
	}
	int size = (int)Stat.st_size;
//	int packets = size/TS_PACKET_SIZE;
	int packets = size/TsPacketSize;
	int st=(-1), en=(-1);
	fprintf( stdout, "size=%d, packets=%d\n", size, packets );

	if( (start>=0) && (end>=0) )
	{	// unit is percentage
	    if( (start>0) && (end>0) )
		len = end-start;
	    else if( (start>0) && (len>0) )
		end = start+len;
	    else if( (end>0) && (len>0) )
		start = end-len;
	    if( (start<0) || (start>MAX) )
	    {
		fprintf( stdout, "Invalid start (%d)\n", start );
		fprintf( stdout, 
		    "Start and End 's unit is 1/10 percentage (0-1000)\n" );
		return -1;
	    }
	    if( (end<0) || (end>MAX) )
	    {
		fprintf( stdout, "Invalid end (%d)\n", end );
		return -1;
	    }
	    if( end<=start )
	    {
		fprintf( stdout, "Invalid start/end (%d,%d)\n", start, end );
		return -1;
	    }
	    ll = packets;
	    st = ll*start/MAX;
	    ll = packets;
	    en = ll*end/MAX;
	    fprintf( stdout, "St(%5d/10 %) : %8d\n", start, st );
	    fprintf( stdout, "En(%5d/10 %) : %8d\n", end  , en );
	} else if( (start<=0) && (end<0) )
	{	// unit is packet
	    start = -start;
	    end   = -end;
	    if( (start>0) && (end>0) )
		len = end-start;
	    else if( (start>0) && (len>0) )
		end = start+len;
	    else if( (end>0) && (len>0) )
		start = end-len;
	    if( end<=start )
	    {
		fprintf( stdout, "Invalid start/end (%d,%d)\n", start, end );
		return -1;
	    }
	    fprintf( stdout, "start=%d\n", start );
	    fprintf( stdout, "end  =%d\n", end   );
	    st = start;
	    en = end;
	    fprintf( stdout, "St : %8d\n", st );
	    fprintf( stdout, "En : %8d\n", en );
	}

	fprintf( stdout, "output file=%s\n", outfile );
	fp = fopen ( filename, "rb" );
	if( fp==NULL )
	{
	    fprintf( stdout, "Can't open %s\n", filename );
	    return -1;
	}
	for( i=0; i<st; i++ )
	{
//	    fseek( fp, TS_PACKET_SIZE,  SEEK_CUR );
	    fseek( fp, TsPacketSize,  SEEK_CUR );
	}
	out = fopen( outfile, "wb" );
	if( out==NULL )
	{
	    fprintf( stdout, "Can't write %s\n", outfile );
	    fclose( fp );
	    return -1;
	}
	if( en==packets )
	    en++;
//	for( ; i<=en; i++ )
	for( ; i<en; i++ )
	{
//	    int readed = gread( bytes, TS_PACKET_SIZE, 1, fp );
	    int readed = gread( bytes, TsPacketSize, 1, fp );
	    if( readed<1 )
	    {
		fprintf( stdout, "\nEOF@%d(addr=0x%X,%d)\n", 
			i, g_addr, g_addr );
		break;
	    }
//	    int written = fwrite( bytes, TS_PACKET_SIZE, 1, out );
	    int written = fwrite( bytes, TsPacketSize, 1, out );
	    if( written<1 )
	    {
	    	fprintf( stdout, "Can't write %s\n", outfile );
		break;
	    }
	}

	fclose( fp );
	fclose( out );
	return 0;
}

int TsOff( char *filename, char *outfile, int pids[MAX_PIDS] )
{
FILE *fp=NULL;
FILE *out=NULL;
unsigned char bytes[1024*4];
unsigned char off  [1024];
int readed;
int PID=(-1);
int i;
int PIDs [MAX_PID];
int PIDon[MAX_PID];
struct stat Stat;

	fprintf( stdout, "TsOff(%s,%s)\n", filename, outfile );
	if( outfile==NULL )
	{
	    fprintf( stdout, "Invaid outfile\n" );
	    return -1;
	}
	if( strcmp( filename, outfile )==0 )
	{
	    fprintf( stdout, "Src and Dst is same ?\n" );
	    exit( 1 );
	}
	for( i=0; i<1024; i++ )
	    off[i] = 0xFF;
	off[0] = 0x47;
	off[1] = 0x1F;
	off[2] = 0xFF;
	off[3] = 0x10;

	for( i=0; i<MAX_PID; i++ )
	{
	    PIDs [i] = 0;
	    PIDon[i] = 0;
	}
	for( i=0; i<MAX_PIDS; i++ )
	{
	    if( pids[i]<0 )
		break;
	    PIDon[pids[i]] = 1;
	}
	PIDon[0x0000] = 1;
	PIDon[0x1FFF] = 1;
	if( stat( filename, &Stat )!=0 )
	{
	    fprintf( stdout, "Can't stat %s\n", filename );
	    exit( 1 );
	}
	int size = (int)Stat.st_size;
//	int packets = size/TS_PACKET_SIZE;
	int packets = size/TsPacketSize;
	fprintf( stdout, "size=%d, packets=%d\n", size, packets );
	fp = fopen ( filename, "rb" );
	if( fp==NULL )
	{
	    fprintf( stdout, "Can't open %s\n", filename );
	    return -1;
	}
	out = fopen( outfile, "wb" );
	if( out==NULL )
	{
	    fprintf( stdout, "Can't write %s\n", outfile );
	    fclose( fp );
	    return -1;
	}
	int total=0;
	for( i=0; ; i++ )
	{
	    if( (i%10000)==0 )
	    {
		if( bDebug )
		    fprintf( stdout, "\r%d ", i );
    //		    fprintf( stdout, "*" );
		fflush( stdout );
	    }
	    readed = gread( bytes, TsPacketSize, 1, fp );
	    if( readed<1 )
	    {
		fprintf( stdout, "\nEOF@%d(addr=0x%X,%d)\n", 
			i, g_addr, g_addr );
		break;
	    }
	    if( bytes[0]==0x47 )
		PID = ((bytes[1]<<8) | (bytes[2]<<0)) & 0x1FFF;
	    if( PIDs[PID]==0 )
	    {
		fprintf( stdout, "PID = %04X\n", PID );
	    }
	    PIDs[PID]++;
	    int written;
	    int bCopy=0;
	    if( PIDon[PID] )
	    	written = fwrite( bytes, 1, TsPacketSize, out ); 
	    else 
	    	written = fwrite( off, 1, TsPacketSize, out ); 

	    if( written<1 )
	    {
	    	fprintf( stdout, "Can't write (0x%X)\n", total );
		break;
	    }
	    total+=written;
	}
	fclose( fp );
	fclose( out );
	fprintf( stdout, "-----------------------------------------------\n" );
/*
	for( i=0; i<MAX_PID; i++ )
	{
	    if( PIDs[i]>0 )
	    {
		fprintf( stdout, "PID = %04X : %8d packets\n", i, PIDs[i] );
	    }
	}
*/

	return 0;
}
int main( int argc, char *argv[] )
{
int i;
int args=0;
char *srcFilename=NULL;
char *outFilename=NULL;
int mode = MODE_ADDR;
int start=0;
int end=0;
int len=(-1);
int pid = 0x21;
int Error=0;
int pids[MAX_PIDS];
int nPid=0;
int nTsSize=0;
int targetAddr=(-1);
int targetSize=(-1);
int firstSync=(-1);

	for( i=0; i<MAX_PIDS; i++ )
	{
	    pids[i] = (-1);
	}

	for( i=1; i<argc; i++ )
	{
	    if( argv[i][0]=='-' )
	    {
	    	switch( argv[i][1] )
		{
		    case 'V' :
		    	bDebug = 1;
			break;
		    case 'a' :
		    	bAll = 1;
			break;
		    case 's' :
		    	bShowAddr = 1;
			break;
		    case 'e' :
			EndPts = GetValue( &argv[i][2], Error );
			break;

		    case 'D' :
		    	mode = MODE_DUMP;
			break;
		    case 'd' :
		    	mode = MODE_DUMP2;
			break;
		    case 'r' :
		    	mode = MODE_DUMP3;
			break;
		    case 'P' :
		    	mode = MODE_PID;
			break;
		    case 'A' :
		    	mode = MODE_PAT;
			break;
		    case 'M' :
		    	mode = MODE_PMT;
			break;
		    case 'C' :
		    	mode = MODE_CUT;
			break;
		    case 'O' :
		    	mode = MODE_OFF;
			break;
		    case 't' :
		    	mode = MODE_TEST;
			break;
		    case 'w' :
		    	mode = MODE_PCR_ANALYZE;
			break;
		    case 'W' :
		    	mode = MODE_PCR_UPDATE;
			PcrOffset = GetValue( &argv[i][2], Error );
			break;
		    case 'c' :
		    	mode = MODE_CUT_END;
		    	bCutEnd = 1;
		    	break;
		    case 'T' :
		    	nTsSize = GetValue( &argv[i][2], Error );
		    	break;
		    case 'p' :
		    	if( nPid>MAX_PIDS )
			{
			    fprintf( stdout, "Too large nPid(%d)\n", nPid );
			    Usage( argv[0] );
			}
		    	pids[nPid++] = GetValue( &argv[i][2], Error );
		    	break;
		    case 'S' :
		    	start = atoi( &argv[i][2] );
		    	break;
		    case 'E' :
		    	end = atoi( &argv[i][2] );
		    	break;
		    case 'L' :
		    	len = atoi( &argv[i][2] );
		    	break;
		    case 'R' :
		    	bRemoveOtherPacket = 1;
		    	break;
		    default :
		    	Usage( argv[0] );
			break;
		}
	    } else if( argv[i][0]=='+' )
	    {
	    	switch( argv[i][1] )
		{
		    case 'P' :
			bPrintPCR=1;
			break;
		    case 'C' :
		    	bCheckContinuous = 1;
			break;
		    case 'W' :
		    	bWriteMsg = 1;
			break;
		    case 'A' :
		    	targetAddr = GetValue( &argv[i][2], Error );
		    	break;
		    case 'S' :
		    	targetSize = GetValue( &argv[i][2], Error );
		    	break;
		    default :
		    	Usage( argv[0] );
			break;
		}
	    } else {
	    	switch( args )
		{
		case 0 :
		    srcFilename = argv[i];
		    break;
		case 1 :
		    outFilename = argv[i];
		    break;
		}
		args++;
	    }
	}
	if( nTsSize>0 )
	{
	    TsPacketSize = nTsSize;
	} else {
	    if( (mode!=MODE_ADDR) )
	    {
		char buffer[512];
		FILE *fp = fopen( srcFilename, "rb" );
		if( fp==NULL )
		{
		    fprintf( stdout, "Can't open src[%s]\n", srcFilename );
		    exit( 1 );
		}
		int readed = gread( (unsigned char *)buffer, 512, 1, fp );
		if( readed<1 )
		{
		    fprintf( stdout, "Can't read\n" );
		    exit( 1 );
		} else {
		    if( buffer[0]==0x47 )
		    {
		    	firstSync=0;
		    } else {
			fprintf( stdout, "first bytes isn'5 0x47 (%02X)\n",
			    buffer[0] );
			for( i=0; i<256; i++ )
			{
			    if( buffer[i]==0x47 )
			    {
			    	fprintf( stdout, "First Sync@%d\n",
				    i );
				firstSync=i;
				break;
			    }
			}
		    }
		    if( firstSync<0 )
		    {
		    	fprintf( stdout, "NoSync\n" );
			exit( 1 );
		    }
		    {
			int s;
			for( s=188; s<256; s++ )
			{
			    if( buffer[firstSync+s]==0x47 )
			    {
				fprintf( stdout, "TsPacketSize = %d\n", s );
				TsPacketSize = s;
				if( TsPacketSize!=188 )
				{
				    fprintf( stderr, "TsPacketSize=%d\n",
				    	TsPacketSize );
				}
				break;
			    }
			}
		    }
		}
		fclose( fp );
		fprintf( stdout, "TsPacketSize=%d\n", TsPacketSize );
		g_addr = 0;
	    }
	}
	if( targetAddr>=0 )
	{
//	    unsigned char bytes[TS_PACKET_SIZE+1];
	    unsigned char bytes[1024];
	    if( TsPacketSize>1023 )
	    {
	    	fprintf( stdout, "Too large TsPacketSize(%d)\n",
			TsPacketSize );
		exit( 1 );
	    }
	    fprintf( stdout, "TargetAddr=0x%X\n", targetAddr );
	    int nA = targetAddr/TsPacketSize;
//	    int tA = (nA-1)*TsPacketSize;
	    int tA = nA*TsPacketSize;
	    fprintf( stdout, "A=0x%X\n", tA );
	    FILE *fp_read = fopen( srcFilename, "rb" );
	    if( fp_read==NULL )
	    {
	    	fprintf( stdout, "Can't open %s\n", srcFilename );
		exit( 1 );
	    }
	    FILE *fp_write = fopen( outFilename, "wb" );
	    if( fp_write==NULL )
	    {
	    	fprintf( stdout, "Can't open %s\n", outFilename );
		exit( 1 );
	    }
	    fseek( fp_read, tA, SEEK_SET );
	    int bWarning=0;
	    for( i=0; ; i++ )
	    {
	    	if( targetSize>=0 )
		if( i>=targetSize )
		    break;
		int readed = fread( bytes, TsPacketSize, 1, fp_read );
		if( readed<1 )
		{
		    fprintf( stdout, "Can't read@%d\n", i );
		    break;
		}
		int written = fwrite( bytes, TsPacketSize, 1, fp_write );
		if( written<1 )
		{
		    fprintf( stdout, "Can't write@%d\n", i );
		    break;
		}
	    }
	    fclose( fp_read );
	    fclose( fp_write );
	    return 0;
	}
	switch( mode )
	{
	case MODE_ADDR :
	    for( i=0; i<16; i++ )
	    {
		fprintf( stdout, "%2d: 0x%04X (%d)\n",
		    i, i*TS_PACKET_SIZE, i*TS_PACKET_SIZE );
	    }
	    break;
	case MODE_DUMP :
	    TsDump( srcFilename, outFilename, pids, nPid, 0 );
	    break;
	case MODE_DUMP2 :
	    TsDump( srcFilename, outFilename, pids, nPid, 1 );
	    break;
	case MODE_DUMP3 :
	    TsDump( srcFilename, outFilename, pids, nPid, 2 );
	    break;
	case MODE_PCR_ANALYZE :
	case MODE_PCR_UPDATE :
	    nPCR=0;
	    TsDump( srcFilename, outFilename, pids, nPid, 2 );
	    {
	    double d_keisu0=0;
	    int bNoCont=0;
	    int pcr_count=0;
	    unsigned long L_PCR_addr=(-1);
	    for( i=0; i<nPCR; i++ )
	    {
	    	// PCR : 33bit,6bit,9bit
		// 33bit PCR
		//  6bit reserve
		//  9bit PCR_ext
	    	unsigned long long LL = PCR_value[i];
		unsigned long LL_H = LL>>32;
		unsigned long LL_L = LL & 0xFFFFFFFF;
		unsigned long long PCR_LL = LL>>15; // 33bit
		if( PCR_PID[i]==pids[0] )
		{
		    pcr_count++;
		    if( PCR0==0xFFFFFFFF )
		    {
		    	PCR0  = PCR_LL;
			addr0 = PCR_addr[i];
			PCR1  = PCR0;
			addr1 = addr0;
		    } else {
		    	PCR1  = PCR_LL;
			addr1 = PCR_addr[i];
		    }
		    unsigned long bytes = addr1-addr0;
		    // ----- Update Here ---- //
		    unsigned long pcr_diff  = PCR1 -PCR0;
		    if( PCR1<PCR0 )
		    {
		    	unsigned long nPCR0 = (0x200000000ll-PCR0);
		    	pcr_diff = PCR1+nPCR0;
		    }
		    // ----- Update Here ---- //
//		    if( (pcr_diff>0) && (bytes>0) )
		    if( (bytes>0) )
		    {
		    	int nCR=0;
		    	double d_keisu = pcr_diff;
			d_keisu = d_keisu/bytes;
			fprintf( stdout, "%4X : %8X,%09llX(%8.8f)",
			    PCR_PID[i],
			    PCR_addr[i],
			    PCR_LL & 0x1FFFFFFFFll,
			    d_keisu );
			if( d_keisu0!=0 )
			{
			    double d_diff = d_keisu-d_keisu0;
//			    int diff = (int)(d_diff*10000000); // 4
			    int diff = (int)(d_diff*100000);
//			    if( abs(diff)>1 )
			    if( abs(diff)>2 )
			    {
			    	fprintf( stdout, ": PCR diff(%d)\n", diff );
				nCR++;
				bNoCont=1;
			    } else {
			    	if( bNoCont==0 )
				    d_keisuL = d_keisu;
				else if( d_keisuL==0 )
				    d_keisuL = d_keisu;
			    }
			}
			if( nCR==0 )
			{
			    if( L_PCR_addr>0 )
			    {
				double d_offset;
				d_offset = PCR_addr[i]-L_PCR_addr;
				d_offset = d_offset*d_keisuL;
			    	fprintf( stdout, "%8X (%4.8f)\n",
					PCR_addr[i]-L_PCR_addr, d_offset );
			    } else
				fprintf( stdout, "\n" );
			}
			d_keisu0 = d_keisu;
		    } else
		    fprintf( stdout, "%4X : %8X,%09llX(%8X:%8X)\n",
			    PCR_PID[i],
			    PCR_addr[i],
			    PCR_LL, LL_H, LL_L );
		    L_PCR_addr = PCR_addr[i];
		}
	    }
	    if( pcr_count==0 )
	    {
	    	fprintf( stdout, "pcr_count=%d\n", pcr_count );
	    }
	    fprintf( stdout, "d_keisuL=%4.8f\n", d_keisuL );
	    }
	    if( mode==MODE_PCR_UPDATE )
		TsDump( srcFilename, outFilename, pids, nPid, -1 );
	    break;
	case MODE_CUT_END :
	    TsDump( srcFilename, outFilename, pids, nPid, 2 );
	    TsDump( srcFilename, outFilename, pids, nPid, -2 );
	    break;
	case MODE_PMT :
	    TsPMT( srcFilename, pids, nPid );
	    break;
	case MODE_PAT :
	    TsPAT( srcFilename );
	    break;
	case MODE_PID :
	    TsPid( srcFilename );
	    break;
	case MODE_CUT :
	    TsCut( srcFilename, outFilename, start, end, len );
	    break;
	case MODE_OFF :
	    TsOff( srcFilename, outFilename, pids );
	    break;
	case MODE_TEST :
	    TsTest( srcFilename, outFilename, start, pids[0] );
	    break;
	default :
	    fprintf( stdout, "Unknown mode (%d)\n", mode );
	    exit( 1 );
	}
	if( argc==1) {
	} else {
	}
}

